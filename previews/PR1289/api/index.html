<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DynamicPPL</title><meta name="title" content="API · DynamicPPL"/><meta property="og:title" content="API · DynamicPPL"/><meta property="twitter:title" content="API · DynamicPPL"/><meta name="description" content="Documentation for DynamicPPL."/><meta property="og:description" content="Documentation for DynamicPPL."/><meta property="twitter:description" content="Documentation for DynamicPPL."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body>
<!-- NAVBAR START -->
<style>
    @import url('https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap');

    /* Documenter.jl CSS Overrides */
    html {
        scroll-padding-top: calc(var(--navbar-height) + 1rem);
    }
    .docs-sidebar, #documenter {
        margin-top: var(--navbar-height);
    }
    .docs-version-selector {
        margin-bottom: 60px !important;
    }
    @media screen and (max-width: 1056px) {
        .docs-version-selector {
            margin-bottom: 60px !important;
        }
        .docs-sidebar {
            margin-top: 0 !important;
        }
    }
    /* End of Documenter.jl Tweaks */

    /* Color and Font Variables */
    :root {
        --heading-color: #6c757d;
        --item-color: rgb(165, 165, 165);
        --primary-bg: white;
        --hover-color: #8faad2;
        --deprecated-bg: #ff4d4d;
        --deprecated-text: white;
        --icon-color: #6c757d;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --dropdown-hover-bg: #e9ecef;
        
        /* Typography */
        --font-family: "Source Sans Pro", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        --nav-link-font-size: 1.0625rem;
        --turing-title-font-size: 21.25px;
        --icon-font-size: 1.25rem;
        --dropdown-arrow-font-size: 0.6875rem;
        --badge-font-size: 0.75rem;

        /* Sizing and Spacing */
        --navbar-height: 3.75rem;
        --logo-height: 31px;
        --logo-width: auto;
        --logo-padding-top: 7px;
        --logo-margin-left: 0.8rem;
        --title-margin-left: 0.4px;
        --title-nav-spacing: 1.1rem;
        --nav-item-margin-left: 1.3rem;
        --icon-margin-left: 1rem;
        --dropdown-padding: 1.875rem;
        --dropdown-item-width: 12.5rem;
        --dropdown-subitem-width: 15.625rem;
        --dropdown-subitem-padding: 0.125rem 0.625rem;
    }

    /* Dark Theme Variable Overrides */
    html.theme--documenter-dark {
        --heading-color: #e0e0e0;
        --item-color: #bdbdbd;
        --primary-bg: #1f2424;
        --hover-color: #ffffff;
        --icon-color: #e0e0e0;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #424242;
    }

    /* Catppuccin Theme Overrides */
    html.theme--catppuccin-latte {
        --heading-color: #4c4f69;
        --primary-bg: #eff1f5;
        --icon-color: #4c4f69;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --dropdown-hover-bg: #e6e9ef;
    }
    html.theme--catppuccin-frappe {
        --heading-color: #c6d0f5;
        --primary-bg: #303446;
        --icon-color: #c6d0f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #51576d;
    }
    html.theme--catppuccin-macchiato {
        --heading-color: #cad3f5;
        --primary-bg: #24273a;
        --icon-color: #cad3f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #494d64;
    }
    html.theme--catppuccin-mocha {
        --heading-color: #cad3f5;
        --primary-bg: #1e1e2e;
        --icon-color: #cad3f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #45475a;
    }


    /* Main Navigation Bar */
    .ext-navigation {
        font-family: var(--font-family);
        position: fixed;
        height: var(--navbar-height);
        top: 0;
        width: 100%;
        background-color: var(--primary-bg);
        z-index: 1000;
        box-shadow: 0 2px 4px var(--shadow-color);
        display: flex;
        align-items: center;
        padding: 0 1.0625rem;
        transition: transform 0.3s, background-color 0.3s;
    }

    nav.ext-navigation .ext-navbar-logo {
        margin-left: var(--logo-margin-left);
        height: auto;
        max-height: var(--logo-height);
        width: auto;
        padding-top: var(--logo-padding-top);
    }
    
    /* Theme-aware logo text color */
    .ext-navbar-logo .logo-text {
        fill: var(--heading-color);
    }
    
    .ext-navbar-title {
        color: var(--heading-color) !important;
        font-size: var(--turing-title-font-size) !important;
        margin-left: var(--title-margin-left);
        text-decoration: none;
        transition: color 0.2s ease;
    }
    
    .ext-navbar-title:hover {
        color: var(--hover-color) !important;
    }

    .ext-nav-links {
        display: flex;
        align-items: center;
        list-style-type: none;
        margin: 0;
        padding: 0;
        flex-grow: 1;
        margin-left: var(--title-nav-spacing);
    }

    .ext-nav-links li:first-child {
        margin-left: 0 !important;
    }

    .ext-nav-links li {
        margin-left: var(--nav-item-margin-left) !important;
    }

    .ext-nav-link {
        color: var(--heading-color) !important;
        text-decoration: none;
        font-size: var(--nav-link-font-size) !important;
        transition: color 0.2s ease;
        cursor: pointer;
    }

    .ext-nav-link:hover,
    .ext-navbar-item-single a:hover,
    .ext-navbar-icons a:hover {
        color: var(--hover-color) !important;
    }

    .ext-navbar-item-single a {
        color: var(--heading-color) !important;
    }
    
    .ext-navbar-icons {
        display: flex;
        align-items: center;
    }

    .ext-navbar-icons a {
        color: var(--icon-color) !important;
        font-size: var(--icon-font-size) !important;
        transition: color 0.2s ease;
        margin-left: var(--icon-margin-left);
    }

    .ext-menu-toggle {
        display: none;
        font-size: 1.5rem;
        color: var(--heading-color);
        cursor: pointer;
    }

    .ext-dropdown {
        display: none;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        padding: var(--dropdown-padding);
        position: absolute;
        top: var(--navbar-height);
        width: 100%;
        left: 0;
        background-color: var(--primary-bg);
        line-height: 1.875rem;
        opacity: 0;
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out, background-color 0.3s;
        transform: translateY(-0.625rem);
        box-shadow: 0 4px 6px var(--shadow-color);
    }

    #library-handler::after {
        content: "▼";
        font-size: var(--dropdown-arrow-font-size);
        margin-left: 0.3125rem;
        transition: transform 0.3s ease-in-out;
    }

    #library-handler.open::after {
        content: "▲";
    }

    .ext-dropdown.show {
        display: grid;
        opacity: 1;
        transform: translateY(0);
    }

    .ext-dropdown ul {
        width: var(--dropdown-item-width);
        margin-bottom: 1.25rem;
    }

    .ext-dropdown ul li {
        text-align: left;
        display: flex;
        align-items: center;
    }

    .ext-dropdown ul a li {
        color: var(--item-color);
        width: var(--dropdown-subitem-width);
        border-radius: 3px;
        padding: var(--dropdown-subitem-padding);
        transition: background-color 0.2s ease;
    }

    .ext-dropdown ul a li:hover {
        background-color: var(--dropdown-hover-bg);
    }

    .ext-dropdown-item-heading {
        color: var(--heading-color);
        text-align: center;
    }

    .deprecated-badge {
        background-color: var(--deprecated-bg);
        color: var(--deprecated-text);
        font-size: var(--badge-font-size);
        padding: .1rem;
        border-radius: 3px;
        margin-left: 0.5rem;
        line-height: 1;
    }

    @media (max-width: 966px) {
        .ext-dropdown {
            grid-template-columns: 1fr 1fr 1fr;
        }
    }

    @media (max-width: 768px) {
        .ext-nav-links {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            background-color: var(--primary-bg);
            position: absolute;
            top: var(--navbar-height);
            left: 0;
            padding: 0.625rem 0;
            height: auto;
            overflow-y: auto;
            box-shadow: 0 4px 6px var(--shadow-color);
            margin-left: 0;
        }

        .ext-nav-links.show {
            display: flex;
        }

        .ext-nav-links li {
            margin: 0.625rem 0 !important;
            text-align: center;
        }
        
        .ext-menu-toggle {
            display: block;
            margin-left: auto;
        }

        .ext-navigation.hide {
            transform: translateY(calc(-1 * var(--navbar-height)));
        }

        .ext-dropdown {
            position: static;
            display: block;
            opacity: 1;
            transform: none;
            box-shadow: none;
            grid-template-columns: 1fr;
            padding: 0.625rem;
            text-align: center;
        }

        .ext-dropdown ul {
            width: auto;
            display: inline-block;
            margin: 0 auto 0.3125rem;
            text-align: left;
        }
    }
</style>
<nav class="ext-navigation">
    <a href="https://turinglang.org/">
        <svg width="4333" height="1145" viewBox="0 0 4333 1145" fill="none" xmlns="http://www.w3.org/2000/svg" class="ext-navbar-logo">
            <path class="logo-text" d="M0.44603 193.181V66.9868H663.471V193.181H406.62V898H257.297V193.181H0.44603ZM1097.24 635.874V274.74H1244.13V898H1101.7V787.225H1095.21C1081.14 822.121 1058.01 850.66 1025.82 872.842C993.902 895.024 954.542 906.115 907.744 906.115C866.896 906.115 830.783 897.053 799.403 878.929C768.295 860.534 743.948 833.889 726.365 798.993C708.782 763.826 699.99 721.356 699.99 671.581V274.74H846.878V648.858C846.878 688.353 857.699 719.733 879.34 742.997C900.981 766.261 929.385 777.893 964.551 777.893C986.192 777.893 1007.16 772.618 1027.45 762.068C1047.73 751.518 1064.37 735.828 1077.35 714.999C1090.61 693.899 1097.24 667.524 1097.24 635.874ZM1395.17 898V274.74H1537.6V378.617H1544.09C1555.45 342.639 1574.93 314.911 1602.52 295.434C1630.38 275.687 1662.17 265.813 1697.88 265.813C1705.99 265.813 1715.05 266.219 1725.06 267.031C1735.34 267.572 1743.86 268.518 1750.63 269.871V404.992C1744.4 402.828 1734.53 400.934 1721 399.311C1707.75 397.417 1694.9 396.471 1682.46 396.471C1655.68 396.471 1631.6 402.287 1610.23 413.919C1589.13 425.28 1572.49 441.105 1560.32 461.393C1548.15 481.682 1542.06 505.081 1542.06 531.591V898H1395.17ZM1848.21 898V274.74H1995.1V898H1848.21ZM1922.06 186.283C1898.8 186.283 1878.78 178.573 1862.01 163.154C1845.24 147.464 1836.85 128.664 1836.85 106.752C1836.85 84.5701 1845.24 65.7695 1862.01 50.3503C1878.78 34.6606 1898.8 26.8158 1922.06 26.8158C1945.6 26.8158 1965.61 34.6606 1982.12 50.3503C1998.89 65.7695 2007.27 84.5701 2007.27 106.752C2007.27 128.664 1998.89 147.464 1982.12 163.154C1965.61 178.573 1945.6 186.283 1922.06 186.283ZM2293.04 532.809V898H2146.15V274.74H2286.54V380.646H2293.85C2308.18 345.75 2331.04 318.022 2362.42 297.463C2394.07 276.904 2433.16 266.625 2479.69 266.625C2522.7 266.625 2560.17 275.822 2592.09 294.217C2624.28 312.612 2649.17 339.257 2666.75 374.153C2684.6 409.049 2693.39 451.385 2693.12 501.159V898H2546.24V523.882C2546.24 482.223 2535.41 449.626 2513.77 426.092C2492.4 402.557 2462.78 390.79 2424.91 390.79C2399.21 390.79 2376.35 396.471 2356.34 407.832C2336.59 418.923 2321.03 435.019 2309.67 456.119C2298.58 477.218 2293.04 502.782 2293.04 532.809ZM3113.5 1144.71C3060.75 1144.71 3015.44 1137.54 2977.57 1123.2C2939.7 1109.13 2909.26 1090.2 2886.27 1066.39C2863.28 1042.59 2847.32 1016.21 2838.39 987.269L2970.67 955.213C2976.62 967.386 2985.28 979.424 2996.64 991.327C3008 1003.5 3023.28 1013.51 3042.49 1021.35C3061.97 1029.47 3086.45 1033.53 3115.93 1033.53C3157.59 1033.53 3192.08 1023.38 3219.4 1003.09C3246.73 983.076 3260.39 950.074 3260.39 904.087V786.008H3253.08C3245.51 801.157 3234.42 816.711 3219.81 832.671C3205.47 848.632 3186.4 862.022 3162.6 872.842C3139.06 883.663 3109.44 889.073 3073.73 889.073C3025.85 889.073 2982.44 877.847 2943.48 855.394C2904.8 832.671 2873.96 798.857 2850.97 753.952C2828.24 708.777 2816.88 652.24 2816.88 584.341C2816.88 515.902 2828.24 458.147 2850.97 411.078C2873.96 363.739 2904.93 327.896 2943.89 303.55C2982.84 278.933 3026.26 266.625 3074.14 266.625C3110.66 266.625 3140.69 272.847 3164.22 285.29C3188.03 297.463 3206.96 312.206 3221.03 329.519C3235.09 346.561 3245.78 362.657 3253.08 377.805H3261.2V274.74H3406.06V908.144C3406.06 961.435 3393.34 1005.53 3367.92 1040.42C3342.49 1075.32 3307.73 1101.43 3263.63 1118.74C3219.54 1136.05 3169.5 1144.71 3113.5 1144.71ZM3114.72 773.835C3145.83 773.835 3172.34 766.261 3194.25 751.112C3216.16 735.963 3232.79 714.187 3244.16 685.783C3255.52 657.379 3261.2 623.295 3261.2 583.53C3261.2 544.305 3255.52 509.95 3244.16 480.465C3233.07 450.979 3216.56 428.12 3194.65 411.89C3173.01 395.389 3146.37 387.138 3114.72 387.138C3081.98 387.138 3054.66 395.659 3032.75 412.701C3010.84 429.744 2994.34 453.143 2983.25 482.899C2972.16 512.385 2966.61 545.929 2966.61 583.53C2966.61 621.672 2972.16 655.08 2983.25 683.754C2994.61 712.158 3011.25 734.34 3033.16 750.3C3055.34 765.99 3082.53 773.835 3114.72 773.835ZM3647.08 906.927C3622.47 906.927 3601.37 898.271 3583.78 880.958C3566.2 863.645 3557.54 842.545 3557.82 817.658C3557.54 793.312 3566.2 772.482 3583.78 755.17C3601.37 737.857 3622.47 729.2 3647.08 729.2C3670.89 729.2 3691.58 737.857 3709.17 755.17C3727.02 772.482 3736.08 793.312 3736.35 817.658C3736.08 834.159 3731.75 849.173 3723.37 862.698C3715.25 876.224 3704.43 887.044 3690.91 895.16C3677.65 903.004 3663.04 906.927 3647.08 906.927ZM3888.01 274.74H4034.9V933.708C4034.9 978.613 4026.38 1015.67 4009.33 1044.89C3992.29 1074.1 3967.67 1095.88 3935.48 1110.22C3903.29 1124.55 3864.2 1131.72 3818.22 1131.72C3812.81 1131.72 3807.8 1131.59 3803.2 1131.32C3798.6 1131.32 3793.6 1131.18 3788.19 1130.91V1011.21C3792.25 1011.48 3795.9 1011.62 3799.15 1011.62C3802.39 1011.89 3805.77 1012.02 3809.29 1012.02C3837.42 1012.02 3857.58 1005.12 3869.75 991.327C3881.92 977.801 3888.01 957.918 3888.01 931.679V274.74ZM3961.05 186.283C3937.51 186.283 3917.36 178.573 3900.59 163.154C3884.09 147.464 3875.84 128.664 3875.84 106.752C3875.84 84.5701 3884.09 65.7695 3900.59 50.3503C3917.36 34.6606 3937.51 26.8158 3961.05 26.8158C3984.31 26.8158 4004.19 34.6606 4020.7 50.3503C4037.47 65.7695 4045.85 84.5701 4045.85 106.752C4045.85 128.664 4037.47 147.464 4020.7 163.154C4004.19 178.573 3984.31 186.283 3961.05 186.283ZM4332.83 66.9868V898H4185.94V66.9868H4332.83Z" fill="currentColor"/>
            <path d="M4076 108.5C4076 168.424 4027.42 217 3967.5 217C3907.58 217 3859 168.424 3859 108.5C3859 48.5762 3907.58 0 3967.5 0C4027.42 0 4076 48.5762 4076 108.5Z" fill="#389725"/>
            <path d="M3755 814.5C3755 874.424 3706.42 923 3646.5 923C3586.58 923 3538 874.424 3538 814.5C3538 754.576 3586.58 706 3646.5 706C3706.42 706 3755 754.576 3755 814.5Z" fill="#9457B1"/>
            <path d="M2030 108.5C2030 168.424 1981.42 217 1921.5 217C1861.58 217 1813 168.424 1813 108.5C1813 48.5762 1861.58 0 1921.5 0C1981.42 0 2030 48.5762 2030 108.5Z" fill="#CA3B33"/>
        </svg>
    </a>
    <!-- <a class="ext-navbar-title" href="https://turinglang.org/">Turing.jl</a> -->
    
    <ul class="ext-nav-links">
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/getting-started/">Get Started</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/tutorials/">Tutorials</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/faq/">FAQ</a></li>
        <li>
            <p class="ext-nav-link" id="library-handler">Libraries</p>
            <div class="ext-dropdown" id="ext-dropdown-items">
                <ul>
                    <li class="ext-dropdown-item-heading">Modelling Languages</li>
                    <a href="https://turinglang.org/DynamicPPL.jl/"><li>DynamicPPL</li></a>
                    <a href="https://turinglang.org/JuliaBUGS.jl/"><li>JuliaBUGS</li></a>
                    <a href="https://turinglang.org/TuringGLM.jl/"><li>TuringGLM</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">MCMC</li>
                    <a href="https://turinglang.org/AdvancedHMC.jl/"><li>AdvancedHMC</li></a>
                    <a href="https://turinglang.org/AbstractMCMC.jl/"><li>AbstractMCMC</li></a>
                    <a href="https://github.com/theogf/ThermodynamicIntegration.jl"><li>ThermodynamicIntegration</li></a>
                    <a href="https://turinglang.org/AdvancedPS.jl/"><li>AdvancedPS</li></a>
                    <a href="https://turinglang.org/SliceSampling.jl/"><li>SliceSampling</li></a>
                    <a href="https://turinglang.org/EllipticalSliceSampling.jl/"><li>EllipticalSliceSampling</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">Diagnostics</li>
                    <a href="https://turinglang.org/MCMCChains.jl/"><li>MCMCChains</li></a>
                    <a href="https://turinglang.org/MCMCDiagnosticTools.jl/"><li>MCMCDiagnosticTools</li></a>
                    <a href="https://chalk-lab.github.io/ParetoSmooth.jl/"><li>ParetoSmooth</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">Gaussian Processes</li>
                    <a href="https://juliagaussianprocesses.github.io/AbstractGPs.jl/"><li>AbstractGPs</li></a>
                    <a href="https://juliagaussianprocesses.github.io/KernelFunctions.jl/"><li>KernelFunctions</li></a>
                    <a href="https://juliagaussianprocesses.github.io/ApproximateGPs.jl/"><li>ApproximateGPs</li></a>
                </ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/Bijectors.jl/">Bijectors</a></li></ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/TuringCallbacks.jl/">TuringCallbacks</a></li></ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/Deprecated/TuringBenchmarking/">TuringBenchmarking</a><span class="deprecated-badge">Deprecated</span></li></ul>
            </div>
        </li>
        <li><a class="ext-nav-link" href="https://turinglang.org/news/">News</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/team/">Team</a></li>
    </ul>

    <div class="ext-navbar-icons">
        <a href="https://x.com/TuringLang" aria-label="Turing on X"><i class="fa-brands fa-x-twitter"></i></a>
        <a href="https://discourse.julialang.org/c/domain/probprog/48" aria-label="Turing on Discourse"><i class="fa-brands fa-discourse"></i></a>
        <a href="https://julialang.slack.com/archives/CCYDC34A0" aria-label="Turing on Slack"><i class="fa-brands fa-slack"></i></a>
        <a href="https://github.com/TuringLang/" aria-label="Turing.jl on GitHub"><i class="fa-brands fa-github"></i></a>
    </div>

    <span class="ext-menu-toggle"><i class="fa-solid fa-bars"></i></span>
</nav>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const menuToggle = document.querySelector(".ext-menu-toggle");
        const navLinks = document.querySelector(".ext-nav-links");
        const nav = document.querySelector(".ext-navigation");
        const libraryHandler = document.getElementById("library-handler");
        const dropdownContainer = document.getElementById("ext-dropdown-items");
        let lastScrollY = window.scrollY;

        function closeDropdown() {
            if (dropdownContainer.classList.contains("show")) {
                libraryHandler.classList.remove("open");
                dropdownContainer.classList.remove("show");
                setTimeout(() => {
                    if (!dropdownContainer.classList.contains("show")) {
                        dropdownContainer.style.display = "none";
                    }
                }, 300);
            }
        }

        function openDropdown() {
            dropdownContainer.style.display = "grid";
            libraryHandler.classList.add("open");
            setTimeout(() => {
                dropdownContainer.classList.add("show");
            }, 10);
        }

        function setAppropriateHeight() {
            if (window.innerWidth <= 768) {
                const viewportHeight = window.innerHeight;
                const navHeight = nav.offsetHeight;
                navLinks.style.maxHeight = `${viewportHeight - navHeight}px`;
                navLinks.style.overflowY = "auto";
            } else {
                navLinks.style.maxHeight = "";
                navLinks.style.overflowY = "";
            }
        }

        menuToggle.addEventListener("click", (event) => {
            event.stopPropagation();
            navLinks.classList.toggle("show");
            if (navLinks.classList.contains("show")) {
                setAppropriateHeight();
                closeDropdown();
                dropdownContainer.style.display = "none";
            }
        });

        libraryHandler.addEventListener("click", (event) => {
            event.stopPropagation();
            event.preventDefault();
            if (dropdownContainer.classList.contains("show")) {
                closeDropdown();
            } else {
                openDropdown();
            }
            setAppropriateHeight();
        });

        // Close all menus if a click is registered outside the navigation bar.
        document.addEventListener("click", (event) => {
            if (!nav.contains(event.target)) {
                navLinks.classList.remove("show");
                closeDropdown();
            }
        });

        // Hide navigation bar on scroll down in mobile view.
        window.addEventListener("scroll", () => {
            if (window.innerWidth <= 768) {
                if (window.scrollY > lastScrollY && window.scrollY > nav.offsetHeight){
                    nav.classList.add("hide");
                } else {
                    nav.classList.remove("hide");
                }
                lastScrollY = window.scrollY;
            }
        });

        window.addEventListener("resize", setAppropriateHeight);
    });
</script>
<!-- NAVBAR END -->



<div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="DynamicPPL logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DynamicPPL</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../conditionfix/">Conditioning and fixing</a></li><li><span class="tocitem">VarNamedTuple</span><ul><li><a class="tocitem" href="../vnt/motivation/">Motivation</a></li><li><a class="tocitem" href="../vnt/design/">Design</a></li><li><a class="tocitem" href="../vnt/implementation/">Implementation</a></li><li><a class="tocitem" href="../vnt/arraylikeblocks/">Array-like blocks</a></li></ul></li><li><a class="tocitem" href="../evaluation/">Model evaluation</a></li><li><a class="tocitem" href="../tilde/">Tilde-statements</a></li><li><a class="tocitem" href="../init/">Initialisation strategies</a></li><li><a class="tocitem" href="../transforms/">Transform strategies</a></li><li><span class="tocitem">Accumulators</span><ul><li><a class="tocitem" href="../accs/overview/">Overview</a></li><li><a class="tocitem" href="../accs/existing/">Existing accumulators in DynamicPPL</a></li><li><a class="tocitem" href="../accs/threadsafe/">Thread-safe accumulation</a></li><li><a class="tocitem" href="../accs/values/">Storing vectorised vs. raw values</a></li></ul></li><li><span class="tocitem">LogDensityFunction</span><ul><li><a class="tocitem" href="../ldf/overview/">Overview</a></li><li><a class="tocitem" href="../ldf/models/">Using LDFs in model evaluation</a></li></ul></li><li><a class="tocitem" href="../migration/">Migrating old VarInfo code</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Model"><span>Model</span></a></li><li><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li><li><a class="tocitem" href="#Condition-and-decondition"><span>Condition and decondition</span></a></li><li><a class="tocitem" href="#Fixing-and-unfixing"><span>Fixing and unfixing</span></a></li><li><a class="tocitem" href="#Predicting"><span>Predicting</span></a></li><li><a class="tocitem" href="#Marginalisation"><span>Marginalisation</span></a></li><li><a class="tocitem" href="#Models-within-models"><span>Models within models</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#AD-testing-and-benchmarking-utilities"><span>AD testing and benchmarking utilities</span></a></li><li><a class="tocitem" href="#Demo-models"><span>Demo models</span></a></li><li><a class="tocitem" href="#Debugging-Utilities"><span>Debugging Utilities</span></a></li><li><a class="tocitem" href="#Advanced"><span>Advanced</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TuringLang/DynamicPPL.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/TuringLang/DynamicPPL.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>Part of the API of DynamicPPL is defined in the more lightweight interface package <a href="https://github.com/TuringLang/AbstractPPL.jl">AbstractPPL.jl</a> and reexported here.</p><h2 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h2><h3 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h3><p>A core component of DynamicPPL is the <a href="#DynamicPPL.@model"><code>@model</code></a> macro. It can be used to define probabilistic models in an intuitive way by specifying random variables and their distributions with <code>~</code> statements. These statements are rewritten by <code>@model</code> as calls of internal functions for sampling the variables and computing their log densities.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.@model"><a class="docstring-binding" href="#DynamicPPL.@model"><code>DynamicPPL.@model</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@model(expr[, warn = false])</code></pre><p>Macro to specify a probabilistic model.</p><p>If <code>warn</code> is <code>true</code>, a warning is displayed if internal variable names are used in the model definition.</p><p><strong>Examples</strong></p><p>Model definition:</p><pre><code class="language-julia hljs">@model function model(x, y = 42)
    ...
end</code></pre><p>To generate a <code>Model</code>, call <code>model(xvalue)</code> or <code>model(xvalue, yvalue)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/compiler.jl#L248-L267">source</a></section></details></article><h3 id="Type"><a class="docs-heading-anchor" href="#Type">Type</a><a id="Type-1"></a><a class="docs-heading-anchor-permalink" href="#Type" title="Permalink"></a></h3><p>A <a href="#Model"><code>Model</code></a> can be created by calling the model function, as defined by <a href="#DynamicPPL.@model"><code>@model</code></a>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.Model"><a class="docstring-binding" href="#DynamicPPL.Model"><code>DynamicPPL.Model</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Model{F,argnames,defaultnames,missings,Targs,Tdefaults,Ctx&lt;:AbstractContext,Threaded}
    f::F
    args::NamedTuple{argnames,Targs}
    defaults::NamedTuple{defaultnames,Tdefaults}
    context::Ctx=DefaultContext()
end</code></pre><p>A <code>Model</code> struct with model evaluation function of type <code>F</code>, arguments of names <code>argnames</code> types <code>Targs</code>, default arguments of names <code>defaultnames</code> with types <code>Tdefaults</code>, missing arguments <code>missings</code>, and evaluation context of type <code>Ctx</code>.</p><p>Here <code>argnames</code>, <code>defaultargnames</code>, and <code>missings</code> are tuples of symbols, e.g. <code>(:a, :b)</code>. <code>context</code> is by default <code>DefaultContext()</code>.</p><p>An argument with a type of <code>Missing</code> will be in <code>missings</code> by default. However, in non-traditional use-cases <code>missings</code> can be defined differently. All variables in <code>missings</code> are treated as random variables rather than observations.</p><p>The <code>Threaded</code> type parameter indicates whether the model requires threadsafe evaluation (i.e., whether the model contains statements which modify the internal VarInfo that are executed in parallel). By default, this is set to <code>false</code>.</p><p>The default arguments are used internally when constructing instances of the same model with different arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Model(f, (x = 1.0, y = 2.0))
Model{typeof(f),(:x, :y),(),(),Tuple{Float64,Float64},Tuple{}}(f, (x = 1.0, y = 2.0), NamedTuple())

julia&gt; Model(f, (x = 1.0, y = 2.0), (x = 42,))
Model{typeof(f),(:x, :y),(:x,),(),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))

julia&gt; Model{(:y,)}(f, (x = 1.0, y = 2.0), (x = 42,)) # with special definition of missings
Model{typeof(f),(:x, :y),(:x,),(:y,),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L1-L39">source</a></section></details></article><p><a href="#Model"><code>Model</code></a>s are callable structs.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.Model-Tuple{}"><a class="docstring-binding" href="#DynamicPPL.Model-Tuple{}"><code>DynamicPPL.Model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(model::Model)([rng, varinfo])</code></pre><p>Sample from the prior of the <code>model</code> with random number generator <code>rng</code>.</p><p>Returns the model&#39;s return value.</p><p>Note that calling this with an existing <code>varinfo</code> object will mutate it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L750-L758">source</a></section></details></article><p>Basic properties of a model can be accessed with <a href="#DynamicPPL.getargnames"><code>getargnames</code></a>, <a href="#DynamicPPL.getmissings"><code>getmissings</code></a>, and <a href="#Base.nameof-Tuple{Model}"><code>nameof</code></a>.</p><article><details class="docstring" open="true"><summary id="Base.nameof-Tuple{Model}"><a class="docstring-binding" href="#Base.nameof-Tuple{Model}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nameof(model::Model)</code></pre><p>Get the name of the <code>model</code> as <code>Symbol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L978-L982">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getargnames"><a class="docstring-binding" href="#DynamicPPL.getargnames"><code>DynamicPPL.getargnames</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getargnames(model::Model)</code></pre><p>Get a tuple of the argument names of the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L964-L968">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getmissings"><a class="docstring-binding" href="#DynamicPPL.getmissings"><code>DynamicPPL.getmissings</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getmissings(model::Model)</code></pre><p>Get a tuple of the names of the missing arguments of the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L971-L975">source</a></section></details></article><p>The context of a model can be set using <a href="#DynamicPPL.contextualize"><code>contextualize</code></a>:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.contextualize"><a class="docstring-binding" href="#DynamicPPL.contextualize"><code>DynamicPPL.contextualize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">contextualize(model::Model, context::AbstractContext)</code></pre><p>Return a new <code>Model</code> with the same evaluation function and other arguments, but with its underlying context set to <code>context</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L109-L114">source</a></section></details></article><p>Some models require threadsafe evaluation (see <a href="https://turinglang.org/docs/usage/threadsafe-evaluation/">the Turing docs</a> for more information on when this is necessary). If this is the case, one must enable threadsafe evaluation for a model:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.setthreadsafe"><a class="docstring-binding" href="#DynamicPPL.setthreadsafe"><code>DynamicPPL.setthreadsafe</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setthreadsafe(model::Model, threadsafe::Bool)</code></pre><p>Returns a new <code>Model</code> with its threadsafe flag set to <code>threadsafe</code>.</p><p>Threadsafe evaluation ensures correctness when executing model statements that mutate the internal <code>VarInfo</code> object in parallel. For example, this is needed if tilde-statements are nested inside <code>Threads.@threads</code> or similar constructs.</p><p>It is not needed for generic multithreaded operations that don&#39;t involve VarInfo. For example, calculating a log-likelihood term in parallel and then calling <code>@addlogprob!</code> outside of the parallel region is safe without needing to set <code>threadsafe=true</code>.</p><p>It is also not needed for multithreaded sampling with AbstractMCMC&#39;s <code>MCMCThreads()</code>.</p><p>Setting <code>threadsafe</code> to <code>true</code> increases the overhead in evaluating the model. Please see <a href="https://turinglang.org/docs/usage/threadsafe-evaluation/">the Turing.jl docs</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L129-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.requires_threadsafe"><a class="docstring-binding" href="#DynamicPPL.requires_threadsafe"><code>DynamicPPL.requires_threadsafe</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">requires_threadsafe(model::Model)</code></pre><p>Return whether <code>model</code> has been marked as needing threadsafe evaluation (using <code>setthreadsafe</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L97-L102">source</a></section></details></article><h2 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h2><p>With <a href="#Base.rand"><code>rand</code></a> one can draw samples from the prior distribution of a <a href="#Model"><code>Model</code></a>.</p><article><details class="docstring" open="true"><summary id="Base.rand"><a class="docstring-binding" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rand([rng=Random.default_rng()], model::Model)</code></pre><p>Sample a <code>VarNamedTuple</code> of raw values from the prior of <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L986-L990">source</a></section></details></article><p>One can also evaluate the log prior, log likelihood, and log joint probability.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.logprior"><a class="docstring-binding" href="#DynamicPPL.logprior"><code>DynamicPPL.logprior</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logprior(model::Model, params)
logprior(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log prior probability of variables <code>params</code> for the probabilistic <code>model</code>, or the log prior of the data in <code>varinfo</code> if provided.</p><p>Note that this probability always refers to the parameters in unlinked space, i.e., the return value of <code>logprior</code> does not depend on whether <code>VarInfo</code> has been linked or not.</p><p>See also <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1.0)
           end
       end
demo (generic function with 2 methods)

julia&gt; # Using a `NamedTuple`.
       logprior(demo([1.0]), (m = 100.0, ))
-5000.918938533205

julia&gt; # Using a `OrderedDict`.
       logprior(demo([1.0]), OrderedDict(@varname(m) =&gt; 100.0))
-5000.918938533205

julia&gt; # Truth.
       logpdf(Normal(), 100.0)
-5000.918938533205</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L1044-L1078">source</a></section><section><div><pre><code class="language-julia hljs">logprior(model::DynamicPPL.Model, chain::MCMCChains.Chains)</code></pre><p>Return an array of log prior probabilities evaluated at each sample in an MCMC <code>chain</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MCMCChains, Distributions

julia&gt; @model function demo_model(x)
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, sqrt(s))
           for i in eachindex(x)
               x[i] ~ Normal(m, sqrt(s))
           end
       end;

julia&gt; # Construct a chain of samples using MCMCChains.
       # This sets s = 0.5 and m = 1.0 for all three samples.
       chain = Chains(repeat([0.5 1.0;;;], 3, 1, 1), [:s, :m]);

julia&gt; logprior(demo_model([1., 2.]), chain)
3×1 Matrix{Float64}:
 -3.2956988239086447
 -3.2956988239086447
 -3.2956988239086447</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMCMCChainsExt.jl#L602-L630">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.loglikelihood"><a class="docstring-binding" href="#StatsAPI.loglikelihood"><code>StatsAPI.loglikelihood</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">loglikelihood(model::Model, params)
loglikelihood(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log likelihood of variables <code>params</code> for the probabilistic <code>model</code>, or the log likelihood of the data in <code>varinfo</code> if provided.</p><p>See also <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#DynamicPPL.logprior"><code>logprior</code></a>.</p><p><strong>Examples</strong></p><p>```jldoctest; setup=:(using Distributions) julia&gt; @model function demo(x)            m ~ Normal()            for i in eachindex(x)                x[i] ~ Normal(m, 1.0)            end        end demo (generic function with 2 methods)</p><p>julia&gt; # Using a <code>NamedTuple</code>.        loglikelihood(demo([1.0]), (m = 100.0, )) -4901.418938533205</p><p>julia&gt; # Using a <code>OrderedDict</code>.        loglikelihood(demo([1.0]), OrderedDict(@varname(m) =&gt; 100.0)) -4901.418938533205</p><p>julia&gt; # Truth.        logpdf(Normal(100.0, 1.0), 1.0) -4901.418938533205</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L1088-L1118">source</a></section><section><div><pre><code class="language-julia hljs">loglikelihood(model::DynamicPPL.Model, chain::MCMCChains.Chains)</code></pre><p>Return an array of log likelihoods evaluated at each sample in an MCMC <code>chain</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MCMCChains, Distributions

julia&gt; @model function demo_model(x)
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, sqrt(s))
           for i in eachindex(x)
               x[i] ~ Normal(m, sqrt(s))
           end
       end;

julia&gt; # Construct a chain of samples using MCMCChains.
       # This sets s = 0.5 and m = 1.0 for all three samples.
       chain = Chains(repeat([0.5 1.0;;;], 3, 1, 1), [:s, :m]);

julia&gt; loglikelihood(demo_model([1., 2.]), chain)
3×1 Matrix{Float64}:
 -2.1447298858494
 -2.1447298858494
 -2.1447298858494</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMCMCChainsExt.jl#L565-L592">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.logjoint"><a class="docstring-binding" href="#DynamicPPL.logjoint"><code>DynamicPPL.logjoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logjoint(model::Model, params)
logjoint(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log joint probability of variables <code>params</code> for the probabilistic <code>model</code>, or the log joint of the data in <code>varinfo</code> if provided.</p><p>Note that this probability always refers to the parameters in unlinked space, i.e., the return value of <code>logjoint</code> does not depend on whether <code>VarInfo</code> has been linked or not.</p><p>See also <a href="#DynamicPPL.logprior"><code>logprior</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1.0)
           end
       end
demo (generic function with 2 methods)

julia&gt; # Using a `NamedTuple`.
       logjoint(demo([1.0]), (m = 100.0, ))
-9902.33787706641

julia&gt; # Using a `OrderedDict`.
       logjoint(demo([1.0]), OrderedDict(@varname(m) =&gt; 100.0))
-9902.33787706641

julia&gt; # Truth.
       logpdf(Normal(100.0, 1.0), 1.0) + logpdf(Normal(), 100.0)
-9902.33787706641</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L998-L1032">source</a></section><section><div><pre><code class="language-julia hljs">logjoint(model::Model, chain::MCMCChains.Chains)</code></pre><p>Return an array of log joint probabilities evaluated at each sample in an MCMC <code>chain</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MCMCChains, Distributions

julia&gt; @model function demo_model(x)
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, sqrt(s))
           for i in eachindex(x)
               x[i] ~ Normal(m, sqrt(s))
           end
       end;

julia&gt; # Construct a chain of samples using MCMCChains.
       # This sets s = 0.5 and m = 1.0 for all three samples.
       chain = Chains(repeat([0.5 1.0;;;], 3, 1, 1), [:s, :m]);

julia&gt; logjoint(demo_model([1., 2.]), chain)
3×1 Matrix{Float64}:
 -5.440428709758045
 -5.440428709758045
 -5.440428709758045</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMCMCChainsExt.jl#L524-L552">source</a></section></details></article><h3 id="LogDensityProblems.jl-interface"><a class="docs-heading-anchor" href="#LogDensityProblems.jl-interface">LogDensityProblems.jl interface</a><a id="LogDensityProblems.jl-interface-1"></a><a class="docs-heading-anchor-permalink" href="#LogDensityProblems.jl-interface" title="Permalink"></a></h3><p>The <a href="https://github.com/tpapp/LogDensityProblems.jl">LogDensityProblems.jl</a> interface is also supported by wrapping a <a href="#Model"><code>Model</code></a> in a <code>DynamicPPL.LogDensityFunction</code>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.LogDensityFunction"><a class="docstring-binding" href="#DynamicPPL.LogDensityFunction"><code>DynamicPPL.LogDensityFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.LogDensityFunction(
    model::Model,
    getlogdensity::Any=getlogjoint_internal,
    vnt_or_vi::Union{VarNamedTuple,VarInfo,OnlyAccsVarInfo}=VarInfo(model).values,
    accs::Union{NTuple{&lt;:Any,AbstractAccumulator},AccumulatorTuple}=DynamicPPL.ldf_accs(getlogdensity);
    adtype::Union{ADTypes.AbstractADType,Nothing}=nothing,
)</code></pre><p>A struct which contains a model, along with all the information necessary to:</p><ul><li>calculate its log density at a given point;</li><li>and if <code>adtype</code> is provided, calculate the gradient of the log density at that point.</li></ul><p>This information can be extracted using the LogDensityProblems.jl interface, specifically, using <code>LogDensityProblems.logdensity</code> and <code>LogDensityProblems.logdensity_and_gradient</code>. If <code>adtype</code> is nothing, then only <code>logdensity</code> is implemented. If <code>adtype</code> is a concrete AD backend type, then <code>logdensity_and_gradient</code> is also implemented.</p><p><code>getlogdensity</code> should be a callable which takes a single argument: an <code>OnlyAccsVarInfo</code>, and returns a <code>Real</code> corresponding to the log density of interest. There are several functions in DynamicPPL that are &#39;supported&#39; out of the box:</p><ul><li><a href="#DynamicPPL.getlogjoint_internal"><code>getlogjoint_internal</code></a>: calculate the log joint, including the log-Jacobian term for any variables that have been linked in the provided VarInfo.</li><li><a href="#DynamicPPL.getlogprior_internal"><code>getlogprior_internal</code></a>: calculate the log prior, including the log-Jacobian term for any variables that have been linked in the provided VarInfo.</li><li><a href="#DynamicPPL.getlogjoint"><code>getlogjoint</code></a>: calculate the log joint in the model space, ignoring any effects of linking</li><li><a href="#DynamicPPL.getlogprior"><code>getlogprior</code></a>: calculate the log prior in the model space, ignoring any effects of linking</li><li><a href="#DynamicPPL.getloglikelihood"><code>getloglikelihood</code></a>: calculate the log likelihood (this is unaffected by linking, since transforms are only applied to random variables)</li></ul><div class="admonition is-info" id="Note-d2bc8ab177671010"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d2bc8ab177671010" title="Permalink"></a></header><div class="admonition-body"><p>By default, <code>LogDensityFunction</code> uses <code>getlogjoint_internal</code>, i.e., the result of <code>LogDensityProblems.logdensity(f, x)</code> will depend on whether the <code>LogDensityFunction</code> was created with a linked or unlinked VarInfo. This is done primarily to ease interoperability with MCMC samplers.</p></div></div><p><code>vnt</code> is a <code>VarNamedTuple</code> which contains vectorised representations of all the random variables in the model. You can create one manually, but for this argument, it is easier to pass either:</p><ul><li>an <code>oavi::OnlyAccsVarInfo</code> which contains a <code>VectorValueAccumulator</code>, in which case the values are taken from that accumulator (<strong>this approach is recommended going forward</strong>);</li><li>a <code>vi::VarInfo</code>, in which case the <code>vi.values</code> field is used.</li></ul><p><code>accs</code> allows you to specify an <code>AccumulatorTuple</code> or a tuple of <code>AbstractAccumulator</code>s which will be used <em>when evaluating the log density</em><code>. (Note that any accumulators from the previous argument are discarded.) By default, this uses an internal function,</code>DynamicPPL.ldf_accs`, which attempts to choose an appropriate set of accumulators based on which kind of log-density is being calculated.</p><p>If the <code>adtype</code> keyword argument is provided, then this struct will also store the adtype along with other information for efficient calculation of the gradient of the log density. Note that preparing a <code>LogDensityFunction</code> with an AD type <code>AutoBackend()</code> requires the AD backend itself to have been loaded (e.g. with <code>import Backend</code>).</p><p><strong>Fields</strong></p><p>Note that it is undefined behaviour to access any of a <code>LogDensityFunction</code>&#39;s fields, apart from:</p><ul><li><code>ldf.model</code>: The original model from which this <code>LogDensityFunction</code> was constructed.</li><li><code>ldf.adtype</code>: The AD type used for gradient calculations, or <code>nothing</code> if no AD type was provided.</li><li><code>ldf.transform_strategy</code>: The transform strategy that specifies which variables in the LogDensityFunction are linked or unlinked.</li></ul><p><strong>Extended help</strong></p><p>Up until DynamicPPL v0.38, there have been two ways of evaluating a DynamicPPL model at a given set of parameters:</p><ol><li><p>With <code>unflatten!!</code> + <code>evaluate!!</code> with <code>DefaultContext</code>: this stores a vector of parameters inside a VarInfo&#39;s metadata, then reads parameter values from the VarInfo during evaluation.</p></li><li><p>With <code>InitFromParams</code>: this reads parameter values from a NamedTuple or a Dict, and stores them inside a VarInfo&#39;s metadata.</p></li></ol><p>In general, both of these approaches work fine, but the fact that they modify the VarInfo&#39;s metadata can often be quite wasteful. In particular, it is very common that the only outputs we care about from model evaluation are those which are stored in accumulators, such as log probability densities, or raw values.</p><p>To avoid this issue, we use <code>OnlyAccsVarInfo</code>, which is a VarInfo that only contains accumulators. It implements enough of the <code>AbstractVarInfo</code> interface to not error during model evaluation.</p><p>Because <code>OnlyAccsVarInfo</code> does not store any parameter values, when evaluating a model with it, it is mandatory that parameters are provided from outside the VarInfo, namely via <code>InitContext</code>.</p><p>The main problem that we face is that it is not possible to directly implement <code>DynamicPPL.init(rng, vn, dist, strategy)</code> for <code>strategy::InitFromParams{&lt;:AbstractVector}</code>. In particular, it is not clear:</p><ul><li>which parts of the vector correspond to which random variables, and</li><li>whether the variables are linked or unlinked.</li></ul><p>Traditionally, this problem has been solved by <code>unflatten!!</code>, because that function would place values into the VarInfo&#39;s metadata alongside the information about ranges and linking. That way, when we evaluate with <code>DefaultContext</code>, we can read this information out again. However, we want to avoid using a metadata. Thus, here, we <em>extract this information from the VarInfo</em> a single time when constructing a <code>LogDensityFunction</code> object. Inside the LogDensityFunction, we store a mapping from VarNames to ranges in that vector, along with link status.</p><p>When evaluating the model, this allows us to combine the parameter vector together with those ranges to create an <code>InitFromVector</code>, which lets us very quickly read parameter values from the vector.</p><p>Note that this assumes that the ranges and link status are static throughout the lifetime of the <code>LogDensityFunction</code> object. Therefore, a <code>LogDensityFunction</code> object cannot handle models which have variable numbers of parameters, or models which may visit random variables in different orders depending on stochastic control flow. <strong>Indeed, silent errors may occur with such models.</strong> This is a general limitation of vectorised parameters: the original <code>unflatten!!</code> + <code>evaluate!!</code> approach also fails with such models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/logdensityfunction.jl#L29-L148">source</a></section></details></article><p>Internally, this is accomplished using <a href="#DynamicPPL.init!!"><code>init!!</code></a> on:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.OnlyAccsVarInfo"><a class="docstring-binding" href="#DynamicPPL.OnlyAccsVarInfo"><code>DynamicPPL.OnlyAccsVarInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OnlyAccsVarInfo(accs...)</code></pre><p><code>OnlyAccsVarInfo</code> is a wrapper around a tuple of accumulators.</p><p>Its name stems from the fact that it implements the minimal <code>AbstractVarInfo</code> interface to work with the <code>tilde_assume!!</code> and <code>tilde_observe!!</code> functions for <code>InitContext</code>.</p><p>Note that this does not implement almost every other AbstractVarInfo interface function, and so using this with a different leaf context such as <code>DefaultContext</code> will result in errors.</p><p>For more information about accumulators, please see the <a href="../accs/overview/#accumulators-overview">DynamicPPL documentation on accumulators</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/onlyaccs.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.to_vector_params"><a class="docstring-binding" href="#DynamicPPL.to_vector_params"><code>DynamicPPL.to_vector_params</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_vector_params(
    vector_values::VarNamedTuple,
    ldf::LogDensityFunction
)</code></pre><p>Extract vectorised values from a <code>VarNamedTuple</code> that contains <code>VectorValue</code>s and <code>LinkedVectorValue</code>s, and concatenate them into a single vector that is consistent with the ranges specified in the <code>LogDensityFunction</code>.</p><p>This is useful when you want to regenerate new vectorised parameters but using a different initialisation strategy.</p><p>Note that the transform status of the variables in the <code>VarNamedTuple</code> must be consistent with the transform strategy stored in the <code>LogDensityFunction</code>. This function checks for that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/logdensityfunction.jl#L535-L551">source</a></section></details></article><h2 id="Condition-and-decondition"><a class="docs-heading-anchor" href="#Condition-and-decondition">Condition and decondition</a><a id="Condition-and-decondition-1"></a><a class="docs-heading-anchor-permalink" href="#Condition-and-decondition" title="Permalink"></a></h2><p>A <a href="#Model"><code>Model</code></a> can be conditioned on a set of observations with <a href="#AbstractPPL.condition"><code>AbstractPPL.condition</code></a> or its alias <a href="#Base.:|-Tuple{Model, Union{Tuple, AbstractDict{&lt;:VarName}, NamedTuple}}"><code>|</code></a>.</p><article><details class="docstring" open="true"><summary id="Base.:|-Tuple{Model, Union{Tuple, AbstractDict{&lt;:VarName}, NamedTuple}}"><a class="docstring-binding" href="#Base.:|-Tuple{Model, Union{Tuple, AbstractDict{&lt;:VarName}, NamedTuple}}"><code>Base.:|</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">model | (x = 1.0, ...)</code></pre><p>Return a <code>Model</code> which now treats variables on the right-hand side as observations.</p><p>See <a href="#AbstractPPL.condition"><code>condition</code></a> for more information and examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L156-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.condition"><a class="docstring-binding" href="#AbstractPPL.condition"><code>AbstractPPL.condition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">condition(model::Model; values...)
condition(model::Model, values::NamedTuple)</code></pre><p>Return a <code>Model</code> which now treats the variables in <code>values</code> as observations.</p><p>See also: <a href="#AbstractPPL.decondition"><code>decondition</code></a>, <a href="#DynamicPPL.conditioned"><code>conditioned</code></a></p><p><strong>Limitations</strong></p><p>This does currently <em>not</em> work with variables that are provided to the model as arguments, e.g. <code>@model function demo(x) ... end</code> means that <code>condition</code> will not affect the variable <code>x</code>.</p><p>Therefore if one wants to make use of <code>condition</code> and <a href="#AbstractPPL.decondition"><code>decondition</code></a> one should not be specifying any random variables as arguments.</p><p>This is done for the sake of backwards compatibility.</p><p><strong>Examples</strong></p><p><strong>Simple univariate model</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; m, x = model(); (m != 1.0 &amp;&amp; x != 100.0)
true

julia&gt; # Create a new instance which treats `x` as observed
       # with value `100.0`, and similarly for `m=1.0`.
       conditioned_model = condition(model, x=100.0, m=1.0);

julia&gt; m, x = conditioned_model(); (m == 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # Let&#39;s only condition on `x = 100.0`.
       conditioned_model = condition(model, x = 100.0);

julia&gt; m, x = conditioned_model(); (m != 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # We can also use the nicer `|` syntax.
       conditioned_model = model | (x = 100.0, );

julia&gt; m, x = conditioned_model(); (m != 1.0 &amp;&amp; x == 100.0)
true</code></pre><p>In the above we have specified the conditioning variables via keyword arguments. You can also provide a <code>NamedTuple</code>, <code>AbstractDict{&lt;:VarName}</code>, or a <code>VarNamedTuple</code>; internally these are all converted to a <code>VarNamedTuple</code>.</p><p>For example, here we use a <code>Dict</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; conditioned_model_dict = condition(model, Dict(@varname(x) =&gt; 100.0));

julia&gt; m, x = conditioned_model_dict(); (m != 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # There&#39;s also an option using `|` by letting the right-hand side be a tuple
       # with elements of type `Pair{&lt;:VarName}`, i.e. `vn =&gt; value` with `vn isa VarName`.
       conditioned_model_pairs = model | (@varname(x) =&gt; 100.0);

julia&gt; m, x = conditioned_model_pairs(); (m != 1.0 &amp;&amp; x == 100.0)
true</code></pre><p><strong>Condition only a part of a multivariate variable</strong></p><p>When conditioning on multiple variables at a time, we can use <code>missing</code> to signal that a part of the variable should not be conditioned on.</p><p>However, note that in this case each element of the multivariate random variable must be on its own tilde-statement. In other words, if we write <code>m ~ MvNormal(...)</code>, then we cannot condition on only <code>m[1]</code>. (In principle, for some distributions this can be possible, specifically when the distribution can be factorised into independent components, like an MvNormal with a diagonal covariance matrix. However, this is not currently implemented.)</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_mv(::Type{TV}=Float64) where {TV}
           m = Vector{TV}(undef, 2)
           m[1] ~ Normal()
           m[2] ~ Normal()
           return m
       end
demo_mv (generic function with 4 methods)

julia&gt; model = demo_mv();

julia&gt; conditioned_model = condition(model, m = [missing, 1.0]);

julia&gt; # (✓) `m[1]` sampled while `m[2]` is fixed
       m = conditioned_model(); (m[1] != 1.0 &amp;&amp; m[2] == 1.0)
true</code></pre><p>Intuitively one might also expect to be able to write <code>model | (m[2] = 1.0, )</code>. You cannot do this with a <code>NamedTuple</code> because the <code>VarName</code> <code>m[2]</code> cannot be represented as a <code>Symbol</code> (i.e., <code>Symbol(&quot;m[2]&quot;)</code> is not the same as <code>@varname(m[2])</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; # (×) `m[2]` is not set to 1.0.
       m = condition(model, var&quot;m[2]&quot; = 1.0)(); m[2] == 1.0
false</code></pre><p>But you <em>can</em> do this if you use a <code>Dict</code> or a <code>VarNamedTuple</code> as the underlying storage instead:</p><pre><code class="language-julia-repl hljs">julia&gt; vnt = @vnt begin
           @template m = zeros(2)
           m[2] := 1.0
       end
VarNamedTuple
└─ m =&gt; PartialArray size=(2,) data::Vector{Float64}
        └─ (2,) =&gt; 1.0

julia&gt; m = condition(model, vnt)(); (m[1] != 1.0 &amp;&amp; m[2] == 1.0)
true</code></pre><p><strong>Nested models</strong></p><p><code>condition</code> also supports the use of nested models through the use of <a href="#DynamicPPL.to_submodel"><code>to_submodel</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; @model demo_inner() = m ~ Normal()
demo_inner (generic function with 2 methods)

julia&gt; @model function demo_outer()
           # By default, `to_submodel` prefixes the variables using the left-hand side of `~`.
           inner ~ to_submodel(demo_inner())
           return inner
       end
demo_outer (generic function with 2 methods)

julia&gt; model = demo_outer();

julia&gt; model() ≠ 1.0
true

julia&gt; # To condition the variable inside `demo_inner` we need to refer to it as `inner.m`.
       conditioned_model = model | (@varname(inner.m) =&gt; 1.0, );

julia&gt; conditioned_model()
1.0

julia&gt; # If you attempt to condition on `inner` itself, it must refer to the prefixed
       # latent variables, not the return value. For example, this will work:
       conditioned_model2 = model | (inner = (m = 1.0,), );

julia&gt; conditioned_model2()
1.0

julia&gt; # However, if `inner` does not contain `m` inside it as a field, this will not
       # result in any conditioning:
       conditioned_model_fail = model | (inner = &quot;something else&quot;, );

julia&gt; conditioned_model_fail == 1.0
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L166-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.conditioned"><a class="docstring-binding" href="#DynamicPPL.conditioned"><code>DynamicPPL.conditioned</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">conditioned(context::AbstractContext)</code></pre><p>Return <code>VarNamedTuple</code> of values that are conditioned on under <code>context</code>.</p><p>Note that this will recursively traverse the context stack and return a merged version of the condition values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts/conditionfix.jl#L306-L313">source</a></section><section><div><pre><code class="language-julia hljs">conditioned(model::Model)</code></pre><p>Return the conditioned values in <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; using DynamicPPL: conditioned, contextualize, PrefixContext, CondFixContext, Condition

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
       end
demo (generic function with 2 methods)

julia&gt; m = demo();

julia&gt; # Returns all the variables we have conditioned on + their values.
       conditioned(condition(m, x=100.0, m=1.0))
VarNamedTuple
├─ x =&gt; 100.0
└─ m =&gt; 1.0

julia&gt; # Nested ones also work. (Note that `PrefixContext` also prefixes
       # the variables of any `CondFixContext` that is _inside_ it.)
       new_context = PrefixContext(@varname(a), CondFixContext{Condition}(VarNamedTuple(m=1.0,)));
       cm = condition(contextualize(m, new_context), x=100.0);

julia&gt; conditioned(cm)
VarNamedTuple
├─ a =&gt; VarNamedTuple
│       └─ m =&gt; 1.0
└─ x =&gt; 100.0

julia&gt; # Since we conditioned on `a.m`, it is not treated as a random variable.
       # However, `a.x` will still be a random variable.
       keys(VarInfo(cm))
1-element Vector{VarName}:
 a.x

julia&gt; # We can also condition on `a.m` _outside_ of the PrefixContext:
       cm = condition(contextualize(m, PrefixContext(@varname(a))), (@varname(a.m) =&gt; 1.0));

julia&gt; conditioned(cm)
VarNamedTuple
└─ a =&gt; VarNamedTuple
        └─ m =&gt; 1.0

julia&gt; # Now `a.x` will be sampled.
       keys(VarInfo(cm))
1-element Vector{VarName}:
 a.x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L459-L514">source</a></section></details></article><p>Similarly, one can specify with <a href="#AbstractPPL.decondition"><code>AbstractPPL.decondition</code></a> that certain, or all, random variables are not observed.</p><article><details class="docstring" open="true"><summary id="AbstractPPL.decondition"><a class="docstring-binding" href="#AbstractPPL.decondition"><code>AbstractPPL.decondition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">decondition(model::Model)
decondition(model::Model, variables...)</code></pre><p>Return a <code>Model</code> for which <code>variables...</code> are <em>not</em> conditioned on. If no <code>variables</code> are provided, then all conditioned variables will be removed.</p><p>Note that this function cannot decondition variables that are provided as arguments to the model function itself; it can only decondition variables that were provided via <code>condition</code> or <code>|</code>.</p><p>This is essentially the inverse of <a href="#AbstractPPL.condition"><code>condition</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; conditioned_model = condition(demo(), m = 1.0, x = 10.0);

julia&gt; conditioned_model()
(m = 1.0, x = 10.0)

julia&gt; # By specifying the `VarName` to `decondition`.
       model = decondition(conditioned_model, @varname(m));

julia&gt; (m, x) = model(); (m ≠ 1.0 &amp;&amp; x == 10.0)
true

julia&gt; # `decondition` also accepts symbols, although VarNames are preferable for
       # type stability reasons.
       model = decondition(conditioned_model, :m);

julia&gt; (m, x) = model(); (m ≠ 1.0 &amp;&amp; x == 10.0)
true

julia&gt; # `decondition` multiple at once:
       (m, x) = decondition(model, :m, :x)(); (m ≠ 1.0 &amp;&amp; x ≠ 10.0)
true

julia&gt; # `decondition` without any symbols will `decondition` all variables.
       (m, x) = decondition(model)(); (m ≠ 1.0 &amp;&amp; x ≠ 10.0)
true</code></pre><p>Note that <code>decondition</code> is only guaranteed to work when you decondition variables that were explicitly provided to <code>condition</code> earlier. In this example we condition on <code>@varname(m)</code> but decondition on <code>@varname(m[1])</code>, which fails because <code>m[1]</code> was not explicitly conditioned on:</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_mv(::Type{TV}=Float64) where {TV}
           m = Vector{TV}(undef, 2)
           m[1] ~ Normal()
           m[2] ~ Normal()
           return m
       end
demo_mv (generic function with 4 methods)

julia&gt; model = demo_mv();

julia&gt; conditioned_model = condition(model, @varname(m) =&gt; [1.0, 2.0]);

julia&gt; conditioned_model()
2-element Vector{Float64}:
 1.0
 2.0

julia&gt; deconditioned_model = decondition(conditioned_model, @varname(m[1]));

julia&gt; deconditioned_model()  # (×) `m[1]` is still conditioned
2-element Vector{Float64}:
 1.0
 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L373-L454">source</a></section></details></article><h2 id="Fixing-and-unfixing"><a class="docs-heading-anchor" href="#Fixing-and-unfixing">Fixing and unfixing</a><a id="Fixing-and-unfixing-1"></a><a class="docs-heading-anchor-permalink" href="#Fixing-and-unfixing" title="Permalink"></a></h2><p>We can also <em>fix</em> a collection of variables in a <a href="#Model"><code>Model</code></a> to certain values using <a href="#DynamicPPL.fix"><code>DynamicPPL.fix</code></a>.</p><p>This is quite similar to the aforementioned <a href="#AbstractPPL.condition"><code>condition</code></a> and its siblings, but they are indeed different operations:</p><ul><li><code>condition</code>ed variables are considered to be <em>observations</em>, and are thus included in the computation <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>, but not in <a href="#DynamicPPL.logprior"><code>logprior</code></a>.</li><li><code>fix</code>ed variables are considered to be <em>constant</em>, and are thus not included in any log-probability computations.</li></ul><p>The differences are more clearly spelled out in the docstring of <a href="#DynamicPPL.fix"><code>DynamicPPL.fix</code></a> below.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.fix"><a class="docstring-binding" href="#DynamicPPL.fix"><code>DynamicPPL.fix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fix(model::Model; values...)
fix(model::Model, values::NamedTuple)</code></pre><p>Return a <code>Model</code> which now treats the variables in <code>values</code> as fixed.</p><p>See also: <a href="#DynamicPPL.unfix"><code>unfix</code></a>, <a href="#DynamicPPL.fixed"><code>fixed</code></a></p><p><strong>Examples</strong></p><p><strong>Simple univariate model</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; m, x = model(); (m ≠ 1.0 &amp;&amp; x ≠ 100.0)
true

julia&gt; # Create a new instance which treats `x` as observed
       # with value `100.0`, and similarly for `m=1.0`.
       fixed_model = fix(model, x=100.0, m=1.0);

julia&gt; m, x = fixed_model(); (m == 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # Let&#39;s only fix on `x = 100.0`.
       fixed_model = fix(model, x = 100.0);

julia&gt; m, x = fixed_model(); (m != 1.0 &amp;&amp; x == 100.0)
true</code></pre><p><strong>Other ways of specifying fixed values</strong></p><p>Specifying fixed values can be done exactly in the same way as for <a href="#AbstractPPL.condition"><code>condition</code></a>; please see its docstring for more examples.</p><p><strong>Difference from <code>condition</code></strong></p><p>The only difference between fixing and conditioning is as follows:</p><ul><li>Conditioned variables are considered to be observations, and are thus included in the computation log-joint and log-likelihood, but not the log-prior.</li><li>Fixed variables are considered to be constant, and are thus not included in any log-probability computations.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; model_fixed = fix(model, m = 1.0);

julia&gt; model_conditioned = condition(model, m = 1.0);

julia&gt; logjoint(model_fixed, (x=1.0,))
-0.9189385332046728

julia&gt; logjoint(model_conditioned, (x=1.0,))
-2.3378770664093453

julia&gt; # The difference is the missing log-probability of `m`:
       logpdf(Normal(), 1.0)
-1.4189385332046727</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L517-L594">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.fixed"><a class="docstring-binding" href="#DynamicPPL.fixed"><code>DynamicPPL.fixed</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fixed(context::AbstractContext)</code></pre><p>Return a <code>VarNamedTuple</code> containing the values that are fixed under <code>context</code>.</p><p>Note that this will recursively traverse the context stack and return a merged version of the fix values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts/conditionfix.jl#L362-L369">source</a></section><section><div><pre><code class="language-julia hljs">fixed(model::Model)</code></pre><p>Return the fixed values in <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; using DynamicPPL: fixed, contextualize, PrefixContext, CondFixContext, Fix

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
       end
demo (generic function with 2 methods)

julia&gt; m = demo();

julia&gt; # Returns all the variables we have fixed on + their values.
       fixed(fix(m, x=100.0, m=1.0))
VarNamedTuple
├─ x =&gt; 100.0
└─ m =&gt; 1.0

julia&gt; # The rest of this is the same as the `condition` example above.
       fm = fix(contextualize(m, PrefixContext(@varname(a), CondFixContext{Fix}(VarNamedTuple(m=1.0)))), x=100.0);

julia&gt; Set(keys(fixed(fm))) == Set([@varname(a.m), @varname(x)])
true

julia&gt; keys(VarInfo(fm))
1-element Vector{VarName}:
 a.x

julia&gt; # We can also fix `a.m` _outside_ of the PrefixContext:
       fm = fix(contextualize(m, PrefixContext(@varname(a))), (@varname(a.m) =&gt; 1.0));

julia&gt; fixed(fm)
VarNamedTuple
└─ a =&gt; VarNamedTuple
        └─ m =&gt; 1.0

julia&gt; # Now `a.x` will be sampled.
       keys(VarInfo(fm))
1-element Vector{VarName}:
 a.x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L660-L708">source</a></section></details></article><p>The difference between <a href="#DynamicPPL.fix"><code>DynamicPPL.fix</code></a> and <a href="#AbstractPPL.condition"><code>DynamicPPL.condition</code></a> is described in the docstring of <a href="#DynamicPPL.fix"><code>DynamicPPL.fix</code></a> above.</p><p>Similarly, we can revert this with <a href="#DynamicPPL.unfix"><code>DynamicPPL.unfix</code></a>, i.e. return the variables to their original meaning:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.unfix"><a class="docstring-binding" href="#DynamicPPL.unfix"><code>DynamicPPL.unfix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unfix(model::Model)
unfix(model::Model, variables...)</code></pre><p>Return a <code>Model</code> for which <code>variables...</code> are <em>not</em> considered fixed. If no <code>variables</code> are provided, then all fixed variables will be removed.</p><p>This is essentially the inverse of <a href="#DynamicPPL.fix"><code>fix</code></a>.</p><p>Conceptually this is very similar to <a href="#AbstractPPL.decondition"><code>decondition</code></a> and thus the same limitations apply; please see its docstring for more details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; fixed_model = fix(demo(), m = 1.0, x = 10.0);

julia&gt; fixed_model()
(m = 1.0, x = 10.0)

julia&gt; # By specifying the `VarName` to `unfix`.
       model = unfix(fixed_model, @varname(m));

julia&gt; (m, x) = model(); (m != 1.0 &amp;&amp; x == 10.0)
true

julia&gt; # When `NamedTuple` is used as the underlying, you can also provide
       # the symbol directly (though the `@varname` approach is preferable if
       # if the variable is known at compile-time).
       model = unfix(fixed_model, :m);

julia&gt; (m, x) = model(); (m != 1.0 &amp;&amp; x == 10.0)
true

julia&gt; # `unfix` multiple at once:
       (m, x) = unfix(model, :m, :x)(); (m != 1.0 &amp;&amp; x != 10.0)
true

julia&gt; # `unfix` without any symbols will `unfix` all variables.
       (m, x) = unfix(model)(); (m != 1.0 &amp;&amp; x != 10.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L606-L656">source</a></section></details></article><h2 id="Predicting"><a class="docs-heading-anchor" href="#Predicting">Predicting</a><a id="Predicting-1"></a><a class="docs-heading-anchor-permalink" href="#Predicting" title="Permalink"></a></h2><p>DynamicPPL provides functionality for generating samples from the posterior predictive distribution through the <code>predict</code> function. This allows you to use posterior parameter samples to generate predictions for unobserved data points.</p><p>The <code>predict</code> function has two main methods:</p><ol><li>For <code>AbstractVector{&lt;:AbstractVarInfo}</code> - useful when you have a collection of <code>VarInfo</code> objects representing posterior samples.</li><li>For <code>MCMCChains.Chains</code> (only available when <code>MCMCChains.jl</code> is loaded) - useful when you have posterior samples in the form of an <code>MCMCChains.Chains</code> object.</li></ol><article><details class="docstring" open="true"><summary id="StatsAPI.predict"><a class="docstring-binding" href="#StatsAPI.predict"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">predict([rng::AbstractRNG,] model::Model, chain::MCMCChains.Chains; include_all=false)</code></pre><p>Sample from the posterior predictive distribution by executing <code>model</code> with parameters fixed to each sample in <code>chain</code>, and return the resulting <code>Chains</code>.</p><p>The <code>model</code> passed to <code>predict</code> is often different from the one used to generate <code>chain</code>. Typically, the model from which <code>chain</code> originated treats certain variables as observed (i.e., data points), while the model you pass to <code>predict</code> may mark these same variables as missing or unobserved. Calling <code>predict</code> then leverages the previously inferred parameter values to simulate what new, unobserved data might look like, given your posterior beliefs.</p><p>For each parameter configuration in <code>chain</code>:</p><ol><li>All random variables present in <code>chain</code> are fixed to their sampled values.</li><li>Any variables not included in <code>chain</code> are sampled from their prior distributions.</li></ol><p>If <code>include_all</code> is <code>false</code>, the returned <code>Chains</code> will contain only those variables that were not fixed by the samples in <code>chain</code>. This is useful when you want to sample only new variables from the posterior predictive distribution.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using AbstractMCMC, Distributions, DynamicPPL, Random

@model function linear_reg(x, y, σ = 0.1)
    β ~ Normal(0, 1)
    for i in eachindex(y)
        y[i] ~ Normal(β * x[i], σ)
    end
end

# Generate synthetic chain using known ground truth parameter
ground_truth_β = 2.0

# Create chain of samples from a normal distribution centered on ground truth
β_chain = MCMCChains.Chains(
    rand(Normal(ground_truth_β, 0.002), 1000), [:β,]
)

# Generate predictions for two test points
xs_test = [10.1, 10.2]

m_train = linear_reg(xs_test, fill(missing, length(xs_test)))

predictions = DynamicPPL.AbstractPPL.predict(
    Random.default_rng(), m_train, β_chain
)

ys_pred = vec(mean(Array(predictions); dims=1))

# Check if predictions match expected values within tolerance
(
    isapprox(ys_pred[1], ground_truth_β * xs_test[1], atol = 0.01),
    isapprox(ys_pred[2], ground_truth_β * xs_test[2], atol = 0.01)
)

# output

(true, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMCMCChainsExt.jl#L231-L291">source</a></section></details></article><h3 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h3><p>The typical workflow for posterior prediction involves:</p><ol><li>Fitting a model to observed data to obtain posterior samples</li><li>Creating a new model instance with some variables marked as missing (unobserved)</li><li>Using <code>predict</code> to generate samples for these missing variables based on the posterior parameter samples</li></ol><p>When using <code>predict</code> with <code>MCMCChains.Chains</code>, you can control which variables are included in the output with the <code>include_all</code> parameter:</p><ul><li><code>include_all=false</code> (default): Include only newly predicted variables</li><li><code>include_all=true</code>: Include both parameters from the original chain and predicted variables</li></ul><h2 id="Marginalisation"><a class="docs-heading-anchor" href="#Marginalisation">Marginalisation</a><a id="Marginalisation-1"></a><a class="docs-heading-anchor-permalink" href="#Marginalisation" title="Permalink"></a></h2><p>DynamicPPL provides the <code>marginalize</code> function to marginalise out variables from a model. This requires <code>MarginalLogDensities.jl</code> to be loaded in your environment.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.marginalize"><a class="docstring-binding" href="#DynamicPPL.marginalize"><code>DynamicPPL.marginalize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">marginalize(
    model::DynamicPPL.Model,
    marginalized_varnames::AbstractVector{&lt;:VarName};
    varinfo::DynamicPPL.AbstractVarInfo=link(VarInfo(model), model),
    getlogprob=DynamicPPL.getlogjoint,
    method::MarginalLogDensities.AbstractMarginalizer=MarginalLogDensities.LaplaceApprox();
    kwargs...,
)</code></pre><p>Construct a <code>MarginalLogDensities.MarginalLogDensity</code> object that represents the marginal log-density of the given <code>model</code>, after marginalizing out the variables specified in <code>varnames</code>.</p><p>The resulting object can be called with a vector of parameter values to compute the marginal log-density.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>varinfo</code>: The <code>varinfo</code> to use for the model. By default we use a linked <code>VarInfo</code>,  meaning that the resulting log-density function accepts parameters that have been  transformed to unconstrained space.</p></li><li><p><code>getlogprob</code>: A function which specifies which kind of marginal log-density to compute.  Its default value is <code>DynamicPPL.getlogjoint</code> which returns the marginal log-joint  probability.</p></li><li><p><code>method</code>: The marginalization method; defaults to a Laplace approximation. Please see <a href="https://github.com/ElOceanografo/MarginalLogDensities.jl/">the  MarginalLogDensities.jl package</a>  for other options.</p></li><li><p>Other keyword arguments are passed to the <code>MarginalLogDensities.MarginalLogDensity</code> constructor.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions, MarginalLogDensities

julia&gt; @model function demo()
           x ~ Normal(1.0)
           y ~ Normal(2.0)
       end
demo (generic function with 2 methods)

julia&gt; marginalized = marginalize(demo(), [:x]);

julia&gt; # The resulting callable computes the marginal log-density of `y`.
       marginalized([1.0])
-1.4189385332046727

julia&gt; logpdf(Normal(2.0), 1.0)
-1.4189385332046727</code></pre><div class="admonition is-warning" id="Warning-eef18e401c14f89"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-eef18e401c14f89" title="Permalink"></a></header><div class="admonition-body"><p>The default usage of linked VarInfo means that, for example, optimization of the marginal log-density can be performed in unconstrained space. However, care must be taken if the model contains variables where the link transformation depends on a marginalized variable. For example:</p><pre><code class="language-julia hljs">@model function f()
    x ~ Normal()
    y ~ truncated(Normal(); lower=x)
end</code></pre><p>Here, the support of <code>y</code>, and hence the link transformation used, depends on the value of <code>x</code>. If we now marginalize over <code>x</code>, we obtain a function mapping linked values of <code>y</code> to log-probabilities. However, it will not be possible to use DynamicPPL to correctly retrieve <em>unlinked</em> values of <code>y</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMarginalLogDensitiesExt.jl#L21-L95">source</a></section></details></article><p>A <code>MarginalLogDensity</code> object acts as a function which maps non-marginalised parameter values to a marginal log-probability. To retrieve a VarInfo object from it, you can use:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.VarInfo-Tuple{MarginalLogDensities.MarginalLogDensity{&lt;:DynamicPPLMarginalLogDensitiesExt.LogDensityFunctionWrapper}, Union{Nothing, AbstractVector}}"><a class="docstring-binding" href="#DynamicPPL.VarInfo-Tuple{MarginalLogDensities.MarginalLogDensity{&lt;:DynamicPPLMarginalLogDensitiesExt.LogDensityFunctionWrapper}, Union{Nothing, AbstractVector}}"><code>DynamicPPL.VarInfo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VarInfo(
    mld::MarginalLogDensities.MarginalLogDensity{&lt;:LogDensityFunctionWrapper},
    unmarginalized_params::Union{AbstractVector,Nothing}=nothing
)</code></pre><p>Retrieve the <code>VarInfo</code> object used in the marginalisation process.</p><p>If a Laplace approximation was used for the marginalisation, the values of the marginalized parameters are also set to their mode (note that this only happens if the <code>mld</code> object has been used to compute the marginal log-density at least once, so that the mode has been computed).</p><p>If a vector of <code>unmarginalized_params</code> is specified, the values for the corresponding parameters will also be updated in the returned VarInfo. This vector may be obtained e.g. by performing an optimization of the marginal log-density.</p><p>All other aspects of the VarInfo, such as link status, are preserved from the original VarInfo used in the marginalisation.</p><div class="admonition is-info" id="Note-f63cfc141e10ee8c"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f63cfc141e10ee8c" title="Permalink"></a></header><div class="admonition-body"><p>The other fields of the VarInfo, e.g. accumulated log-probabilities, will not be updated. If you wish to obtain updated log-probabilities, you should re-evaluate the model with the values inside the returned VarInfo, for example using:</p><pre><code class="language-julia hljs">init_strategy = DynamicPPL.InitFromParams(varinfo.values, nothing)
oavi = DynamicPPL.OnlyAccsVarInfo((
    DynamicPPL.LogPriorAccumulator(),
    DynamicPPL.LogLikelihoodAccumulator(),
    DynamicPPL.RawValueAccumulator(false),
    # ... whatever else you need
))
_, oavi = DynamicPPL.init!!(rng, model, oavi, init_strategy, DynamicPPL.UnlinkAll())</code></pre><p>You can then extract all the updated data from <code>oavi</code>.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions, MarginalLogDensities

julia&gt; @model function demo()
           x ~ Normal()
           y ~ Beta(2, 2)
       end
demo (generic function with 2 methods)

julia&gt; # Note that by default `marginalize` uses a linked VarInfo.
       mld = marginalize(demo(), [@varname(x)]);

julia&gt; using MarginalLogDensities: Optimization, OptimizationOptimJL

julia&gt; # Find the mode of the marginal log-density of `y`, with an initial point of `y0`.
       y0 = 2.0; opt_problem = Optimization.OptimizationProblem(mld, [y0])
OptimizationProblem. In-place: true
u0: 1-element Vector{Float64}:
 2.0

julia&gt; # This tells us the optimal (linked) value of `y` is around 0.
       opt_solution = Optimization.solve(opt_problem, OptimizationOptimJL.NelderMead())
retcode: Success
u: 1-element Vector{Float64}:
 4.88281250001733e-5

julia&gt; # Get the VarInfo corresponding to the mode of `y`.
       vi = VarInfo(mld, opt_solution.u);

julia&gt; # `x` is set to its mode (which for `Normal()` is zero).
       vi[@varname(x)]
0.0

julia&gt; # `y` is set to the optimal value we found above.
       DynamicPPL.getindex_internal(vi, @varname(y))
1-element Vector{Float64}:
 4.88281250001733e-5

julia&gt; # To obtain values in the original constrained space, we can either
       # use `getindex`:
       vi[@varname(y)]
0.5000122070312476

julia&gt; # Or invlink the entire VarInfo object using the model:
       vi_unlinked = DynamicPPL.invlink(vi, demo()); vi_unlinked[:]
2-element Vector{Float64}:
 0.0
 0.5000122070312476</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMarginalLogDensitiesExt.jl#L123-L213">source</a></section></details></article><h2 id="Models-within-models"><a class="docs-heading-anchor" href="#Models-within-models">Models within models</a><a id="Models-within-models-1"></a><a class="docs-heading-anchor-permalink" href="#Models-within-models" title="Permalink"></a></h2><p>One can include models and call another model inside the model function with <code>left ~ to_submodel(model)</code>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.to_submodel"><a class="docstring-binding" href="#DynamicPPL.to_submodel"><code>DynamicPPL.to_submodel</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_submodel(model::Model[, auto_prefix::Bool])</code></pre><p>Return a model wrapper indicating that it is a sampleable model over the return-values.</p><p>This is mainly meant to be used on the right-hand side of a <code>~</code> operator to indicate that the model can be sampled from but not necessarily evaluated for its log density.</p><div class="admonition is-warning" id="Warning-7e0fea23480ead7d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-7e0fea23480ead7d" title="Permalink"></a></header><div class="admonition-body"><p>Note that some other operations that one typically associate with expressions of the form <code>left ~ right</code> such as <a href="#AbstractPPL.condition"><code>condition</code></a>, will also not work with <code>to_submodel</code>.</p></div></div><div class="admonition is-warning" id="Warning-63d63dd0f95dac06"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-63d63dd0f95dac06" title="Permalink"></a></header><div class="admonition-body"><p>To avoid variable names clashing between models, it is recommended to leave the argument <code>auto_prefix</code> equal to <code>true</code>. If one does not use automatic prefixing, then it&#39;s recommended to use <a href="#DynamicPPL.prefix"><code>prefix(::Model, input)</code></a> explicitly, i.e. <code>to_submodel(prefix(model, @varname(my_prefix)))</code></p></div></div><p><strong>Arguments</strong></p><ul><li><code>model::Model</code>: the model to wrap.</li><li><code>auto_prefix::Bool</code>: whether to automatically prefix the variables in the model using the left-hand   side of the <code>~</code> statement. Default: <code>true</code>.</li></ul><p><strong>Examples</strong></p><p><strong>Simple example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo1(x)
           x ~ Normal()
           return 1 + abs(x)
       end;

julia&gt; @model function demo2(x, y)
            a ~ to_submodel(demo1(x))
            return y ~ Uniform(0, a)
       end;</code></pre><p>When we sample from the model <code>demo2(missing, 0.4)</code> random variable <code>x</code> will be sampled:</p><pre><code class="language-julia-repl hljs">julia&gt; vi = VarInfo(demo2(missing, 0.4));

julia&gt; @varname(a.x) in keys(vi)
true</code></pre><p>The variable <code>a</code> is not tracked. However, it will be assigned the return value of <code>demo1</code>, and can be used in subsequent lines of the model, as shown above.</p><pre><code class="language-julia-repl hljs">julia&gt; @varname(a) in keys(vi)
false</code></pre><p>We can check that the log joint probability of the model accumulated in <code>vi</code> is correct:</p><pre><code class="language-julia-repl hljs">julia&gt; x = vi[@varname(a.x)];

julia&gt; getlogjoint(vi) ≈ logpdf(Normal(), x) + logpdf(Uniform(0, 1 + abs(x)), 0.4)
true</code></pre><p><strong>Without automatic prefixing</strong></p><p>As mentioned earlier, by default, the <code>auto_prefix</code> argument specifies whether to automatically prefix the variables in the submodel. If <code>auto_prefix=false</code>, then the variables in the submodel will not be prefixed.</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo1(x)
           x ~ Normal()
           return 1 + abs(x)
       end;

julia&gt; @model function demo2_no_prefix(x, z)
            a ~ to_submodel(demo1(x), false)
            return z ~ Uniform(-a, 1)
       end;

julia&gt; vi = VarInfo(demo2_no_prefix(missing, 0.4));

julia&gt; @varname(x) in keys(vi)  # here we just use `x` instead of `a.x`
true</code></pre><p>However, not using prefixing is generally not recommended as it can lead to variable name clashes unless one is careful. For example, if we&#39;re re-using the same model twice in a model, not using prefixing will lead to variable name clashes: However, one can manually prefix using the <a href="#DynamicPPL.prefix"><code>prefix(::Model, input)</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo2(x, y, z)
            a ~ to_submodel(prefix(demo1(x), :sub1), false)
            b ~ to_submodel(prefix(demo1(y), :sub2), false)
            return z ~ Uniform(-a, b)
       end;

julia&gt; vi = VarInfo(demo2(missing, missing, 0.4));

julia&gt; @varname(sub1.x) in keys(vi)
true

julia&gt; @varname(sub2.x) in keys(vi)
true</code></pre><p>Variables <code>a</code> and <code>b</code> are not tracked, but are assigned the return values of the respective calls to <code>demo1</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @varname(a) in keys(vi)
false

julia&gt; @varname(b) in keys(vi)
false</code></pre><p>We can check that the log joint probability of the model accumulated in <code>vi</code> is correct:</p><pre><code class="language-julia-repl hljs">julia&gt; sub1_x = vi[@varname(sub1.x)];

julia&gt; sub2_x = vi[@varname(sub2.x)];

julia&gt; logprior = logpdf(Normal(), sub1_x) + logpdf(Normal(), sub2_x);

julia&gt; loglikelihood = logpdf(Uniform(-1 - abs(sub1_x), 1 + abs(sub2_x)), 0.4);

julia&gt; getlogjoint(vi) ≈ logprior + loglikelihood
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/submodel.jl#L15-L138">source</a></section></details></article><p>Note that a <code>[to_submodel](@ref)</code> is only sampleable; one cannot compute <code>logpdf</code> for its realizations.</p><p>In the context of including models within models, it&#39;s also useful to prefix the variables in sub-models to avoid variable names clashing:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.prefix"><a class="docstring-binding" href="#DynamicPPL.prefix"><code>DynamicPPL.prefix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prefix(ctx::AbstractContext, vn::VarName)</code></pre><p>Apply the prefixes in the context <code>ctx</code> to the variable name <code>vn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts/prefix.jl#L31-L35">source</a></section><section><div><pre><code class="language-julia hljs">prefix(model::Model, x::VarName)
prefix(model::Model, x::Val{sym})
prefix(model::Model, x::Any)</code></pre><p>Return <code>model</code> but with all random variables prefixed by <code>x</code>, where <code>x</code> is either:</p><ul><li>a <code>VarName</code> (e.g. <code>@varname(a)</code>),</li><li>a <code>Val{sym}</code> (e.g. <code>Val(:a)</code>), or</li><li>for any other type, <code>x</code> is converted to a Symbol and then to a <code>VarName</code>. Note that this will introduce runtime overheads so is not recommended unless absolutely necessary.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL: prefix

julia&gt; @model demo() = x ~ Dirac(1)
demo (generic function with 2 methods)

julia&gt; rand(prefix(demo(), @varname(my_prefix)))
VarNamedTuple
└─ my_prefix =&gt; VarNamedTuple
                └─ x =&gt; 1

julia&gt; rand(prefix(demo(), Val(:my_prefix)))
VarNamedTuple
└─ my_prefix =&gt; VarNamedTuple
                └─ x =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L711-L741">source</a></section></details></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><p><code>typed_identity</code> is the same as <code>identity</code>, but with an overload for <code>with_logabsdet_jacobian</code> that ensures that it never errors.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.typed_identity"><a class="docstring-binding" href="#DynamicPPL.typed_identity"><code>DynamicPPL.typed_identity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">typed_identity(x)</code></pre><p>Identity function, but with an overload for <code>with_logabsdet_jacobian</code> to ensure that it returns a sensible zero logjac.</p><p>The problem with plain old <code>identity</code> is that the default definition of <code>with_logabsdet_jacobian</code> for <code>identity</code> returns <code>zero(eltype(x))</code>: https://github.com/JuliaMath/ChangesOfVariables.jl/blob/d6a8115fc9b9419decbdb48e2c56ec9675b4c6a4/src/with_ladj.jl#L154</p><p>This is fine for most samples <code>x</code>, but if <code>eltype(x)</code> doesn&#39;t return a sensible type (e.g. if it&#39;s <code>Any</code>), then using <code>identity</code> will error with <code>zero(Any)</code>. This can happen with, for example, <code>ProductNamedTupleDistribution</code>:</p><pre><code class="language-julia hljs">julia&gt; using Distributions; d = product_distribution((a = Normal(), b = LKJCholesky(3, 0.5)));

julia&gt; eltype(rand(d))
Any</code></pre><p>The same problem precludes us from eventually broadening the scope of DynamicPPL.jl to support distributions with non-numeric samples.</p><p>Furthermore, in principle, the type of the log-probability should be separate from the type of the sample. Thus, instead of using <code>zero(LogProbType)</code>, we should use the eltype of the LogJacobianAccumulator. There&#39;s no easy way to thread that through here, but if a way to do this is discovered, then <code>typed_identity</code> is what will allow us to obtain that custom behaviour.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/utils.jl#L12-L41">source</a></section></details></article><p>It is possible to manually increase (or decrease) the accumulated log likelihood or prior from within a model function.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.@addlogprob!"><a class="docstring-binding" href="#DynamicPPL.@addlogprob!"><code>DynamicPPL.@addlogprob!</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@addlogprob!(ex)</code></pre><p>Add a term to the log joint.</p><p>If <code>ex</code> evaluates to a <code>NamedTuple</code> with keys <code>:loglikelihood</code> and/or <code>:logprior</code>, the values are added to the log likelihood and log prior respectively.</p><p>If <code>ex</code> evaluates to a number it is added to the log likelihood.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mylogjoint(x, μ) = (; loglikelihood=loglikelihood(Normal(μ, 1), x), logprior=1.0);

julia&gt; @model function demo(x)
           μ ~ Normal()
           @addlogprob! mylogjoint(x, μ)
       end;

julia&gt; x = [1.3, -2.1];

julia&gt; loglikelihood(demo(x), (μ=0.2,)) ≈ mylogjoint(x, 0.2).loglikelihood
true

julia&gt; logprior(demo(x), (μ=0.2,)) ≈ logpdf(Normal(), 0.2) + mylogjoint(x, 0.2).logprior
true</code></pre><p>and to <a href="https://github.com/TuringLang/Turing.jl/issues/1328">reject samples</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ MvNormal(zero(x), I)
           if dot(m, x) &lt; 0
               @addlogprob! (; loglikelihood=-Inf)
               # Exit the model evaluation early
               return
           end
           x ~ MvNormal(m, I)
           return
       end;

julia&gt; logjoint(demo([-2.1]), (m=[0.2],)) == -Inf
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/utils.jl#L48-L94">source</a></section></details></article><p>Return values of the model function can be obtained with <a href="#DynamicPPL.returned-Tuple{Model, Chains}"><code>returned(model, sample)</code></a>, where <code>sample</code> is either a <code>MCMCChains.Chains</code> object (which represents a collection of samples), or a single sample represented as a <code>NamedTuple</code> or a dictionary of VarNames.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.returned-Tuple{Model, Chains}"><a class="docstring-binding" href="#DynamicPPL.returned-Tuple{Model, Chains}"><code>DynamicPPL.returned</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">returned(model::Model, chain::MCMCChains.Chains)</code></pre><p>Execute <code>model</code> for each of the samples in <code>chain</code> and return an array of the values returned by the <code>model</code> for each sample.</p><p><strong>Examples</strong></p><p><strong>General</strong></p><p>Often you might have additional quantities computed inside the model that you want to inspect, e.g.</p><pre><code class="language-julia hljs">@model function demo(x)
    # sample and observe
    θ ~ Prior()
    x ~ Likelihood()
    return interesting_quantity(θ, x)
end
m = demo(data)
chain = sample(m, alg, n)
# To inspect the `interesting_quantity(θ, x)` where `θ` is replaced by samples
# from the posterior/`chain`:
returned(m, chain) # &lt;= results in a `Vector` of returned values
                               #    from `interesting_quantity(θ, x)`</code></pre><p><strong>Concrete (and simple)</strong></p><pre><code class="language-julia hljs">julia&gt; using Turing

julia&gt; @model function demo(xs)
           s ~ InverseGamma(2, 3)
           m_shifted ~ Normal(10, √s)
           m = m_shifted - 10

           for i in eachindex(xs)
               xs[i] ~ Normal(m, √s)
           end

           return (m, )
       end
demo (generic function with 1 method)

julia&gt; model = demo(randn(10));

julia&gt; chain = sample(model, MH(), 10);

julia&gt; returned(model, chain)
10×1 Array{Tuple{Float64},2}:
 (2.1964758025119338,)
 (2.1964758025119338,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.043088571494005024,)
 (-0.16489786710222099,)
 (-0.16489786710222099,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMCMCChainsExt.jl#L329-L387">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.returned-Tuple{Model, Union{AbstractDict{&lt;:VarName}, NamedTuple}}"><a class="docstring-binding" href="#DynamicPPL.returned-Tuple{Model, Union{AbstractDict{&lt;:VarName}, NamedTuple}}"><code>DynamicPPL.returned</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">returned(model::Model, parameters...)</code></pre><p>Initialise a <code>model</code> using the given <code>parameters</code> and return the model&#39;s return value. The parameters must be provided in a format that can be wrapped in an <code>InitFromParams</code>, i.e., <code>InitFromParams(parameters..., nothing)</code> must be a valid <code>AbstractInitStrategy</code> (where <code>nothing</code> is the fallback strategy to use if parameters are not provided).</p><p>As far as DynamicPPL is concerned, <code>parameters</code> can be either a singular <code>NamedTuple</code> or an <code>AbstractDict{&lt;:VarName}</code>; however this method is left flexible to allow for other packages that wish to extend <code>InitFromParams</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions

julia&gt; @model function demo()
           m ~ Normal()
           return (mp1 = m + 1,)
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; returned(model, (; m = 1.0))
(mp1 = 2.0,)

julia&gt; returned(model, Dict{VarName,Float64}(@varname(m) =&gt; 2.0))
(mp1 = 3.0,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L1131-L1161">source</a></section></details></article><p>For a chain of samples, one can compute the pointwise log-likelihoods of each observed random variable with <a href="#DynamicPPL.pointwise_loglikelihoods"><code>pointwise_loglikelihoods</code></a>. Similarly, the log-densities of the priors using <a href="#DynamicPPL.pointwise_prior_logdensities"><code>pointwise_prior_logdensities</code></a> or both, i.e. all variables, using <a href="#DynamicPPL.pointwise_logdensities"><code>pointwise_logdensities</code></a>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.pointwise_logdensities"><a class="docstring-binding" href="#DynamicPPL.pointwise_logdensities"><code>DynamicPPL.pointwise_logdensities</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.pointwise_logdensities(
    model::DynamicPPL.Model,
    chain::MCMCChains.Chains,
)</code></pre><p>Runs <code>model</code> on each sample in <code>chain</code>, returning a new <code>MCMCChains.Chains</code> object where the log-density of each variable at each sample is stored (rather than its value).</p><p>See also: <a href="#DynamicPPL.pointwise_loglikelihoods"><code>DynamicPPL.pointwise_loglikelihoods</code></a>, <a href="#DynamicPPL.pointwise_prior_logdensities"><code>DynamicPPL.pointwise_prior_logdensities</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MCMCChains

julia&gt; @model function demo(xs, y)
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, √s)
           for i in eachindex(xs)
               xs[i] ~ Normal(m, √s)
           end
           y ~ Normal(m, √s)
       end
demo (generic function with 2 methods)

julia&gt; # Example observations.
       model = demo([1.0, 2.0, 3.0], [4.0]);

julia&gt; # A chain with 3 iterations.
       chain = Chains(
           reshape(1.:6., 3, 2),
           [:s, :m];
           info=(varname_to_symbol=Dict(
               @varname(s) =&gt; :s,
               @varname(m) =&gt; :m,
           ),),
       );

julia&gt; plds = pointwise_logdensities(model, chain)
Chains MCMC chain (3×6×1 Array{Float64, 3}):

Iterations        = 1:1:3
Number of chains  = 1
Samples per chain = 3
parameters        = s, m, xs[1], xs[2], xs[3], y
[...]

julia&gt; plds[:s]
2-dimensional AxisArray{Float64,2,...} with axes:
    :iter, 1:1:3
    :chain, 1:1
And data, a 3×1 Matrix{Float64}:
 -0.8027754226637804
 -1.3822169643436162
 -2.0986122886681096

julia&gt; # The above is the same as:
       logpdf.(InverseGamma(2, 3), chain[:s])
3×1 Matrix{Float64}:
 -0.8027754226637804
 -1.3822169643436162
 -2.0986122886681096</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMCMCChainsExt.jl#L418-L483">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.pointwise_loglikelihoods"><a class="docstring-binding" href="#DynamicPPL.pointwise_loglikelihoods"><code>DynamicPPL.pointwise_loglikelihoods</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.pointwise_loglikelihoods(
    model::DynamicPPL.Model,
    chain::MCMCChains.Chains,
)</code></pre><p>Compute the pointwise log-likelihoods of the model given the chain. This is the same as <code>pointwise_logdensities(model, chain)</code>, but only including the likelihood terms.</p><p>See also: <a href="#DynamicPPL.pointwise_logdensities"><code>DynamicPPL.pointwise_logdensities</code></a>, <a href="#DynamicPPL.pointwise_prior_logdensities"><code>DynamicPPL.pointwise_prior_logdensities</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMCMCChainsExt.jl#L490-L500">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.pointwise_prior_logdensities"><a class="docstring-binding" href="#DynamicPPL.pointwise_prior_logdensities"><code>DynamicPPL.pointwise_prior_logdensities</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.pointwise_prior_logdensities(
    model::DynamicPPL.Model,
    chain::MCMCChains.Chains
)</code></pre><p>Compute the pointwise log-prior-densities of the model given the chain. This is the same as <code>pointwise_logdensities(model, chain)</code>, but only including the prior terms.</p><p>See also: <a href="#DynamicPPL.pointwise_logdensities"><code>DynamicPPL.pointwise_logdensities</code></a>, <a href="#DynamicPPL.pointwise_loglikelihoods"><code>DynamicPPL.pointwise_loglikelihoods</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMCMCChainsExt.jl#L507-L517">source</a></section></details></article><p>Sometimes it can be useful to extract the priors of a model. This is the possible using <a href="#DynamicPPL.extract_priors"><code>extract_priors</code></a>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.extract_priors"><a class="docstring-binding" href="#DynamicPPL.extract_priors"><code>DynamicPPL.extract_priors</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extract_priors([rng::Random.AbstractRNG, ]model::Model)</code></pre><p>Extract the priors from a model. This is done by sampling from the model and recording the distributions that are used to generate the samples.</p><div class="admonition is-warning" id="Warning-eaa47731328ccb52"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-eaa47731328ccb52" title="Permalink"></a></header><div class="admonition-body"><p>Because the extraction is done by execution of the model, there are several caveats:</p><ol><li><p>If the distribution itself is not a constant (e.g. if it depends on another random variable, then the extracted prior will have different parameters in every extraction!</p></li><li><p>If the model does <em>not</em> have static support, say, <code>n ~ Categorical(1:10); x ~ MvNormal(zeros(n), I)</code>, then the extracted priors themselves will be different between extractions, not just their parameters.</p></li></ol><p>Both of these caveats are demonstrated below.</p></div></div><p><strong>Examples</strong></p><p><strong>Changing parameters</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions, StableRNGs

julia&gt; rng = StableRNG(42);

julia&gt; @model function model_dynamic_parameters()
           x ~ Normal(0, 1)
           y ~ Normal(x, 1)
       end;

julia&gt; model = model_dynamic_parameters();

julia&gt; extract_priors(rng, model)[@varname(y)]
Normal{Float64}(μ=-0.6702516921145671, σ=1.0)

julia&gt; extract_priors(rng, model)[@varname(y)]
Normal{Float64}(μ=1.3736306979834252, σ=1.0)</code></pre><p><strong>Changing support</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra, Distributions, StableRNGs

julia&gt; rng = StableRNG(42);

julia&gt; @model function model_dynamic_support()
           n ~ Categorical(ones(10) ./ 10)
           x ~ MvNormal(zeros(n), I)
       end;

julia&gt; model = model_dynamic_support();

julia&gt; length(extract_priors(rng, model)[@varname(x)])
6

julia&gt; length(extract_priors(rng, model)[@varname(x)])
9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators/priors.jl#L11-L73">source</a></section><section><div><pre><code class="language-julia hljs">extract_priors(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Extract the priors that were used to generate a VarInfo.</p><p>This is done by evaluating the model at the values present in <code>varinfo</code> and recording the distributions that are present at each tilde statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators/priors.jl#L81-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.NamedDist"><a class="docstring-binding" href="#DynamicPPL.NamedDist"><code>DynamicPPL.NamedDist</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A named distribution that carries the name of the random variable with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/distribution_wrappers.jl#L5-L7">source</a></section></details></article><h2 id="AD-testing-and-benchmarking-utilities"><a class="docs-heading-anchor" href="#AD-testing-and-benchmarking-utilities">AD testing and benchmarking utilities</a><a id="AD-testing-and-benchmarking-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#AD-testing-and-benchmarking-utilities" title="Permalink"></a></h2><p>To test and/or benchmark the performance of an AD backend on a model, DynamicPPL provides the following utilities:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.run_ad"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.run_ad"><code>DynamicPPL.TestUtils.AD.run_ad</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">run_ad(
    model::Model,
    adtype::ADTypes.AbstractADType;
    test::Union{AbstractADCorrectnessTestSetting,Bool}=WithBackend(),
    benchmark=false,
    atol::AbstractFloat=1e-8,
    rtol::AbstractFloat=sqrt(eps()),
    getlogdensity::Function=getlogjoint_internal,
    rng::Random.AbstractRNG=Random.default_rng(),
    varinfo::AbstractVarInfo=link(VarInfo(model), model),
    params::Union{Nothing,Vector{&lt;:AbstractFloat}}=nothing,
    verbose=true,
)::ADResult</code></pre><p><strong>Description</strong></p><p>Test the correctness and/or benchmark the AD backend <code>adtype</code> for the model <code>model</code>.</p><p>Whether to test and benchmark is controlled by the <code>test</code> and <code>benchmark</code> keyword arguments. By default, <code>test</code> is <code>true</code> and <code>benchmark</code> is <code>false</code>.</p><p>Note that to run AD successfully you will need to import the AD backend itself. For example, to test with <code>AutoReverseDiff()</code> you will need to run <code>import ReverseDiff</code>.</p><p><strong>Arguments</strong></p><p>There are two positional arguments, which absolutely must be provided:</p><ol><li><code>model</code> - The model being tested.</li><li><code>adtype</code> - The AD backend being tested.</li></ol><p>Everything else is optional, and can be categorised into several groups:</p><ol><li><p><em>How to specify the VarInfo.</em></p><p>DynamicPPL contains several different types of VarInfo objects which change the way model evaluation occurs. If you want to use a specific type of VarInfo, pass it as the <code>varinfo</code> argument. Otherwise, it will default to using a linked <code>TypedVarInfo</code> generated from the model. Here, <em>linked</em> means that the parameters in the VarInfo have been transformed to unconstrained Euclidean space if they aren&#39;t already in that space.</p></li><li><p><em>How to specify the parameters.</em></p><p>For maximum control over this, generate a vector of parameters yourself and pass this as the <code>params</code> argument. If you don&#39;t specify this, it will be taken from the contents of the VarInfo.</p><p>Note that if the VarInfo is not specified (and thus automatically generated) the parameters in it will have been sampled from the prior of the model. If you want to seed the parameter generation for the VarInfo, you can pass the <code>rng</code> keyword argument, which will then be used to create the VarInfo.</p><p>Finally, note that these only reflect the parameters used for <em>evaluating</em> the gradient. If you also want to control the parameters used for <em>preparing</em> the gradient, then you need to manually set these parameters in the VarInfo object, for example using <code>vi = DynamicPPL.unflatten!!(vi, prep_params)</code>. You could then evaluate the gradient at a different set of parameters using the <code>params</code> keyword argument.</p></li><li><p><em>Which type of logp is being calculated.</em></p><p>By default, <code>run_ad</code> evaluates the &#39;internal log joint density&#39; of the model, i.e., the log joint density in the unconstrained space. Thus, for example, in</p><pre><code class="nohighlight hljs">@model f() = x ~ LogNormal()</code></pre><p>the internal log joint density is <code>logpdf(Normal(), log(x))</code>. This is the relevant log density for e.g. Hamiltonian Monte Carlo samplers and is therefore the most useful to test.</p><p>If you want the log joint density in the original model parameterisation, you can use <code>getlogjoint</code>. Likewise, if you want only the prior or likelihood, you can use <code>getlogprior</code> or <code>getloglikelihood</code>, respectively.</p></li><li><p><em>How to specify the results to compare against.</em></p><p>Once logp and its gradient has been calculated with the specified <code>adtype</code>, it can optionally be tested for correctness. The exact way this is tested is specified in the <code>test</code> parameter.</p><p>There are several options for this:</p><ul><li>You can explicitly specify the correct value using <a href="#DynamicPPL.TestUtils.AD.WithExpectedResult"><code>WithExpectedResult()</code></a>.</li><li>You can compare against the result obtained with a different AD backend using <a href="#DynamicPPL.TestUtils.AD.WithBackend"><code>WithBackend(adtype)</code></a>.</li><li>You can disable testing by passing <a href="#DynamicPPL.TestUtils.AD.NoTest"><code>NoTest()</code></a>.</li><li>The default is to compare against the result obtained with ForwardDiff, i.e. <code>WithBackend(AutoForwardDiff())</code>.</li><li><code>test=false</code> and <code>test=true</code> are synonyms for <code>NoTest()</code> and <code>WithBackend(AutoForwardDiff())</code>, respectively.</li></ul></li><li><p><em>How to specify the tolerances.</em> (Only if testing is enabled.)</p><p>Both absolute and relative tolerances can be specified using the <code>atol</code> and <code>rtol</code> keyword arguments respectively. The behaviour of these is similar to <code>isapprox()</code>, i.e. the value and gradient are considered correct if either atol or rtol is satisfied. The default values are <code>100*eps()</code> for <code>atol</code> and <code>sqrt(eps())</code> for <code>rtol</code>.</p><p>For the most part, it is the <code>rtol</code> check that is more meaningful, because we cannot know the magnitude of logp and its gradient a priori. The <code>atol</code> value is supplied to handle the case where gradients are equal to zero.</p></li><li><p><em>Whether to benchmark.</em></p><p>By default, benchmarking is disabled. To enable it, set <code>benchmark=true</code>. When enabled, the time taken to evaluate logp as well as its gradient is measured using Chairmarks.jl, and the <code>ADResult</code> object returned will contain <code>grad_time</code> and <code>primal_time</code> fields with the median times (in seconds).</p></li><li><p><em>Whether to output extra logging information.</em></p><p>By default, this function prints messages when it runs. To silence it, set <code>verbose=false</code>.</p></li></ol><p><strong>Returns / Throws</strong></p><p>Returns an <a href="#DynamicPPL.TestUtils.AD.ADResult"><code>ADResult</code></a> object, which contains the results of the test and/or benchmark.</p><p>If <code>test</code> is <code>true</code> and the AD backend returns an incorrect value or gradient, an <code>ADIncorrectException</code> is thrown. If a different error occurs, it will be thrown as-is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/ad.jl#L186-L315">source</a></section></details></article><p>The default test setting is to compare against ForwardDiff. You can have more fine-grained control over how to test the AD backend using the following types:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.AbstractADCorrectnessTestSetting"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.AbstractADCorrectnessTestSetting"><code>DynamicPPL.TestUtils.AD.AbstractADCorrectnessTestSetting</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractADCorrectnessTestSetting</code></pre><p>Different ways of testing the correctness of an AD backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/ad.jl#L23-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.WithBackend"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.WithBackend"><code>DynamicPPL.TestUtils.AD.WithBackend</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WithBackend(adtype::AbstractADType=AutoForwardDiff()) &lt;: AbstractADCorrectnessTestSetting</code></pre><p>Test correctness by comparing it against the result obtained with <code>adtype</code>.</p><p><code>adtype</code> defaults to ForwardDiff.jl, since it&#39;s the default AD backend used in Turing.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/ad.jl#L30-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.WithExpectedResult"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.WithExpectedResult"><code>DynamicPPL.TestUtils.AD.WithExpectedResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WithExpectedResult(
    value::T,
    grad::AbstractVector{T}
) where {T &lt;: AbstractFloat}
&lt;: AbstractADCorrectnessTestSetting</code></pre><p>Test correctness by comparing it against a known result (e.g. one obtained analytically, or one obtained with a different backend previously). Both the value of the primal (i.e. the log-density) as well as its gradient must be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/ad.jl#L43-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.NoTest"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.NoTest"><code>DynamicPPL.TestUtils.AD.NoTest</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoTest() &lt;: AbstractADCorrectnessTestSetting</code></pre><p>Disable correctness testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/ad.jl#L60-L64">source</a></section></details></article><p>These are returned / thrown by the <code>run_ad</code> function:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.ADResult"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.ADResult"><code>DynamicPPL.TestUtils.AD.ADResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ADResult{Tparams&lt;:AbstractFloat,Tresult&lt;:AbstractFloat,Ttol&lt;:AbstractFloat}</code></pre><p>Data structure to store the results of the AD correctness test.</p><p>The type parameter <code>Tparams</code> is the numeric type of the parameters passed in; <code>Tresult</code> is the type of the value and the gradient; and <code>Ttol</code> is the type of the absolute and relative tolerances used for correctness testing.</p><p><strong>Fields</strong></p><ul><li><p><code>model::Model</code>: The DynamicPPL model that was tested</p></li><li><p><code>getlogdensity::Function</code>: The function used to extract the log density from the model</p></li><li><p><code>varinfo::AbstractVarInfo</code>: The VarInfo that was used</p></li><li><p><code>params::Vector{Tparams} where Tparams&lt;:AbstractFloat</code>: The values at which the model was evaluated</p></li><li><p><code>adtype::ADTypes.AbstractADType</code>: The AD backend that was tested</p></li><li><p><code>atol::AbstractFloat</code>: Absolute tolerance used for correctness test</p></li><li><p><code>rtol::AbstractFloat</code>: Relative tolerance used for correctness test</p></li><li><p><code>value_expected::Union{Nothing, Tresult} where Tresult&lt;:AbstractFloat</code>: The expected value of logp</p></li><li><p><code>grad_expected::Union{Nothing, Vector{Tresult}} where Tresult&lt;:AbstractFloat</code>: The expected gradient of logp</p></li><li><p><code>value_actual::AbstractFloat</code>: The value of logp (calculated using <code>adtype</code>)</p></li><li><p><code>grad_actual::Vector{Tresult} where Tresult&lt;:AbstractFloat</code>: The gradient of logp (calculated using <code>adtype</code>)</p></li><li><p><code>grad_time::Union{Nothing, Tresult} where Tresult&lt;:AbstractFloat</code>: If benchmarking was requested, the time taken by the AD backend to evaluate the gradient     of logp (in seconds)</p></li><li><p><code>primal_time::Union{Nothing, Tresult} where Tresult&lt;:AbstractFloat</code>: If benchmarking was requested, the time taken by the AD backend to evaluate logp (in     seconds)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/ad.jl#L129-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.ADIncorrectException"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.ADIncorrectException"><code>DynamicPPL.TestUtils.AD.ADIncorrectException</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ADIncorrectException{T&lt;:AbstractFloat}</code></pre><p>Exception thrown when an AD backend returns an incorrect value or gradient.</p><p>The type parameter <code>T</code> is the numeric type of the value and gradient.</p><p><strong>Fields</strong></p><ul><li><p><code>value_expected::AbstractFloat</code></p></li><li><p><code>value_actual::AbstractFloat</code></p></li><li><p><code>grad_expected::Vector{T} where T&lt;:AbstractFloat</code></p></li><li><p><code>grad_actual::Vector{T} where T&lt;:AbstractFloat</code></p></li><li><p><code>atol::AbstractFloat</code></p></li><li><p><code>rtol::AbstractFloat</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/ad.jl#L67-L76">source</a></section></details></article><h2 id="Demo-models"><a class="docs-heading-anchor" href="#Demo-models">Demo models</a><a id="Demo-models-1"></a><a class="docs-heading-anchor-permalink" href="#Demo-models" title="Permalink"></a></h2><p>DynamicPPL provides several demo models in the <code>DynamicPPL.TestUtils</code> submodule.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.DEMO_MODELS"><a class="docstring-binding" href="#DynamicPPL.TestUtils.DEMO_MODELS"><code>DynamicPPL.TestUtils.DEMO_MODELS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>A collection of models corresponding to the posterior distribution defined by the generative process</p><pre><code class="language-julia hljs">s ~ InverseGamma(2, 3)
m ~ Normal(0, √s)
1.5 ~ Normal(m, √s)
2.0 ~ Normal(m, √s)</code></pre><p>or by</p><pre><code class="language-julia hljs">s[1] ~ InverseGamma(2, 3)
s[2] ~ InverseGamma(2, 3)
m[1] ~ Normal(0, √s)
m[2] ~ Normal(0, √s)
1.5 ~ Normal(m[1], √s[1])
2.0 ~ Normal(m[2], √s[2])</code></pre><p>These are examples of a Normal-InverseGamma conjugate prior with Normal likelihood, for which the posterior is known in closed form.</p><p>In particular, for the univariate model (the former one):</p><pre><code class="language-julia hljs">mean(s) == 49 / 24
mean(m) == 7 / 6</code></pre><p>And for the multivariate one (the latter one):</p><pre><code class="language-julia hljs">mean(s[1]) == 19 / 8
mean(m[1]) == 3 / 4
mean(s[2]) == 8 / 3
mean(m[2]) == 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/models.jl#L833-L866">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.ALL_MODELS"><a class="docstring-binding" href="#DynamicPPL.TestUtils.ALL_MODELS"><code>DynamicPPL.TestUtils.ALL_MODELS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>A tuple of all models defined in DynamicPPL.TestUtils.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/models.jl#L884-L886">source</a></section></details></article><p>For every demo model, one can define the true log prior, log likelihood, and log joint probabilities.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.logprior_true"><a class="docstring-binding" href="#DynamicPPL.TestUtils.logprior_true"><code>DynamicPPL.TestUtils.logprior_true</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logprior_true(model, args...)</code></pre><p>Return the <code>logprior</code> of <code>model</code> for <code>args</code>.</p><p>This should generally be implemented by hand for every specific <code>model</code>.</p><p>See also: <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, <a href="#DynamicPPL.TestUtils.loglikelihood_true"><code>loglikelihood_true</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/model_interface.jl#L7-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.loglikelihood_true"><a class="docstring-binding" href="#DynamicPPL.TestUtils.loglikelihood_true"><code>DynamicPPL.TestUtils.loglikelihood_true</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">loglikelihood_true(model, args...)</code></pre><p>Return the <code>loglikelihood</code> of <code>model</code> for <code>args</code>.</p><p>This should generally be implemented by hand for every specific <code>model</code>.</p><p>See also: <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/model_interface.jl#L18-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.logjoint_true"><a class="docstring-binding" href="#DynamicPPL.TestUtils.logjoint_true"><code>DynamicPPL.TestUtils.logjoint_true</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logjoint_true(model, args...)</code></pre><p>Return the <code>logjoint</code> of <code>model</code> for <code>args</code>.</p><p>Defaults to <code>logprior_true(model, args...) + loglikelihood_true(model, args..)</code>.</p><p>This should generally be implemented by hand for every specific <code>model</code> so that the returned value can be used as a ground-truth for testing things like:</p><ol><li>Validity of evaluation of <code>model</code> using a particular implementation of <code>AbstractVarInfo</code>.</li><li>Validity of a sampler when combined with DynamicPPL by running the sampler twice: once targeting ground-truth functions, e.g. <code>logjoint_true</code>, and once targeting <code>model</code>.</li></ol><p>And more.</p><p>See also: <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>, <a href="#DynamicPPL.TestUtils.loglikelihood_true"><code>loglikelihood_true</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/model_interface.jl#L29-L45">source</a></section></details></article><p>And in the case where the model includes constrained variables, it can also be useful to define</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian"><a class="docstring-binding" href="#DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian"><code>DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logprior_true_with_logabsdet_jacobian(model::Model, args...)</code></pre><p>Return a tuple <code>(args_unconstrained, logprior_unconstrained)</code> of <code>model</code> for <code>args...</code>.</p><p>Unlike <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>, the returned logprior computation includes the log-absdet-jacobian adjustment, thus computing logprior for the unconstrained variables.</p><p>Note that <code>args</code> are assumed be in the support of <code>model</code>, while <code>args_unconstrained</code> will be unconstrained.</p><p>See also: <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/model_interface.jl#L71-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian"><a class="docstring-binding" href="#DynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian"><code>DynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logjoint_true_with_logabsdet_jacobian(model::Model, args...)</code></pre><p>Return a tuple <code>(args_unconstrained, logjoint)</code> of <code>model</code> for <code>args</code>.</p><p>Unlike <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, the returned logjoint computation includes the log-absdet-jacobian adjustment, thus computing logjoint for the unconstrained variables.</p><p>Note that <code>args</code> are assumed be in the support of <code>model</code>, while <code>args_unconstrained</code> will be unconstrained.</p><p>This should generally not be implemented directly, instead one should implement <a href="#DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian"><code>logprior_true_with_logabsdet_jacobian</code></a> for a given <code>model</code>.</p><p>See also: <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, <a href="#DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian"><code>logprior_true_with_logabsdet_jacobian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/model_interface.jl#L50-L65">source</a></section></details></article><p>Finally, the following methods can also be of use:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.varnames"><a class="docstring-binding" href="#DynamicPPL.TestUtils.varnames"><code>DynamicPPL.TestUtils.varnames</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">varnames(model::Model)</code></pre><p>Return the VarNames defined in <code>model</code>, as a Vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/models.jl#L10-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.posterior_mean"><a class="docstring-binding" href="#DynamicPPL.TestUtils.posterior_mean"><code>DynamicPPL.TestUtils.posterior_mean</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">posterior_mean(model::Model)</code></pre><p>Return a <code>NamedTuple</code> compatible with <code>varnames(model)</code> where the values represent the posterior mean under <code>model</code>.</p><p>&quot;Compatible&quot; means that a <code>varname</code> from <code>varnames(model)</code> can be used to extract the corresponding value using e.g. <code>AbstractPPL.getvalue(posterior_mean(model), varname)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/model_interface.jl#L103-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.setup_varinfos"><a class="docstring-binding" href="#DynamicPPL.TestUtils.setup_varinfos"><code>DynamicPPL.TestUtils.setup_varinfos</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setup_varinfos(model::Model, example_values::NamedTuple; include_threadsafe::Bool=false)</code></pre><p>Return a tuple of instances for different implementations of <code>AbstractVarInfo</code> with each <code>vi</code>, supposedly, satisfying <code>vi[vn] == get(example_values, vn)</code> for <code>vn</code> in <code>varnames</code>.</p><p>If <code>include_threadsafe</code> is <code>true</code>, then the returned tuple will also include thread-safe versions of the varinfo instances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/varinfo.jl#L24-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.test_values"><a class="docstring-binding" href="#DynamicPPL.TestUtils.test_values"><code>DynamicPPL.TestUtils.test_values</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_values(vi::AbstractVarInfo, vals::NamedTuple, vns)</code></pre><p>Test that <code>vi[vn]</code> corresponds to the correct value in <code>vals</code> for every <code>vn</code> in <code>vns</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/test_utils/varinfo.jl#L6-L10">source</a></section></details></article><h2 id="Debugging-Utilities"><a class="docs-heading-anchor" href="#Debugging-Utilities">Debugging Utilities</a><a id="Debugging-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging-Utilities" title="Permalink"></a></h2><p>DynamicPPL provides a few methods for checking validity of a model-definition.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.DebugUtils.check_model"><a class="docstring-binding" href="#DynamicPPL.DebugUtils.check_model"><code>DynamicPPL.DebugUtils.check_model</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.DebugUtils.check_model(
    [rng::Random.AbstractRNG,]
    model::Model;
    error_on_failure=false,
    fail_if_discrete=false
)</code></pre><p>Check <code>model</code> for potential issues. Returns <code>true</code> if the model check succeeded, <code>false</code> otherwise.</p><p>The model is only evaluated a single time, so if the model contains any indeterminism, results may differ across runs. The <code>rng</code> argument can be used to control reproducibility if needed.</p><p><strong>Issues that this function checks for</strong></p><ul><li><p>Repeated usage of the same or overlapping VarNames</p></li><li><p><code>NaN</code> on the left-hand side of observe statements</p></li><li><p>(if <code>fail_if_discrete</code> is set) Usage of discrete distributions</p></li><li><p>Empty models emit a warning, but do not fail (since they are not incorrect <em>per se</em>)</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>error_on_failure::Bool</code>: Whether to throw an error (instead of just returning <code>false</code>) if the model check fails.</p></li><li><p><code>fail_if_discrete::Bool</code>: Whether to fail (i.e., return <code>false</code> or throw an error,  depending on <code>error_on_failure</code>) when the model contains discrete distributions. Discrete  distributions do not have a differentiable log-density and are incompatible with  gradient-based approaches such as HMC / NUTS or optimisation.</p></li></ul><p><strong>Examples</strong></p><p><strong>Correct model</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL.DebugUtils: check_model; using Distributions

julia&gt; @model demo_correct() = x ~ Normal()
demo_correct (generic function with 2 methods)

julia&gt; model = demo_correct();

julia&gt; check_model(model)
true

julia&gt; cond_model = model | (x = 1.0,);

julia&gt; # Empty models will issue a warning, but not a failure
       check_model(cond_model)
┌ Warning: The model does not contain any parameters.
└ @ DynamicPPL.DebugUtils DynamicPPL.jl/src/debug_utils.jl:215
true</code></pre><p><strong>Incorrect model</strong></p><p>```jldoctest; setup=:(using Distributions) julia&gt; using DynamicPPL.DebugUtils: check_model; using Distributions</p><p>julia&gt; @model function demo<em>incorrect()            # Sampling <code>x</code> twice.            x ~ Normal()            x ~ Exponential()        end demo</em>incorrect (generic function with 2 methods)</p><p>julia&gt; # Notice that VarInfo(model<em>incorrect) evaluates the model, but doesn&#39;t actually        # alert us to the issue of <code>x</code> being sampled twice.        model = demo</em>incorrect(); varinfo = VarInfo(model);</p><p>julia&gt; check<em>model(model; error</em>on_failure=true) ERROR: varname x used multiple times in model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/debug_utils.jl#L111-L188">source</a></section></details></article><p>And some which might be useful to determine certain properties of the model based on the debug trace.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.DebugUtils.has_static_constraints"><a class="docstring-binding" href="#DynamicPPL.DebugUtils.has_static_constraints"><code>DynamicPPL.DebugUtils.has_static_constraints</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_static_constraints([rng, ]model::Model; num_evals=5)</code></pre><p>Attempts to detect whether <code>model</code> has static constraints (i.e., the support of all variables is the same regardless of what their values are). Returns <code>true</code> if the model has static constraints, <code>false</code> otherwise.</p><p>Note that this is a heuristic check based on sampling from the model multiple times and checking if the model is consistent across runs.</p><p><strong>Arguments</strong></p><ul><li><code>rng::Random.AbstractRNG</code>: The random number generator to use when evaluating the model.</li><li><code>model::Model</code>: The model to check.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>num_evals::Int</code>: The number of evaluations to perform. Default: <code>5</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/debug_utils.jl#L278-L295">source</a></section></details></article><p>For determining whether one might have type instabilities in the model, the following can be useful</p><article><details class="docstring" open="true"><summary id="DynamicPPL.DebugUtils.model_warntype"><a class="docstring-binding" href="#DynamicPPL.DebugUtils.model_warntype"><code>DynamicPPL.DebugUtils.model_warntype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">model_warntype(model[, varinfo]; optimize=true)</code></pre><p>Check the type stability of the model&#39;s evaluator, warning about any potential issues.</p><p>This simply calls <code>@code_warntype</code> on the model&#39;s evaluator, filling in internal arguments where needed.</p><p><strong>Arguments</strong></p><ul><li><code>model::Model</code>: The model to check.</li><li><code>varinfo::AbstractVarInfo</code>: The varinfo to use when evaluating the model. Default: <code>VarInfo(model)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>optimize::Bool</code>: Whether to generate optimized code. Default: <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/debug_utils.jl#L343-L356">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.DebugUtils.model_typed"><a class="docstring-binding" href="#DynamicPPL.DebugUtils.model_typed"><code>DynamicPPL.DebugUtils.model_typed</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">model_typed(model[, varinfo]; optimize=true)</code></pre><p>Return the type inference for the model&#39;s evaluator.</p><p>This simply calls <code>@code_typed</code> on the model&#39;s evaluator, filling in internal arguments where needed.</p><p><strong>Arguments</strong></p><ul><li><code>model::Model</code>: The model to check.</li><li><code>varinfo::AbstractVarInfo</code>: The varinfo to use when evaluating the model. Default: <code>VarInfo(model)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>optimize::Bool</code>: Whether to generate optimized code. Default: <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/debug_utils.jl#L364-L377">source</a></section></details></article><p>Interally, the type-checking methods make use of the following method for construction of the call with the argument types:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.DebugUtils.gen_evaluator_call_with_types"><a class="docstring-binding" href="#DynamicPPL.DebugUtils.gen_evaluator_call_with_types"><code>DynamicPPL.DebugUtils.gen_evaluator_call_with_types</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gen_evaluator_call_with_types(model[, varinfo])</code></pre><p>Generate the evaluator call and the types of the arguments.</p><p><strong>Arguments</strong></p><ul><li><code>model::Model</code>: The model whose evaluator is of interest.</li><li><code>varinfo::AbstractVarInfo</code>: The varinfo to use when evaluating the model. Default: <code>VarInfo(model)</code>.</li></ul><p><strong>Returns</strong></p><p>A 2-tuple with the following elements:</p><ul><li><code>f</code>: This is either <code>model.f</code> or <code>Core.kwcall</code>, depending on whether   the model has keyword arguments.</li><li><code>argtypes::Type{&lt;:Tuple}</code>: The types of the arguments for the evaluator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/debug_utils.jl#L317-L331">source</a></section></details></article><h2 id="Advanced"><a class="docs-heading-anchor" href="#Advanced">Advanced</a><a id="Advanced-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced" title="Permalink"></a></h2><h3 id="Variable-names"><a class="docs-heading-anchor" href="#Variable-names">Variable names</a><a id="Variable-names-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-names" title="Permalink"></a></h3><p>Names and possibly nested indices of variables are described with <code>AbstractPPL.VarName</code>. They can be defined with <code>AbstractPPL.@varname</code>. Please see the documentation of <a href="https://github.com/TuringLang/AbstractPPL.jl">AbstractPPL.jl</a> for further information.</p><h3 id="Data-Structures-of-Variables"><a class="docs-heading-anchor" href="#Data-Structures-of-Variables">Data Structures of Variables</a><a id="Data-Structures-of-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures-of-Variables" title="Permalink"></a></h3><p>DynamicPPL provides a data structure for storing samples and accumulation of the log-probabilities, called <a href="../vnt/arraylikeblocks/#VarInfo"><code>VarInfo</code></a>. The interface that <code>VarInfo</code> respects is described by the abstract type <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a>. Internally DynamicPPL also uses a couple of other subtypes of <code>AbstractVarInfo</code>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractVarInfo"><a class="docstring-binding" href="#DynamicPPL.AbstractVarInfo"><code>DynamicPPL.AbstractVarInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractVarInfo</code></pre><p>Abstract supertype for data structures that capture random variables when executing a probabilistic model and accumulate log densities such as the log likelihood or the log joint probability of the model.</p><p>See also: <a href="../vnt/arraylikeblocks/#VarInfo"><code>VarInfo</code></a>, <a href="#DynamicPPL.OnlyAccsVarInfo"><code>OnlyAccsVarInfo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/DynamicPPL.jl#L210-L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VarInfo"><a class="docstring-binding" href="#DynamicPPL.VarInfo"><code>DynamicPPL.VarInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VarInfo{
    Tfm&lt;:AbstractTransformStrategy,
    T&lt;:VarNamedTuple,
    Accs&lt;:AccumulatorTuple
} &lt;: AbstractVarInfo</code></pre><p>The default implementation of <code>AbstractVarInfo</code>, storing variable values and accumulators.</p><p><code>VarInfo</code> is quite a thin wrapper around a <code>VarNamedTuple</code> storing the variable values, and a tuple of accumulators. The only really noteworthy thing about it is that it stores the values of variables vectorised as instances of <a href="#DynamicPPL.AbstractTransformedValue"><code>AbstractTransformedValue</code></a>. That is, it stores each value as a special vector with a flag indicating whether it is just a vectorised value (<a href="#DynamicPPL.VectorValue"><code>VectorValue</code></a>), or whether it is also linked (<a href="#DynamicPPL.LinkedVectorValue"><code>LinkedVectorValue</code></a>). It also stores the size of the actual post-transformation value. These are all accessible via <a href="#DynamicPPL.AbstractTransformedValue"><code>AbstractTransformedValue</code></a>.</p><p><code>VarInfo</code> additionally stores a transform strategy, which reflects the linked status of variables inside the <code>VarInfo</code>. For example, a <code>VarInfo{LinkAll}</code> should contain only <code>LinkedVectorValue</code>s in its <code>values</code> field.</p><p>Because the job of <code>VarInfo</code> is to store transformed values, there is no generic <code>setindex!!</code> implementation on <code>VarInfo</code> itself. Instead, all storage must go via <a href="#DynamicPPL.setindex_with_dist!!"><code>setindex_with_dist!!</code></a>, which takes care of storing the value in the correct transformed form. This in turn means that the distribution on the right-hand side of a tilde-statement must be available when modifying a VarInfo.</p><p>You can use <code>getindex</code> on <code>VarInfo</code> to obtain values in the support of the original distribution. To directly get access to the internal vectorised values, use <a href="#DynamicPPL.getindex_internal"><code>getindex_internal</code></a>, <a href="#DynamicPPL.setindex_internal!!"><code>setindex_internal!!</code></a>, and <a href="#DynamicPPL.unflatten!!"><code>unflatten!!</code></a>.</p><p>For more details on the internal storage, see documentation of <a href="#DynamicPPL.AbstractTransformedValue"><code>AbstractTransformedValue</code></a> and <a href="#DynamicPPL.VarNamedTuples.VarNamedTuple"><code>VarNamedTuple</code></a>.</p><p><strong>Fields</strong></p><ul><li><p><code>transform_strategy::AbstractTransformStrategy</code></p></li><li><p><code>values::VarNamedTuple</code></p></li><li><p><code>accs::DynamicPPL.AccumulatorTuple</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varinfo.jl#L1-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setindex_with_dist!!"><a class="docstring-binding" href="#DynamicPPL.setindex_with_dist!!"><code>DynamicPPL.setindex_with_dist!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setindex_with_dist!!(
    vi::VarInfo,
    tval::Union{VectorValue,LinkedVectorValue},
    dist::Distribution,
    vn::VarName,
    template::Any,
)</code></pre><p>Set the value of <code>vn</code> in <code>vi</code> to <code>tval</code>. Note that this will cause the linked status of <code>vi</code> to update according to what <code>tval</code> is. That means that whether or not a variable is considered to be &#39;linked&#39; is determined by <code>tval</code> rather than the previous status of <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varinfo.jl#L272-L284">source</a></section><section><div><pre><code class="language-julia hljs">setindex_with_dist!!(
    vi::VarInfo,
    tval::UntransformedValue,
    dist::Distribution,
    vn::VarName,
    template::Any
)</code></pre><p>Vectorise <code>tval</code> (into a <code>VectorValue</code>) and store it. (Note that if <code>setindex_with_dist!!</code> receives an <code>UntransformedValue</code>, the variable is always considered unlinked, since if it were to be linked, <code>apply_transform_strategy</code> will already have done so.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varinfo.jl#L300-L312">source</a></section></details></article><p>One main characteristic of <a href="../vnt/arraylikeblocks/#VarInfo"><code>VarInfo</code></a> is that samples are transformed to unconstrained Euclidean space and stored in a linearized form, as described in the <a href="https://turinglang.org/docs/developers/transforms/dynamicppl/">main Turing documentation</a>. The <a href="#Transformations">Transformations section below</a> describes the methods used for this. In the specific case of <code>VarInfo</code>, it keeps track of whether samples have been transformed by setting flags on them, using the following functions.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.is_transformed"><a class="docstring-binding" href="#DynamicPPL.is_transformed"><code>DynamicPPL.is_transformed</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_transformed(vi::AbstractVarInfo[, vns::Union{VarName, AbstractVector{&lt;:Varname}}])</code></pre><p>Return <code>true</code> if <code>vi</code> is working in unconstrained space, and <code>false</code> if <code>vi</code> is assuming realizations to be in support of the corresponding distributions.</p><p>If <code>vns</code> is provided, then only check if this/these varname(s) are transformed.</p><div class="admonition is-warning" id="Warning-3a921ac8441c589"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-3a921ac8441c589" title="Permalink"></a></header><div class="admonition-body"><p>Not all implementations of <code>AbstractVarInfo</code> support transforming only a subset of the variables.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L700-L711">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.set_transformed!!"><a class="docstring-binding" href="#DynamicPPL.set_transformed!!"><code>DynamicPPL.set_transformed!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_transformed!!(vi::AbstractVarInfo, trans::Bool[, vn::VarName])</code></pre><p>Return <code>vi</code> with <code>is_transformed(vi, vn)</code> evaluating to <code>true</code>.</p><p>If <code>vn</code> is not specified, then <code>is_transformed(vi)</code> evaluates to <code>true</code> for all variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L725-L731">source</a></section></details></article><h4 id="VarNamedTuples"><a class="docs-heading-anchor" href="#VarNamedTuples"><code>VarNamedTuple</code>s</a><a id="VarNamedTuples-1"></a><a class="docs-heading-anchor-permalink" href="#VarNamedTuples" title="Permalink"></a></h4><p><code>VarInfo</code> is only a thin wrapper around <a href="#DynamicPPL.VarNamedTuples.VarNamedTuple"><code>VarNamedTuple</code></a>, which stores arbitrary data keyed by <code>VarName</code>s. For more details on <code>VarNamedTuple</code>, see the Internals section of our documentation.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.VarNamedTuples.VarNamedTuple"><a class="docstring-binding" href="#DynamicPPL.VarNamedTuples.VarNamedTuple"><code>DynamicPPL.VarNamedTuples.VarNamedTuple</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VarNamedTuple{names,Values}</code></pre><p>A <code>NamedTuple</code>-like structure with <code>VarName</code> keys.</p><p><code>VarNamedTuple</code> is a data structure for storing arbitrary data, keyed by <code>VarName</code>s, in an efficient and type stable manner. It is mainly used through <code>getindex</code>, <code>setindex!!</code>, <code>templated_setindex!!</code>, and <code>haskey</code>, all of which only accept <code>VarName</code>s as keys. Other notable methods are <code>merge</code> and <code>subset</code>.</p><p><code>VarNamedTuple</code> has an ordering to its elements, and two <code>VarNamedTuple</code>s with the same keys and values but in different orders are considered different for equality and hashing. Iterations such as <code>keys</code> and <code>values</code> respect this ordering. The ordering is dependent on the order in which elements were inserted into the <code>VarNamedTuple</code>, though isn&#39;t always equal to it. More specifically</p><ul><li>Any new keys that have a joint parent <code>VarName</code> with an existing key are inserted after that key. For instance, if one first inserts, in order, <code>@varname(a.x)</code>, <code>@varname(b)</code>, and <code>@varname(a.y)</code>, the resulting order will be <code>(@varname(a.x), @varname(a.y), @varname(b))</code>.</li><li><code>Index</code> keys<code>, like</code>@varname(a[3])<code>or</code>@varname(b[2,3,4:5])<code>, are always iterated in the same order an</code>Array<code>with the same indices would be iterated. For instance, if one first inserts, in order,</code>@varname(a[2])<code>,</code>@varname(b)<code>, and</code>@varname(a[1])<code>, the resulting order will be</code>(@varname(a[1]), @varname(a[2]), @varname(b))`.</li></ul><p>Otherwise insertion order is respected.</p><p><code>setindex!!</code> and <code>getindex</code> on <code>VarNamedTuple</code> are type stable as long as one does not store heterogeneous data under different indices of the same symbol. That is, if either</p><ul><li>one sets <code>a[1]</code> and <code>a[2]</code> to be of different types, or</li><li>if <code>a[1]</code> and <code>a[2]</code> both exist, one sets <code>a[1].b</code> without setting <code>a[2].b</code>,</li></ul><p>then getting values for <code>a[1]</code> or <code>a[2]</code> will not be type stable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varnamedtuple/vnt.jl#L1-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VarNamedTuples.@vnt"><a class="docstring-binding" href="#DynamicPPL.VarNamedTuples.@vnt"><code>DynamicPPL.VarNamedTuples.@vnt</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@vnt begin ... end</code></pre><p>Construct a <code>VarNamedTuple</code> from a block of assignments. Each assignment should be of the form <code>var := value</code>, where <code>var</code> is a variable name. This is best illustrated by example:</p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL

julia&gt; @vnt begin
           a := 1
           b := 2
       end
VarNamedTuple
├─ a =&gt; 1
└─ b =&gt; 2</code></pre><p>You can set entirely arbitrary variables:</p><pre><code class="language-julia-repl hljs">julia&gt; @vnt begin
           a.b.c.d.e := &quot;hello&quot;
       end
VarNamedTuple
└─ a =&gt; VarNamedTuple
        └─ b =&gt; VarNamedTuple
                └─ c =&gt; VarNamedTuple
                        └─ d =&gt; VarNamedTuple
                                └─ e =&gt; &quot;hello&quot;</code></pre><p>For variables that have indexing, it is often necessary to provide a template, so that the VNT &#39;knows&#39; what kind of array is being used to store the values, and can set the values in the appropriate places (consider e.g. OffsetArrays where <code>x[1]</code> may not mean what it usually does).</p><p>This is done by inserting a <code>@template</code> macro call in the block. The <code>@template</code> macro accepts whitespace-separated arguments, which must either be</p><ul><li>a single symbol (e.g. <code>@template x</code>), in which case the template is the value of <code>x</code> (and <code>x</code> must already be defined in the current scope); or</li><li>an assignment of the form <code>y = expr</code>, in which case the template for <code>y</code> is the value of <code>expr</code>. In this case <code>y</code> does not need to be defined in the current scope, but any symbols referenced in <code>expr</code> must be.</li></ul><p>For example:</p><pre><code class="language-julia-repl hljs">julia&gt; x = zeros(5); outside_y = zeros(3, 3);

julia&gt; @vnt begin
            @template x y=outside_y
            x[1] := 1.0
            y[1, 1] := 2.0
       end
VarNamedTuple
├─ x =&gt; PartialArray size=(5,) data::Vector{Float64}
│       └─ (1,) =&gt; 1.0
└─ y =&gt; PartialArray size=(3, 3) data::Matrix{Float64}
        └─ (1, 1) =&gt; 2.0</code></pre><div class="admonition is-info" id="Note-42764d613b688013"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-42764d613b688013" title="Permalink"></a></header><div class="admonition-body"><p>You can use any expression in <code>@template y=expr</code>, even a function call that is completely contained within the macro (e.g. <code>@template y=zeros(3, 3)</code>). The macro makes sure that <code>expr</code> is only evaluated once, so there is no performance penalty to doing this.</p></div></div><p>If no template is provided, the VNT will use a <code>GrowableArray</code>. This can produce correct results in simple cases, but is not recommended for general use. Please see the VarNamedTuple documentation for more details.</p><pre><code class="language-julia-repl hljs">julia&gt; @vnt begin
            # No template provided.
            x[1] := 1.0
            y[1, 1] := 2.0
       end
┌ Warning: Creating a growable `Base.Array` of dimension 1 to store values. This may not match the actual type or size of the actual `AbstractArray` that will be used inside the DynamicPPL model.
│
│  If this is not the type or size that you expect, please see: https://turinglang.org/docs/uri/growablearray
└ @ DynamicPPL.VarNamedTuples /path/to/DynamicPPL.jl/src/varnamedtuple/partial_array.jl:823
┌ Warning: Creating a growable `Base.Array` of dimension 2 to store values. This may not match the actual type or size of the actual `AbstractArray` that will be used inside the DynamicPPL model.
│
│  If this is not the type or size that you expect, please see: https://turinglang.org/docs/uri/growablearray
└ @ DynamicPPL.VarNamedTuples /path/to/DynamicPPL.jl/src/varnamedtuple/partial_array.jl:823
VarNamedTuple
├─ x =&gt; PartialArray size=(1,) data::DynamicPPL.VarNamedTuples.GrowableArray{Float64, 1}
│       └─ (1,) =&gt; 1.0
└─ y =&gt; PartialArray size=(1, 1) data::DynamicPPL.VarNamedTuples.GrowableArray{Float64, 2}
        └─ (1, 1) =&gt; 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varnamedtuple/macro.jl#L1-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VarNamedTuples.apply!!"><a class="docstring-binding" href="#DynamicPPL.VarNamedTuples.apply!!"><code>DynamicPPL.VarNamedTuples.apply!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply!!(func, vnt::VarNamedTuple, name::VarName)</code></pre><p>Apply <code>func</code> to the subdata at <code>name</code> in <code>vnt</code>, and set the result back at <code>name</code>.</p><p>Like <code>map_values!!</code>, but only for a single <code>VarName</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL: VarNamedTuple, setindex!!

julia&gt; using DynamicPPL.VarNamedTuples: apply!!

julia&gt; vnt = VarNamedTuple()
VarNamedTuple()

julia&gt; vnt = setindex!!(vnt, [1, 2, 3], @varname(a))
VarNamedTuple
└─ a =&gt; [1, 2, 3]

julia&gt; apply!!(x -&gt; x .+ 1, vnt, @varname(a))
VarNamedTuple
└─ a =&gt; [2, 3, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varnamedtuple/map.jl#L51-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VarNamedTuples.densify!!"><a class="docstring-binding" href="#DynamicPPL.VarNamedTuples.densify!!"><code>DynamicPPL.VarNamedTuples.densify!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">densify!!(vnt::VarNamedTuple)</code></pre><p>Convert any <code>PartialArray</code>s in <code>vnt</code> where all elements are filled to just normal arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varnamedtuple/map.jl#L456-L460">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VarNamedTuples.map_pairs!!"><a class="docstring-binding" href="#DynamicPPL.VarNamedTuples.map_pairs!!"><code>DynamicPPL.VarNamedTuples.map_pairs!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">map_pairs!!(func, vnt::VarNamedTuple)</code></pre><p>Apply <code>func</code> to all key =&gt; value pairs of <code>vnt</code>, in place if possible.</p><p><code>func</code> should accept a pair of <code>VarName</code> and value, and return the new value to be set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varnamedtuple/map.jl#L303-L309">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VarNamedTuples.map_values!!"><a class="docstring-binding" href="#DynamicPPL.VarNamedTuples.map_values!!"><code>DynamicPPL.VarNamedTuples.map_values!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">map_values!!(func, vnt::VarNamedTuple)</code></pre><p>Apply <code>func</code> to elements of <code>vnt</code>, in place if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varnamedtuple/map.jl#L323-L327">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VarNamedTuples.PartialArray"><a class="docstring-binding" href="#DynamicPPL.VarNamedTuples.PartialArray"><code>DynamicPPL.VarNamedTuples.PartialArray</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PartialArray{
    ElType,
    num_dims,
    D&lt;:AbstractArray{ElType,num_dims},
    M&lt;:AbstractArray{Bool,num_dims}
}</code></pre><p>An array-like like structure that may only have some of its elements defined.</p><p>One can set values in a <code>PartialArray</code> either element-by-element, or with ranges like <code>arr[1:3,2] = [5,10,15]</code>. </p><p>When setting values over a range of indices, the value being set can be an <code>AbstractArray</code> whose size matches the range (in which case the values are set elementwise). If the value is some other object, it can still be stored as an <code>ArrayLikeBlock</code>. Retrieving such a block-value must be done with the exact same range of indices, otherwise an error is thrown. Please see <a href="../vnt/arraylikeblocks/#array-like-blocks">the DynamicPPL documentation</a> for more information on this.</p><p>If the element type of a <code>PartialArray</code> is not concrete, any call to <code>setindex!!</code> will check if, after the new value has been set, the element type can be made more concrete. If so, a new <code>PartialArray</code> with a more concrete element type is returned. Thus the element type of any <code>PartialArray</code> should always be as concrete as is allowed by the elements in it.</p><p>The internal implementation of an <code>PartialArray</code> consists of two arrays: one holding the data and the other one being a boolean mask indicating which elements are defined. These internal arrays may need resizing when new elements are set that have index ranges larger than the current internal arrays. To avoid resizing too often, the internal arrays are resized in exponentially increasing steps. This means that most <code>setindex!!</code> calls are very fast, but some may incur substantial overhead due to resizing and copying data. It also means that the largest index set so far determines the memory usage of the <code>PartialArray</code>. <code>PartialArray</code>s are thus well-suited when most values in it will eventually be set. If only a few scattered values are set, a structure like <code>SparseArray</code> may be more appropriate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varnamedtuple/partial_array.jl#L143-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VarNamedTuples.templated_setindex!!"><a class="docstring-binding" href="#DynamicPPL.VarNamedTuples.templated_setindex!!"><code>DynamicPPL.VarNamedTuples.templated_setindex!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.VarNamedTuples.templated_setindex!!(vnt, value, vn, template; allow_new=Val(true))</code></pre><p>Assign <code>value</code> to the location in <code>vnt</code> specified by <code>vn</code>.</p><p>The argument <code>template</code> must be provided in order to guide the creation of <code>PartialArray</code>s, as well as to concretise any dynamic indices in <code>vn</code>. It must be an object that has the shape of the top-level symbol in <code>vn</code>. For example:</p><pre><code class="language-julia hljs">vnt = VarNamedTuple()
templated_setindex!!(vnt, 10, @varname(x[1]), rand(2, 2))</code></pre><p>Here, <code>rand(2, 2)</code> is the template for the top-level symbol <code>x</code>, which tells <code>setindex!!</code> that <code>x</code> should be a <code>PartialArray</code> that is backed by a matrix.</p><p>The actual data inside <code>template</code> is not needed, and <code>template</code> is never mutated by this call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varnamedtuple/vnt.jl#L95-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VarNamedTuples.NoTemplate"><a class="docstring-binding" href="#DynamicPPL.VarNamedTuples.NoTemplate"><code>DynamicPPL.VarNamedTuples.NoTemplate</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoTemplate</code></pre><p>A singleton struct representing the fact that there is no template for a top-level variable. When <code>NoTemplate</code> is used, several things happen:</p><ul><li>If you attempt to call <code>make_leaf</code> with an Index optic, this will error.</li><li>When recursing into substructures, <code>NoTemplate</code> will be propagated.</li></ul><p>Collectively this means that you can only set values for variables that only have Property optics, unless a template is provided.</p><p>It might seem more idiomatic to use <code>nothing</code> or <code>missing</code> for this. However, this causes a bug with BangBang.setindex!!: https://github.com/JuliaFolds2/BangBang.jl/issues/43 so we use a dedicated struct instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varnamedtuple.jl#L20-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VarNamedTuples.SkipTemplate"><a class="docstring-binding" href="#DynamicPPL.VarNamedTuples.SkipTemplate"><code>DynamicPPL.VarNamedTuples.SkipTemplate</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SkipTemplate{N}(value)</code></pre><p>A struct representing the fact that <code>value</code> is the template for the variable <code>N</code> levels down from the top-level variable. In other words, SkipTemplate{0}(value) is equivalent to just <code>value</code>, and SkipTemplate{1}(value) means that <code>value</code> is the template for <code>a</code> when setting the variable <code>@varname(x.a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varnamedtuple.jl#L38-L45">source</a></section></details></article><p>VarNamedTuple provides a Dict-like interface, so you can iterate over <code>keys(vnt)</code>, <code>values(vnt)</code>, and <code>pairs(vnt)</code>. You can also use <code>getindex(vnt, key)</code>, but <code>setindex!</code> is not allowed: all changes to a <code>VarNamedTuple</code> must be done via <code>setindex!!</code> or <code>templated_setindex!!</code>. Please see the VarNamedTuple documentation for more details.</p><p>You can convert a <code>VarNamedTuple</code> to a NamedTuple in the case where all keys are VarNames with identity optics.</p><article><details class="docstring" open="true"><summary id="Core.NamedTuple-Tuple{VarNamedTuple}"><a class="docstring-binding" href="#Core.NamedTuple-Tuple{VarNamedTuple}"><code>Core.NamedTuple</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NamedTuple(vnt::VarNamedTuple)</code></pre><p>Convert a <code>VarNamedTuple</code> to a standard <code>NamedTuple</code>, provided all keys in the <code>VarNamedTuple</code> are <code>VarName</code>s with top-level symbols. If any key is a <code>VarName</code> with a non-identity optic (e.g., <code>@varname(x.a)</code> or <code>@varname(x[1])</code>), this will throw an <code>ArgumentError</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, BangBang

julia&gt; vnt = VarNamedTuple(); vnt = setindex!!(vnt, 10, @varname(x))
VarNamedTuple
└─ x =&gt; 10

julia&gt; NamedTuple(vnt)
(x = 10,)

julia&gt; vnt2 = setindex!!(vnt, 20, @varname(y.a))
VarNamedTuple
├─ x =&gt; 10
└─ y =&gt; VarNamedTuple
        └─ a =&gt; 20

julia&gt; NamedTuple(vnt2)
ERROR: ArgumentError: Cannot convert VarNamedTuple containing non-identity VarNames to NamedTuple. To create a NamedTuple, all keys in the VarNamedTuple must be top-level symbols.
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varnamedtuple.jl#L143-L173">source</a></section></details></article><h3 id="Accumulators"><a class="docs-heading-anchor" href="#Accumulators">Accumulators</a><a id="Accumulators-1"></a><a class="docs-heading-anchor-permalink" href="#Accumulators" title="Permalink"></a></h3><p>The subtypes of <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a> store the cumulative log prior and log likelihood, and sometimes other variables that change during executing, in what are called accumulators.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractAccumulator"><a class="docstring-binding" href="#DynamicPPL.AbstractAccumulator"><code>DynamicPPL.AbstractAccumulator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractAccumulator</code></pre><p>An abstract type for accumulators.</p><p>An accumulator is an object that may change its value at every <code>tilde_assume!!</code> or <code>tilde_observe!!</code> call based on the random variable in question. The obvious examples of accumulators are the log prior and log likelihood. Other examples might be a variable that counts the number of observations in a trace, or a list of the names of random variables seen so far.</p><p>An accumulator type <code>T &lt;: AbstractAccumulator</code> must implement the following methods:</p><ul><li><code>accumulator_name(acc::T)</code> or <code>accumulator_name(::Type{T})</code></li><li><code>accumulate_observe!!(acc::T, dist, val, vn, template)</code></li><li><code>accumulate_assume!!(acc::T, val, tval, logjac, vn, dist, template)</code></li><li><code>reset(acc::T)</code></li><li><code>Base.copy(acc::T)</code></li></ul><p>In these functions:</p><ul><li><code>val</code> is the new value of the random variable sampled from a distribution (always in the original unlinked space), or the value on the left-hand side of an observe statement.</li><li><code>tval</code> is the original <code>AbstractTransformedValue</code> that was obtained from the initialisation strategy. This is passed through unchanged to <code>accumulate_assume!!</code> since it can be reused for some accumulators (e.g. when storing linked values, if the linked value was already provided, it is faster to reuse it than to re-link <code>val</code>).</li><li><code>dist</code> is the distribution on the RHS of the tilde statement.</li><li><code>vn</code> is the <code>VarName</code> that is on the left-hand side of the tilde-statement. If the tilde-statement is a literal observation like <code>0.0 ~ Normal()</code>, then <code>vn</code> is <code>nothing</code>.</li><li><code>logjac</code> is the log determinant of the Jacobian of the link transformation, <em>if</em> the variable is stored as a linked value in the VarInfo. If the variable is stored in its original, unlinked form, then <code>logjac</code> is zero.</li><li><code>template</code> is a value that conveys the shape of the top-level symbol in <code>vn</code>, and is used specifically for accumulators that carry VarNamedTuples.</li></ul><p>To be able to work with multi-threading, it should also implement:</p><ul><li><code>split(acc::T)</code></li><li><code>combine(acc::T, acc2::T)</code></li></ul><p>See the documentation for each of these functions for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators.jl#L1-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.accumulate_assume!!"><a class="docstring-binding" href="#DynamicPPL.accumulate_assume!!"><code>DynamicPPL.accumulate_assume!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">accumulate_assume!!(acc::AbstractAccumulator, val, tval, logjac, vn, right, template)</code></pre><p>Update <code>acc</code> in a <code>tilde_assume!!</code> call. Returns the updated <code>acc</code>.</p><p>See <a href="#DynamicPPL.AbstractAccumulator"><code>AbstractAccumulator</code></a> for the meaning of the arguments.</p><p><code>accumulate_assume!!</code> may mutate <code>acc</code>, but not any of the other arguments.</p><p>See also: <a href="#DynamicPPL.accumulate_observe!!"><code>accumulate_observe!!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators.jl#L68-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.accumulate_observe!!"><a class="docstring-binding" href="#DynamicPPL.accumulate_observe!!"><code>DynamicPPL.accumulate_observe!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">accumulate_observe!!(acc::AbstractAccumulator, right, left, vn, template)</code></pre><p>Update <code>acc</code> in a <code>tilde_observe!!</code> call. Returns the updated <code>acc</code>.</p><p>See <a href="#DynamicPPL.AbstractAccumulator"><code>AbstractAccumulator</code></a> for the meaning of the arguments.</p><p><code>accumulate_observe!!</code> may mutate <code>acc</code>, but not any of the other arguments.</p><p>See also: <a href="#DynamicPPL.accumulate_assume!!"><code>accumulate_assume!!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators.jl#L55-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.accumulator_name"><a class="docstring-binding" href="#DynamicPPL.accumulator_name"><code>DynamicPPL.accumulator_name</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">accumulator_name(acc::AbstractAccumulator)</code></pre><p>Return a Symbol which can be used as a name for <code>acc</code>.</p><p>The name has to be unique in the sense that a <code>VarInfo</code> can only have one accumulator for each name. The most typical case, and the default implementation, is that the name only depends on the type of <code>acc</code>, not on its value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators.jl#L44-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.reset"><a class="docstring-binding" href="#DynamicPPL.reset"><code>DynamicPPL.reset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reset(acc::AbstractAccumulator)</code></pre><p>Return a new accumulator like <code>acc</code>, but with its contents reset to the state that they should be at the beginning of model evaluation.</p><p>Note that this may in general have very similar behaviour to <a href="#DynamicPPL.split"><code>split</code></a>, and may share the same implementation, but the difference is that <code>split</code> may in principle happen at any stage during model evaluation, whereas <code>reset</code> is only called at the beginning of model evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators.jl#L81-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.split"><a class="docstring-binding" href="#DynamicPPL.split"><code>DynamicPPL.split</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">split(acc::AbstractAccumulator)</code></pre><p>Return a new accumulator like <code>acc</code> suitable for use in a forked thread.</p><p>The returned value should be such that <code>combine(acc, split(acc))</code> is equal to <code>acc</code>. This is used in the context of multi-threading where different threads may accumulate independently and the results are then combined.</p><p>Note that this may in general have very similar behaviour to <a href="#DynamicPPL.reset"><code>reset</code></a>, but is semantically different. See <a href="#DynamicPPL.reset"><code>reset</code></a> for more details.</p><p>See also: <a href="#DynamicPPL.combine"><code>combine</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators.jl#L101-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.combine"><a class="docstring-binding" href="#DynamicPPL.combine"><code>DynamicPPL.combine</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">combine(acc::AbstractAccumulator, acc2::AbstractAccumulator)</code></pre><p>Combine two accumulators which have the same type (but may, in general, have different type parameters). Returns a new accumulator of the same type.</p><p>See also: <a href="#DynamicPPL.split"><code>split</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators.jl#L117-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VNTAccumulator"><a class="docstring-binding" href="#DynamicPPL.VNTAccumulator"><code>DynamicPPL.VNTAccumulator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VNTAccumulator{AccName}(f::F, values::VarNamedTuple=VarNamedTuple()) where {AccName,F}</code></pre><p>A generic accumulator that applies a function <code>f</code> to values seen during model execution and stores the results in a <code>VarNamedTuple</code>.</p><p><code>AccName</code> is the name of the accumulator, and is exposed to allow users to define and use multiple forms of <code>VNTAccumulator</code> within the same set of accumulators. In theory, each <code>VNTAccumulator</code> with the same function <code>f</code> should use the same accumulator name. This is not enforced.</p><p>The function <code>f</code> should have the signature:</p><pre><code class="language-julia hljs">f(val, tval, logjac, vn, dist) -&gt; value_to_store</code></pre><p>where <code>val</code>, <code>tval</code>, <code>logjac</code>, <code>vn</code>, and <code>dist</code> have their usual meanings in accumulate_assume!! (see its docstring for more details). If a value does not need to be accumulated, this can be signalled by returning <code>DoNotAccumulate()</code> from <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators/vnt.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.DoNotAccumulate"><a class="docstring-binding" href="#DynamicPPL.DoNotAccumulate"><code>DynamicPPL.DoNotAccumulate</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DoNotAccumulate()</code></pre><p>Sentinel value indicating that no accumulation should be performed for a given variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators/vnt.jl#L30-L34">source</a></section></details></article><p>To manipulate the accumulators in a <code>VarInfo</code>, one can use:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.getacc"><a class="docstring-binding" href="#DynamicPPL.getacc"><code>DynamicPPL.getacc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getacc(at::AccumulatorTuple, ::Val{accname})</code></pre><p>Get the accumulator with name <code>accname</code> from <code>at</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators.jl#L223-L227">source</a></section><section><div><pre><code class="language-julia hljs">getacc(vi::AbstractVarInfo, ::Val{accname})</code></pre><p>Return the <code>AbstractAccumulator</code> of <code>vi</code> with name <code>accname</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L300-L304">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setacc!!"><a class="docstring-binding" href="#DynamicPPL.setacc!!"><code>DynamicPPL.setacc!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setacc!!(at::AccumulatorTuple, acc::AbstractAccumulator)</code></pre><p>Add <code>acc</code> to <code>at</code>. Returns a new <code>AccumulatorTuple</code>.</p><p>If an <code>AbstractAccumulator</code> with the same <code>accumulator_name</code> already exists in <code>at</code> it is replaced. <code>at</code> will never be mutated, but the name has the <code>!!</code> for consistency with the corresponding function for <code>AbstractVarInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators.jl#L208-L216">source</a></section><section><div><pre><code class="language-julia hljs">setacc!!(vi::AbstractVarInfo, acc::AbstractAccumulator)</code></pre><p>Add <code>acc</code> to the <code>AccumulatorTuple</code> of <code>vi</code>, mutating if it makes sense.</p><p>If an accumulator with the same <a href="#DynamicPPL.accumulator_name"><code>accumulator_name</code></a> already exists, it will be replaced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L208-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setaccs!!"><a class="docstring-binding" href="#DynamicPPL.setaccs!!"><code>DynamicPPL.setaccs!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setaccs!!(vi::AbstractVarInfo, accs::AccumulatorTuple)
setaccs!!(vi::AbstractVarInfo, accs::NTuple{N,AbstractAccumulator} where {N})</code></pre><p>Update the <code>AccumulatorTuple</code> of <code>vi</code> to <code>accs</code>, mutating if it makes sense.</p><p><code>setaccs!!(vi:AbstractVarInfo, accs::AccumulatorTuple) should be implemented by each subtype of</code>AbstractVarInfo`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L113-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.deleteacc!!"><a class="docstring-binding" href="#DynamicPPL.deleteacc!!"><code>DynamicPPL.deleteacc!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">deleteacc!!(at::AccumulatorTuple, ::Val{accname})</code></pre><p>Delete the accumulator with name <code>accname</code> from <code>at</code>. Returns a new <code>AccumulatorTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/accumulators.jl#L232-L236">source</a></section></details></article><h3 id="Common-API"><a class="docs-heading-anchor" href="#Common-API">Common API</a><a id="Common-API-1"></a><a class="docs-heading-anchor-permalink" href="#Common-API" title="Permalink"></a></h3><h4 id="Accumulation-of-log-probabilities"><a class="docs-heading-anchor" href="#Accumulation-of-log-probabilities">Accumulation of log-probabilities</a><a id="Accumulation-of-log-probabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Accumulation-of-log-probabilities" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogp"><a class="docstring-binding" href="#DynamicPPL.getlogp"><code>DynamicPPL.getlogp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogp(vi::AbstractVarInfo)</code></pre><p>Return a NamedTuple of the log prior, log Jacobian, and log likelihood probabilities.</p><p>The keys are called <code>logprior</code>, <code>logjac</code>, and <code>loglikelihood</code>. If any of them are not present in <code>vi</code> an error will be thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L99-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setlogp!!"><a class="docstring-binding" href="#DynamicPPL.setlogp!!"><code>DynamicPPL.setlogp!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setlogp!!(vi::AbstractVarInfo, logp::NamedTuple)</code></pre><p>Set both the log prior and the log likelihood probabilities in <code>vi</code>.</p><p><code>logp</code> should have fields <code>logprior</code> and <code>loglikelihood</code> and no other fields.</p><p>See also: <a href="#DynamicPPL.setlogprior!!"><code>setlogprior!!</code></a>, <a href="#DynamicPPL.setloglikelihood!!"><code>setloglikelihood!!</code></a>, <a href="#DynamicPPL.getlogp"><code>getlogp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L272-L280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.acclogp!!"><a class="docstring-binding" href="#DynamicPPL.acclogp!!"><code>DynamicPPL.acclogp!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">acclogp!!(vi::AbstractVarInfo, logp::NamedTuple; ignore_missing_accumulator::Bool=false)</code></pre><p>Add to both the log prior and the log likelihood probabilities in <code>vi</code>.</p><p><code>logp</code> should have fields <code>logprior</code> and/or <code>loglikelihood</code>, and no other fields.</p><p>By default if the necessary accumulators are not in <code>vi</code> an error is thrown. If <code>ignore_missing_accumulator</code> is set to <code>true</code> then this is silently ignored instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L434-L443">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogjoint"><a class="docstring-binding" href="#DynamicPPL.getlogjoint"><code>DynamicPPL.getlogjoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogjoint(vi::AbstractVarInfo)</code></pre><p>Return the log of the joint probability of the observed data and parameters in <code>vi</code>.</p><p>See also: <a href="#DynamicPPL.getlogprior"><code>getlogprior</code></a>, <a href="#DynamicPPL.getloglikelihood"><code>getloglikelihood</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L74-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogjoint_internal"><a class="docstring-binding" href="#DynamicPPL.getlogjoint_internal"><code>DynamicPPL.getlogjoint_internal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogjoint_internal(vi::AbstractVarInfo)</code></pre><p>Return the log of the joint probability of the observed data and parameters as they are stored internally in <code>vi</code>, including the log-Jacobian for any linked parameters.</p><p>In general, we have that:</p><pre><code class="language-julia hljs">getlogjoint_internal(vi) == getlogjoint(vi) - getlogjac(vi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L83-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogjac"><a class="docstring-binding" href="#DynamicPPL.getlogjac"><code>DynamicPPL.getlogjac</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogjac(vi::AbstractVarInfo)</code></pre><p>Return the accumulated log-Jacobian term for any linked parameters in <code>vi</code>. The Jacobian here is taken with respect to the forward (link) transform.</p><p>See also: <a href="#DynamicPPL.setlogjac!!"><code>setlogjac!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L189-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setlogjac!!"><a class="docstring-binding" href="#DynamicPPL.setlogjac!!"><code>DynamicPPL.setlogjac!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setlogjac!!(vi::AbstractVarInfo, logjac)</code></pre><p>Set the accumulated log-Jacobian term for any linked parameters in <code>vi</code>. The Jacobian here is taken with respect to the forward (link) transform.</p><p>See also: <a href="#DynamicPPL.getlogjac"><code>getlogjac</code></a>, <a href="#DynamicPPL.acclogjac!!"><code>acclogjac!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L229-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.acclogjac!!"><a class="docstring-binding" href="#DynamicPPL.acclogjac!!"><code>DynamicPPL.acclogjac!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">acclogjac!!(vi::AbstractVarInfo, logjac; ignore_missing_accumulator::Bool=false)</code></pre><p>Add <code>logjac</code> to the value of the log Jacobian in <code>vi</code>.</p><p>Errors if <code>vi</code> does not have a <code>LogJacobianAccumulator</code>, unless <code>ignore_missing_accumulator</code> is set to <code>true</code>, in which case this is silently ignored instead.</p><p>See also: <a href="#DynamicPPL.getlogjac"><code>getlogjac</code></a>, <a href="#DynamicPPL.setlogjac!!"><code>setlogjac!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L395-L404">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogprior"><a class="docstring-binding" href="#DynamicPPL.getlogprior"><code>DynamicPPL.getlogprior</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogprior(vi::AbstractVarInfo)</code></pre><p>Return the log of the prior probability of the parameters in <code>vi</code>.</p><p>See also: <a href="#DynamicPPL.getlogjoint"><code>getlogjoint</code></a>, <a href="#DynamicPPL.getloglikelihood"><code>getloglikelihood</code></a>, <a href="#DynamicPPL.setlogprior!!"><code>setlogprior!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L166-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogprior_internal"><a class="docstring-binding" href="#DynamicPPL.getlogprior_internal"><code>DynamicPPL.getlogprior_internal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogprior_internal(vi::AbstractVarInfo)</code></pre><p>Return the log of the prior probability of the parameters as stored internally in <code>vi</code>. This includes the log-Jacobian for any linked parameters.</p><p>In general, we have that:</p><pre><code class="language-julia hljs">getlogprior_internal(vi) == getlogprior(vi) - getlogjac(vi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L175-L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setlogprior!!"><a class="docstring-binding" href="#DynamicPPL.setlogprior!!"><code>DynamicPPL.setlogprior!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setlogprior!!(vi::AbstractVarInfo, logp)</code></pre><p>Set the log of the prior probability of the parameters sampled in <code>vi</code> to <code>logp</code>.</p><p>See also: <a href="#DynamicPPL.setloglikelihood!!"><code>setloglikelihood!!</code></a>, <a href="#DynamicPPL.setlogp!!"><code>setlogp!!</code></a>, <a href="#DynamicPPL.getlogprior"><code>getlogprior</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L220-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.acclogprior!!"><a class="docstring-binding" href="#DynamicPPL.acclogprior!!"><code>DynamicPPL.acclogprior!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">acclogprior!!(vi::AbstractVarInfo, logp)</code></pre><p>Add <code>logp</code> to the value of the log of the prior probability in <code>vi</code>.</p><p>Errors if <code>vi</code> does not have a <code>LogPriorAccumulator</code>, unless <code>ignore_missing_accumulator</code> is set to <code>true</code>, in which case this is silently ignored instead.</p><p>See also: <a href="#DynamicPPL.accloglikelihood!!"><code>accloglikelihood!!</code></a>, <a href="#DynamicPPL.acclogp!!"><code>acclogp!!</code></a>, <a href="#DynamicPPL.getlogprior"><code>getlogprior</code></a>, <a href="#DynamicPPL.setlogprior!!"><code>setlogprior!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L376-L385">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getloglikelihood"><a class="docstring-binding" href="#DynamicPPL.getloglikelihood"><code>DynamicPPL.getloglikelihood</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getloglikelihood(vi::AbstractVarInfo)</code></pre><p>Return the log of the likelihood probability of the observed data in <code>vi</code>.</p><p>See also: <a href="#DynamicPPL.getlogjoint"><code>getlogjoint</code></a>, <a href="#DynamicPPL.getlogprior"><code>getlogprior</code></a>, <a href="#DynamicPPL.setloglikelihood!!"><code>setloglikelihood!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L199-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setloglikelihood!!"><a class="docstring-binding" href="#DynamicPPL.setloglikelihood!!"><code>DynamicPPL.setloglikelihood!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setloglikelihood!!(vi::AbstractVarInfo, logp)</code></pre><p>Set the log of the likelihood probability of the observed data sampled in <code>vi</code> to <code>logp</code>.</p><p>See also: <a href="#DynamicPPL.setlogprior!!"><code>setlogprior!!</code></a>, <a href="#DynamicPPL.setlogp!!"><code>setlogp!!</code></a>, <a href="#DynamicPPL.getloglikelihood"><code>getloglikelihood</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L239-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.accloglikelihood!!"><a class="docstring-binding" href="#DynamicPPL.accloglikelihood!!"><code>DynamicPPL.accloglikelihood!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">accloglikelihood!!(vi::AbstractVarInfo, logp)</code></pre><p>Add <code>logp</code> to the value of the log of the likelihood in <code>vi</code>.</p><p>Errors if <code>vi</code> does not have a <code>LogLikelihoodAccumulator</code>, unless <code>ignore_missing_accumulator</code> is set to <code>true</code>, in which case this is silently ignored instead.</p><p>See also: <a href="#DynamicPPL.accloglikelihood!!"><code>accloglikelihood!!</code></a>, <a href="#DynamicPPL.acclogp!!"><code>acclogp!!</code></a>, <a href="#DynamicPPL.getloglikelihood"><code>getloglikelihood</code></a>, <a href="#DynamicPPL.setloglikelihood!!"><code>setloglikelihood!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L414-L424">source</a></section></details></article><h4 id="Variables-and-their-realizations"><a class="docs-heading-anchor" href="#Variables-and-their-realizations">Variables and their realizations</a><a id="Variables-and-their-realizations-1"></a><a class="docs-heading-anchor-permalink" href="#Variables-and-their-realizations" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="Base.keys"><a class="docstring-binding" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">keys(vi::AbstractVarInfo)</code></pre><p>Return an iterator over all <code>vns</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L465-L469">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex"><a class="docstring-binding" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getindex(vi::AbstractVarInfo, vn::VarName[, dist::Distribution])
getindex(vi::AbstractVarInfo, vns::Vector{&lt;:VarName}[, dist::Distribution])</code></pre><p>Return the current value(s) of <code>vn</code> (<code>vns</code>) in <code>vi</code> in the support of its (their) distribution(s).</p><p>If <code>dist</code> is specified, the value(s) will be massaged into the representation expected by <code>dist</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L471-L479">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BangBang.empty!!"><a class="docstring-binding" href="#BangBang.empty!!"><code>BangBang.empty!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">empty!!(vi::AbstractVarInfo)</code></pre><p>Empty <code>vi</code> of variables and reset all accumulators.</p><p>This is useful when using a sampling algorithm that assumes an empty <code>vi</code>, e.g. <code>SMC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L529-L535">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isempty"><a class="docstring-binding" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isempty(vi::AbstractVarInfo)</code></pre><p>Return true if <code>vi</code> is empty and false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L537-L541">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getindex_internal"><a class="docstring-binding" href="#DynamicPPL.getindex_internal"><code>DynamicPPL.getindex_internal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getindex_internal(vi::AbstractVarInfo, vn::VarName)
getindex_internal(vi::AbstractVarInfo, vns::Vector{&lt;:VarName})
getindex_internal(vi::AbstractVarInfo, ::Colon)</code></pre><p>Return the internal value of the varname <code>vn</code>, varnames <code>vns</code>, or all varnames in <code>vi</code> respectively. The internal value is the value of the variables that is stored in the varinfo object; this may be the actual realisation of the random variable (i.e. the value sampled from the distribution), or it may have been transformed to Euclidean space, depending on whether the varinfo was linked.</p><p>See https://turinglang.org/docs/developers/transforms/dynamicppl/ for more information on how transformed variables are stored in DynamicPPL.</p><p>See also: <a href="#Base.getindex"><code>getindex(vi::AbstractVarInfo, vn::VarName, dist::Distribution)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L500-L515">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setindex_internal!!"><a class="docstring-binding" href="#DynamicPPL.setindex_internal!!"><code>DynamicPPL.setindex_internal!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setindex_internal!!(vi::VarInfo, val, vn::VarName)</code></pre><p>Set the internal (vectorised) value of variable <code>vn</code> in <code>vi</code> to <code>val</code>.</p><p>This does not change the transformation or linked status of the variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varinfo.jl#L219-L225">source</a></section></details></article><h4 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractTransformation"><a class="docstring-binding" href="#DynamicPPL.AbstractTransformation"><code>DynamicPPL.AbstractTransformation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractTransformation</code></pre><p>Represents a transformation to be used in <code>link!!</code> and <code>invlink!!</code>, amongst others.</p><p>A concrete implementation of this should implement the following methods:</p><ul><li><a href="#DynamicPPL.link!!"><code>link!!</code></a>: transforms the <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a> to the unconstrained space.</li><li><a href="#DynamicPPL.invlink!!"><code>invlink!!</code></a>: transforms the <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a> to the constrained space.</li></ul><p>See also: <a href="#DynamicPPL.link!!"><code>link!!</code></a>, <a href="#DynamicPPL.invlink!!"><code>invlink!!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L2-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.NoTransformation"><a class="docstring-binding" href="#DynamicPPL.NoTransformation"><code>DynamicPPL.NoTransformation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NoTransformation &lt;: DynamicPPL.AbstractTransformation</code></pre><p>Transformation which applies the identity function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L15-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.DynamicTransformation"><a class="docstring-binding" href="#DynamicPPL.DynamicTransformation"><code>DynamicPPL.DynamicTransformation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DynamicTransformation &lt;: DynamicPPL.AbstractTransformation</code></pre><p>Transformation which transforms the variables on a per-need-basis in the execution of a given <code>Model</code>.</p><p>This is in constrast to <code>StaticTransformation</code> which transforms all variables <em>before</em> the execution of a given <code>Model</code>.</p><p>Different VarInfo types should implement their own methods for <code>link!!</code> and <code>invlink!!</code> for <code>DynamicTransformation</code>.</p><p>See also: <a href="#DynamicPPL.StaticTransformation"><code>StaticTransformation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L22-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.StaticTransformation"><a class="docstring-binding" href="#DynamicPPL.StaticTransformation"><code>DynamicPPL.StaticTransformation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct StaticTransformation{F} &lt;: DynamicPPL.AbstractTransformation</code></pre><p>Transformation which represents a fixed bijector to be applied to the variables, as opposed to deriving the bijector again at runtime.</p><p>See also: <a href="#DynamicPPL.DynamicTransformation"><code>DynamicTransformation</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>bijector::Any</code>: The function, assumed to implement the <code>Bijectors</code> interface, to be applied to the variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L38-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bijectors.link"><a class="docstring-binding" href="#Bijectors.link"><code>Bijectors.link</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">link([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)
link([t::AbstractTransformation, ]vi::AbstractVarInfo, vns::NTuple{N,VarName}, model::Model)</code></pre><p>Transform variables in <code>vi</code> to their linked space without mutating <code>vi</code>.</p><p>Either transform all variables, or only ones specified in <code>vns</code>.</p><p>Use the  transformation <code>t</code>, or <code>default_transformation(model, vi)</code> if one is not provided.</p><p>See also: <a href="#DynamicPPL.default_transformation"><code>default_transformation</code></a>, <a href="#Bijectors.invlink"><code>invlink</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L760-L771">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bijectors.invlink"><a class="docstring-binding" href="#Bijectors.invlink"><code>Bijectors.invlink</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">invlink([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)
invlink([t::AbstractTransformation, ]vi::AbstractVarInfo, vns::NTuple{N,VarName}, model::Model)</code></pre><p>Transform variables in <code>vi</code> to their constrained space without mutating <code>vi</code>.</p><p>Either transform all variables, or only ones specified in <code>vns</code>.</p><p>Use the (inverse of) transformation <code>t</code>, or <code>default_transformation(model, vi)</code> if one is not provided.</p><p>See also: <a href="#DynamicPPL.default_transformation"><code>default_transformation</code></a>, <a href="#Bijectors.link"><code>link</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L802-L814">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.link!!"><a class="docstring-binding" href="#DynamicPPL.link!!"><code>DynamicPPL.link!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">link!!([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)
link!!([t::AbstractTransformation, ]vi::AbstractVarInfo, vns::NTuple{N,VarName}, model::Model)</code></pre><p>Transform variables in <code>vi</code> to their linked space, mutating <code>vi</code> if possible.</p><p>Either transform all variables, or only ones specified in <code>vns</code>.</p><p>Use the  transformation <code>t</code>, or <code>default_transformation(model, vi)</code> if one is not provided.</p><p>See also: <a href="#DynamicPPL.default_transformation"><code>default_transformation</code></a>, <a href="#DynamicPPL.invlink!!"><code>invlink!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L741-L752">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.invlink!!"><a class="docstring-binding" href="#DynamicPPL.invlink!!"><code>DynamicPPL.invlink!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">invlink!!([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)
invlink!!([t::AbstractTransformation, ]vi::AbstractVarInfo, vns::NTuple{N,VarName}, model::Model)</code></pre><p>Transform variables in <code>vi</code> to their constrained space, mutating <code>vi</code> if possible.</p><p>Either transform all variables, or only ones specified in <code>vns</code>.</p><p>Use the (inverse of) transformation <code>t</code>, or <code>default_transformation(model, vi)</code> if one is not provided.</p><p>See also: <a href="#DynamicPPL.default_transformation"><code>default_transformation</code></a>, <a href="#DynamicPPL.link!!"><code>link!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L782-L794">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.update_link_status!!"><a class="docstring-binding" href="#DynamicPPL.update_link_status!!"><code>DynamicPPL.update_link_status!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.update_link_status!!(
    orig_vi::VarInfo, transform_strategy::AbstractTransformStrategy, model::Model
)</code></pre><p>Given an original <code>VarInfo</code> <code>orig_vi</code>, update the link status of its variables according to the new <code>transform_strategy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/varinfo.jl#L425-L432">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractTransformStrategy"><a class="docstring-binding" href="#DynamicPPL.AbstractTransformStrategy"><code>DynamicPPL.AbstractTransformStrategy</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractTransformStrategy end</code></pre><p>An abstract type for strategies that determine how each variable should be transformed.</p><p>For subtypes of <code>AbstractTransformStrategy</code>, the only method that needs to be overloaded is <a href="#DynamicPPL.target_transform"><code>DynamicPPL.target_transform(::AbstractTransformStrategy, vn::VarName)</code></a>, which returns an <a href="#DynamicPPL.AbstractTransform"><code>AbstractTransform</code></a> that specifies how the variable with name <code>vn</code> should be transformed.</p><p>The transform strategy dictates how the log-Jacobian is accumulated during model evaluation. Regardless of what initialisation strategy is used (and what kind of transformed value <code>init()</code> returns, the log-Jacobian that is accumulated is always the log-Jacobian for the forward transform specified by <code>target_transform(strategy, vn)</code>.</p><p>That is, even if <code>init()</code> returns an <code>UntransformedValue</code>, if the transform strategy is <code>LinkAll()</code> (which returns <code>DynamicLink</code> for all variables), then the log-Jacobian for linking will be accumulated during model evaluation.</p><p>Subtypes in DynamicPPL are <a href="#DynamicPPL.LinkAll"><code>LinkAll</code></a>, <a href="#DynamicPPL.UnlinkAll"><code>UnlinkAll</code></a>, <a href="#DynamicPPL.LinkSome"><code>LinkSome</code></a>, and <a href="#DynamicPPL.UnlinkSome"><code>UnlinkSome</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L208-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.LinkAll"><a class="docstring-binding" href="#DynamicPPL.LinkAll"><code>DynamicPPL.LinkAll</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinkAll() &lt;: AbstractTransformStrategy</code></pre><p>Indicate that all variables should be linked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L243-L247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.UnlinkAll"><a class="docstring-binding" href="#DynamicPPL.UnlinkAll"><code>DynamicPPL.UnlinkAll</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnlinkAll() &lt;: AbstractTransformStrategy</code></pre><p>Indicate that all variables should be unlinked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L251-L255">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.LinkSome"><a class="docstring-binding" href="#DynamicPPL.LinkSome"><code>DynamicPPL.LinkSome</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinkSome(vns::Set{&lt;:VarName}, fallback) &lt;: AbstractTransformStrategy</code></pre><p>Indicate that the variables in <code>vns</code> must be linked. The link statuses of other variables are determined by the <code>fallback</code> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L259-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.UnlinkSome"><a class="docstring-binding" href="#DynamicPPL.UnlinkSome"><code>DynamicPPL.UnlinkSome</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnlinkSome(vns::Set{&lt;:VarName}, fallback) &lt;: AbstractTransformStrategy</code></pre><p>Indicate that the variables in <code>vns</code> must not be linked. The link statuses of other variables are determined by the <code>fallback</code> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L284-L289">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractTransform"><a class="docstring-binding" href="#DynamicPPL.AbstractTransform"><code>DynamicPPL.AbstractTransform</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractTransform end</code></pre><p>An abstract type to represent the intended transformation for a variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L186-L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.DynamicLink"><a class="docstring-binding" href="#DynamicPPL.DynamicLink"><code>DynamicPPL.DynamicLink</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DynamicLink &lt;: AbstractTransform</code></pre><p>A type indicating that a target transformation should be derived by recomputing the invlink transform from the distribution on the right-hand side of the tilde.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L193-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.Unlink"><a class="docstring-binding" href="#DynamicPPL.Unlink"><code>DynamicPPL.Unlink</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Unlink &lt;: AbstractTransform</code></pre><p>A type indicating that the target transformation should be nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L201-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.target_transform"><a class="docstring-binding" href="#DynamicPPL.target_transform"><code>DynamicPPL.target_transform</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">target_transform(linker::AbstractTransformStrategy, vn::VarName)</code></pre><p>Determine whether a variable with name <code>vn</code> should be linked according to the <code>linker</code> strategy. Returns <code>DynamicLink()</code> if the variable should be linked, or <code>Unlink()</code> if it should not.</p><p>This function can in the future be extended to support fixed transformations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L232-L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.apply_transform_strategy"><a class="docstring-binding" href="#DynamicPPL.apply_transform_strategy"><code>DynamicPPL.apply_transform_strategy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.apply_transform_strategy(
    strategy::AbstractTransformStrategy,
    tv::AbstractTransformedValue,
    vn::VarName,
    dist::Distribution,
)</code></pre><p>Apply the given <code>strategy</code> to the transformed value <code>tv</code> for a tilde-statement <code>vn ~ dist</code>.</p><p>Specifically, this function does a number of things:</p><ul><li><p>Calculates the raw value associated with <code>tv</code>.</p></li><li><p>Checks whether the <code>strategy</code> expects the VarName <code>vn</code> to be linked or unlinked. If the current link status of <code>tv</code> matches the expected link status, <code>tv</code> is returned unchanged. Otherwise, either linking or unlinking is applied as necessary. Note that this function does not perform vectorisation unless it is needed.</p><p>A table summarising the possible transformations is as follows:</p><table><tr><th style="text-align: right">tv isa ...</th><th style="text-align: right"><code>target_transform(...) isa DynamicLink</code></th><th style="text-align: right"><code>target_transform(...) isa Unlink</code></th></tr><tr><td style="text-align: right"><code>LinkedVectorValue</code></td><td style="text-align: right">-&gt; <code>LinkedVectorValue</code></td><td style="text-align: right">-&gt; <code>UntransformedValue</code></td></tr><tr><td style="text-align: right"><code>VectorValue</code></td><td style="text-align: right">-&gt; <code>LinkedVectorValue</code></td><td style="text-align: right">-&gt; <code>VectorValue</code></td></tr><tr><td style="text-align: right"><code>UntransformedValue</code></td><td style="text-align: right">-&gt; <code>LinkedVectorValue</code></td><td style="text-align: right">-&gt; <code>UntransformedValue</code></td></tr></table></li><li><p>If <code>vn</code> is supposed to be linked, calculates the associated log-Jacobian adjustment for the <strong>forward</strong> linking transformation (i.e., from unlinked to linked).</p></li></ul><p>This function returns a tuple of <code>(raw_value, new_tv, logjac)</code>.</p><div class="admonition is-info" id="Note-741d7147fe802adf"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-741d7147fe802adf" title="Permalink"></a></header><div class="admonition-body"><p>This function is therefore the single source of truth for whether <code>logjac</code> should be incremented during model evaluation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L311-L346">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.transformation"><a class="docstring-binding" href="#DynamicPPL.transformation"><code>DynamicPPL.transformation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transformation(vi::AbstractVarInfo)</code></pre><p>Return the <code>AbstractTransformation</code> related to <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L66-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.default_transformation"><a class="docstring-binding" href="#DynamicPPL.default_transformation"><code>DynamicPPL.default_transformation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_transformation(model::Model[, vi::AbstractVarInfo])</code></pre><p>Return the <code>AbstractTransformation</code> currently related to <code>model</code> and, potentially, <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L58-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.link_transform"><a class="docstring-binding" href="#DynamicPPL.link_transform"><code>DynamicPPL.link_transform</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">link_transform(dist)</code></pre><p>Return the constrained-to-unconstrained bijector for distribution <code>dist</code>.</p><p>By default, this is just <code>Bijectors.bijector(dist)</code>.</p><div class="admonition is-warning" id="Warning-b0fadc157c223fc0"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-b0fadc157c223fc0" title="Permalink"></a></header><div class="admonition-body"><p>Note that currently this is not used by <code>Bijectors.logpdf_with_trans</code>, hence that needs to be overloaded separately if the intention is to change behavior of an existing distribution.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/utils.jl#L230-L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.invlink_transform"><a class="docstring-binding" href="#DynamicPPL.invlink_transform"><code>DynamicPPL.invlink_transform</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">invlink_transform(dist)</code></pre><p>Return the unconstrained-to-constrained bijector for distribution <code>dist</code>.</p><p>By default, this is just <code>inverse(link_transform(dist))</code>.</p><div class="admonition is-warning" id="Warning-b0fadc157c223fc0"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-b0fadc157c223fc0" title="Permalink"></a></header><div class="admonition-body"><p>Note that currently this is not used by <code>Bijectors.logpdf_with_trans</code>, hence that needs to be overloaded separately if the intention is to change behavior of an existing distribution.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/utils.jl#L244-L255">source</a></section></details></article><h4 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="Base.merge-Tuple{AbstractVarInfo}"><a class="docstring-binding" href="#Base.merge-Tuple{AbstractVarInfo}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">merge(varinfo, other_varinfos...)</code></pre><p>Merge varinfos into one, giving precedence to the right-most varinfo when sensible.</p><p>This is particularly useful when combined with <a href="#DynamicPPL.subset"><code>subset(varinfo, vns)</code></a>.</p><p>See docstring of <a href="#DynamicPPL.subset"><code>subset(varinfo, vns)</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L679-L687">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.subset"><a class="docstring-binding" href="#DynamicPPL.subset"><code>DynamicPPL.subset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">subset(varinfo::AbstractVarInfo, vns::AbstractVector{&lt;:VarName})</code></pre><p>Subset a <code>varinfo</code> to only contain the variables <code>vns</code>.</p><p>The ordering of variables in the return value will be the same as in <code>varinfo</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo()
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, sqrt(s))
           x = Vector{Float64}(undef, 2)
           x[1] ~ Normal(m, sqrt(s))
           x[2] ~ Normal(m, sqrt(s))
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; params = @vnt begin
           s := 1.0
           m := 2.0
           x := [3.0, 4.0]
       end
VarNamedTuple
├─ s =&gt; 1.0
├─ m =&gt; 2.0
└─ x =&gt; [3.0, 4.0]

julia&gt; vi = last(init!!(model, VarInfo(), InitFromParams(params), UnlinkAll()));

julia&gt; keys(vi)
4-element Vector{VarName}:
 s
 m
 x[1]
 x[2]

julia&gt; # Extract one with only `m`.
       vi_subset1 = subset(vi, [@varname(m),]);

julia&gt; keys(vi_subset1)
1-element Vector{VarName}:
 m

julia&gt; vi_subset1[@varname(m)]
2.0

julia&gt; # Extract one with both `s` and `x[2]`.
       vi_subset2 = subset(vi, [@varname(s), @varname(x[2])]);

julia&gt; keys(vi_subset2)
2-element Vector{VarName}:
 s
 x[2]

julia&gt; vi_subset2[[@varname(s), @varname(x[2])]]
2-element Vector{Float64}:
 1.0
 4.0</code></pre><p><code>subset</code> is particularly useful when combined with <a href="#Base.merge-Tuple{AbstractVarInfo}"><code>merge(vi::AbstractVarInfo)</code></a></p><pre><code class="language-julia-repl hljs">julia&gt; # Merge the two.
       vi_subset_merged = merge(vi_subset1, vi_subset2);

julia&gt; keys(vi_subset_merged)
3-element Vector{VarName}:
 m
 s
 x[2]

julia&gt; vi_subset_merged[[@varname(s), @varname(m), @varname(x[2])]]
3-element Vector{Float64}:
 1.0
 2.0
 4.0

julia&gt; # Merge the two with the original.
       vi_merged = merge(vi, vi_subset_merged);

julia&gt; keys(vi_merged)
4-element Vector{VarName}:
 s
 m
 x[1]
 x[2]

julia&gt; vi_merged[[@varname(s), @varname(m), @varname(x[1]), @varname(x[2])]]
4-element Vector{Float64}:
 1.0
 2.0
 3.0
 4.0</code></pre><p><strong>Notes</strong></p><p><strong>Type-stability</strong></p><div class="admonition is-warning" id="Warning-88664e9d57baa0ec"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-88664e9d57baa0ec" title="Permalink"></a></header><div class="admonition-body"><p>This function is only type-stable when <code>vns</code> contains only varnames with the same symbol. For example, <code>[@varname(m[1]), @varname(m[2])]</code> will be type-stable, but <code>[@varname(m[1]), @varname(x)]</code> will not be.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L569-L676">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.unflatten!!"><a class="docstring-binding" href="#DynamicPPL.unflatten!!"><code>DynamicPPL.unflatten!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unflatten!!(vi::AbstractVarInfo, x::AbstractVector)</code></pre><p>Return a new instance of <code>vi</code> where the internal values stored in <code>vi.values</code> have been overwritten with the values in <code>x</code>.</p><p>This is the inverse operation of <a href="#DynamicPPL.internal_values_as_vector"><code>internal_values_as_vector</code></a>.</p><div class="admonition is-warning" id="The-VarInfo-will-be-in-an-invalid-state-24fa98015f72e343"><header class="admonition-header">The VarInfo will be in an invalid state<a class="admonition-anchor" href="#The-VarInfo-will-be-in-an-invalid-state-24fa98015f72e343" title="Permalink"></a></header><div class="admonition-body"><p>Note that this does not re-evaluate the model (indeed it cannot!) so the contents of any accumulators in the <code>VarInfo</code> will almost certainly be inconsistent with the new values.</p><p>On top of that, it does not update the <em>transformations</em> stored inside the <code>LinkedVectorValue</code>s and <code>VectorValue</code>s. If these transformations themselves depend on the values of the variables, this can lead to incorrect results when trying to access untransformed values, e.g. using <code>getindex(vi, vn)</code>.</p><p><strong>Because of these issues, we strongly recommend against using this function, unless absolutely necessary.</strong> In many cases, usage of <code>unflatten!!(vi, x)</code> can be replaced with <code>InitFromVector(x, ldf::LogDensityFunction)</code>: please see the <a href="../ldf/models/#ldf-model">DynamicPPL documentation</a> for more information. If you are unsure how to adapt your code to avoid using <code>unflatten!!</code>, please open an issue.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L825-L847">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.internal_values_as_vector"><a class="docstring-binding" href="#DynamicPPL.internal_values_as_vector"><code>DynamicPPL.internal_values_as_vector</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">internal_values_as_vector(vi::AbstractVarInfo)</code></pre><p>Return all internal values stored in <code>vi.values</code> as a flattened <code>Vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/abstract_varinfo.jl#L493-L497">source</a></section></details></article><h3 id="Evaluation-Contexts"><a class="docs-heading-anchor" href="#Evaluation-Contexts">Evaluation Contexts</a><a id="Evaluation-Contexts-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Contexts" title="Permalink"></a></h3><p>Internally, model evaluation is performed with <a href="#AbstractPPL.evaluate!!"><code>AbstractPPL.evaluate!!</code></a>.</p><article><details class="docstring" open="true"><summary id="AbstractPPL.evaluate!!"><a class="docstring-binding" href="#AbstractPPL.evaluate!!"><code>AbstractPPL.evaluate!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">evaluate!!(model::Model, varinfo)</code></pre><p>Evaluate the <code>model</code> with the given <code>varinfo</code>, wrapping it in a <code>ThreadSafeVarInfo</code> if the model is marked as needing threadsafe evaluation.</p><div class="admonition is-warning" id="Warning-3842a9931cb55cb5"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-3842a9931cb55cb5" title="Permalink"></a></header><div class="admonition-body"><p>The semantics of this method are complicated. We <strong>strongly</strong> recommend that users do <em>not</em> use this method unless absolutely necessary. In the future this method will be deprecated and removed. As far as possible (and it should <strong>always</strong> be possible – please open an issue if you do not know how to adapt your code!) you should use the five-argument <code>init!!([rng,] model, ::OnlyAccsVarInfo, init_strategy, transform_strategy)</code> method, which has more explicit semantics and allows you to have more control over each part of the evaluation process.</p></div></div><p>The exact semantics depend on the <code>model</code>&#39;s context. Fundamentally, this method executes the model evaluation function (i.e., the function used to define the model) using the given <code>varinfo</code> as an argument. At each tilde-statement, <code>tilde_assume!!</code> or <code>tilde_observe!!</code> is called, whose behaviour depends on the model&#39;s context.</p><p>Broadly speaking, if the leaf context is an <code>InitContext</code>, then this function:</p><ul><li>uses the initialisation strategy inside the <code>InitContext</code>;</li><li>uses the transform strategy inside the <code>InitContext</code>;</li><li>uses the accumulators inside <code>varinfo</code> (resetting them before evaluation);</li><li>overwrites the values in <code>varinfo</code> with the new values obtained from the initialisation strategy.</li></ul><p>If the leaf context is a <code>DefaultContext</code>, then this function:</p><ul><li>uses the values inside the <code>varinfo</code> as the initialisation strategy;</li><li>derives a transform strategy from the <code>varinfo</code>&#39;s stored variables (if a linked variable is stored, then the transform strategy will treat that variable as linked; likewise for unlinked)</li><li>uses the accumulators inside <code>varinfo</code> (resetting them before evaluation);</li><li>does not overwrite the values in the <code>varinfo</code> (that is unnecessary since the values used for evaluation are already stored in <code>varinfo</code>).</li></ul><p>The long-term plan for this method is to:</p><ul><li>Replace <code>DefaultContext</code> with <code>InitContext</code> by splitting up the functionality of <code>DefaultContext</code> into its constituent components</li><li>Remove the <code>VarInfo</code> argument, and instead use only an <code>AccumulatorTuple</code></li><li>Separate the initialisation and transform strategies into separate arguments, instead of storing them inside the model&#39;s context.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L814-L858">source</a></section></details></article><p>This method mutates the <code>varinfo</code> used for execution. By default, it does not perform any actual sampling: it only evaluates the model using the values of the variables that are already in the <code>varinfo</code>. If you wish to sample new values, see the section on <a href="#VarInfo-initialisation">VarInfo initialisation</a> just below this.</p><p>The behaviour of a model execution can be changed with evaluation contexts, which are a field of the model.</p><p>All contexts are subtypes of <code>AbstractPPL.AbstractContext</code>.</p><p>Contexts are split into two kinds:</p><p><strong>Leaf contexts</strong>: These are the most important contexts as they ultimately decide how model evaluation proceeds. For example, <code>DefaultContext</code> evaluates the model using values stored inside a VarInfo&#39;s metadata, whereas <code>InitContext</code> obtains new values either by sampling or from a known set of parameters. DynamicPPL has more leaf contexts which are used for internal purposes, but these are the two that are exported.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.DefaultContext"><a class="docstring-binding" href="#DynamicPPL.DefaultContext"><code>DynamicPPL.DefaultContext</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DefaultContext &lt;: AbstractContext end</code></pre><p><code>DefaultContext</code>, as the name suggests, is the default context used when instantiating a model.</p><pre><code class="language-julia-repl hljs">julia&gt; @model f() = x ~ Normal();

julia&gt; model = f(); model.context
DefaultContext()</code></pre><p>As an evaluation context, the behaviour of <code>DefaultContext</code> is to require all variables to be present in the <code>AbstractVarInfo</code> used for evaluation. Thus, semantically, evaluating a model with <code>DefaultContext</code> means &#39;calculating the log-probability associated with the variables in the <code>AbstractVarInfo</code>&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts/default.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.InitContext"><a class="docstring-binding" href="#DynamicPPL.InitContext"><code>DynamicPPL.InitContext</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InitContext(
    [rng::Random.AbstractRNG=Random.default_rng()],
    strategy::AbstractInitStrategy,
    transform_strategy::AbstractTransformStrategy,
)</code></pre><p>A leaf context that indicates that new values for random variables are currently being obtained through sampling. Used e.g. when initialising a fresh VarInfo.</p><p>The <code>strategy</code> argument specifies how new values are to be obtained (see <a href="#DynamicPPL.AbstractInitStrategy"><code>AbstractInitStrategy</code></a> for details), while the <code>transform_strategy</code> argument specifies whether values should be treated as being in linked or unlinked space. That also means that <code>transform_strategy</code> determines whether the log-Jacobian of the link transform is included when evaluating the model.</p><div class="admonition is-info" id="Note-4270ea23aefbef99"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4270ea23aefbef99" title="Permalink"></a></header><div class="admonition-body"><p>If <code>leafcontext(model.context) isa InitContext</code>, then <code>evaluate!!(model, varinfo)</code> will override all values in the VarInfo.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts/init.jl#L354-L373">source</a></section></details></article><p>To implement a leaf context, you need to subtype <code>AbstractPPL.AbstractContext</code> and implement the <code>tilde_assume!!</code> and <code>tilde_observe!!</code> methods for your context.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.tilde_assume!!"><a class="docstring-binding" href="#DynamicPPL.tilde_assume!!"><code>DynamicPPL.tilde_assume!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.tilde_assume!!(
    context::AbstractContext,
    right::Distribution,
    vn::VarName,
    template::Any,
    vi::AbstractVarInfo
)::Tuple{Any,AbstractVarInfo}</code></pre><p>Handle assumed variables, i.e. anything which is not observed (see <a href="#DynamicPPL.tilde_observe!!"><code>tilde_observe!!</code></a>). Accumulate the associated log probability, and return the sampled value and updated <code>vi</code>.</p><p><code>vn</code> is the VarName on the left-hand side of the tilde statement.</p><p><code>template</code> is the value of the top-level symbol in <code>vn</code>.</p><p>This function should return a tuple <code>(x, vi)</code>, where <code>x</code> is the sampled value (which must be untransformed, i.e., <code>insupport(right, x)</code> must be true!) and <code>vi</code> is the updated VarInfo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts.jl#L93-L112">source</a></section><section><div><pre><code class="language-julia hljs">DynamicPPL.tilde_assume!!(
    ::DefaultContext,
    right::Distribution,
    vn::VarName,
    template::Any,
    vi::AbstractVarInfo
)</code></pre><p>Handle assumed variables. For <code>DefaultContext</code>, this function extracts the value associated with <code>vn</code> from <code>vi</code>, If <code>vi</code> does not contain an appropriate value then this will error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts/default.jl#L21-L32">source</a></section><section><div><pre><code class="language-julia hljs">DynamicPPL.tilde_assume!!(
    context::AbstractContext,
    right::DynamicPPL.Submodel,
    vn::VarName,
    ::Any,
    vi::AbstractVarInfo
)</code></pre><p>Evaluate the submodel with the given context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/submodel.jl#L145-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.tilde_observe!!"><a class="docstring-binding" href="#DynamicPPL.tilde_observe!!"><code>DynamicPPL.tilde_observe!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.tilde_observe!!(
    context::AbstractContext,
    right::Distribution,
    left,
    vn::Union{VarName, Nothing},
    template::Any,
    vi::AbstractVarInfo
)::Tuple{Any,AbstractVarInfo}</code></pre><p>This function handles observed variables, which may be:</p><ul><li>literals on the left-hand side, e.g., <code>3.0 ~ Normal()</code></li><li>a model input, e.g. <code>x ~ Normal()</code> in a model <code>@model f(x) ... end</code></li><li>a conditioned or fixed variable, e.g. <code>x ~ Normal()</code> in a model <code>model | (; x = 3.0)</code>.</li></ul><p>The relevant log-probability associated with the observation is computed and accumulated in the VarInfo object <code>vi</code> (except for fixed variables, which do not contribute to the log-probability).</p><p><code>left</code> is the actual value that the left-hand side evaluates to. <code>vn</code> is the VarName on the left-hand side, or <code>nothing</code> if the left-hand side is a literal value. <code>template</code> is the value of the top-level symbol in <code>vn</code>; if <code>vn</code> is <code>nothing</code>, then <code>template</code> will be <code>NoTemplate()</code>.</p><p>This function should return a tuple <code>(left, vi)</code>, where <code>left</code> is the same as the input, and <code>vi</code> is the updated VarInfo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts.jl#L128-L155">source</a></section><section><div><pre><code class="language-julia hljs">DynamicPPL.tilde_observe!!(
    ::DefaultContext,
    right::Distribution,
    left,
    vn::Union{VarName,Nothing},
    template::Any,
    vi::AbstractVarInfo,
)</code></pre><p>Handle observed variables. This just accumulates the log-likelihood for <code>left</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts/default.jl#L56-L67">source</a></section></details></article><p><strong>Parent contexts</strong>: These essentially act as &#39;modifiers&#39; for leaf contexts. For example, <code>PrefixContext</code> adds a prefix to all variable names during evaluation, while <code>CondFixContext</code> marks certain variables as being either conditioned or fixed.</p><p>To implement a parent context, you have to subtype <code>DynamicPPL.AbstractParentContext</code>, and implement the <code>childcontext</code> and <code>setchildcontext</code> methods. If needed, you can also implement <code>tilde_assume!!</code> and <code>tilde_observe!!</code> for your context. This is optional; the default implementation is to simply delegate to the child context.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractParentContext"><a class="docstring-binding" href="#DynamicPPL.AbstractParentContext"><code>DynamicPPL.AbstractParentContext</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractParentContext</code></pre><p>An abstract context that has a child context.</p><p>Subtypes of <code>AbstractParentContext</code> must implement the following interface:</p><ul><li><code>DynamicPPL.childcontext(context::AbstractParentContext)</code>: Return the child context.</li><li><code>DynamicPPL.setchildcontext(parent::AbstractParentContext, child::AbstractContext)</code>: Reconstruct <code>parent</code> but now using <code>child</code> as its child context.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.childcontext"><a class="docstring-binding" href="#DynamicPPL.childcontext"><code>DynamicPPL.childcontext</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">childcontext(context::AbstractParentContext)</code></pre><p>Return the descendant context of <code>context</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts.jl#L14-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setchildcontext"><a class="docstring-binding" href="#DynamicPPL.setchildcontext"><code>DynamicPPL.setchildcontext</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setchildcontext(parent::AbstractParentContext, child::AbstractContext)</code></pre><p>Reconstruct <code>parent</code> but now using <code>child</code> is its <a href="#DynamicPPL.childcontext"><code>childcontext</code></a>, effectively updating the child context.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL: InitContext, CondFixContext, Condition

julia&gt; ctx = CondFixContext{Condition}(VarNamedTuple(; a = 1));

julia&gt; DynamicPPL.childcontext(ctx)
DefaultContext()

julia&gt; ctx_prior = DynamicPPL.setchildcontext(ctx, InitContext(MersenneTwister(23), InitFromPrior(), UnlinkAll()));

julia&gt; DynamicPPL.childcontext(ctx_prior)
InitContext{MersenneTwister, InitFromPrior, UnlinkAll}(MersenneTwister(23), InitFromPrior(), UnlinkAll())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts.jl#L21-L41">source</a></section></details></article><p>Since contexts form a tree structure, these functions are automatically defined for manipulating context stacks. They are mainly useful for modifying the fundamental behaviour (i.e. the leaf context), without affecting any of the modifiers (i.e. parent contexts).</p><article><details class="docstring" open="true"><summary id="DynamicPPL.leafcontext"><a class="docstring-binding" href="#DynamicPPL.leafcontext"><code>DynamicPPL.leafcontext</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">leafcontext(context::AbstractContext)</code></pre><p>Return the leaf of <code>context</code>, i.e. the first descendant context that is not an <code>AbstractParentContext</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts.jl#L44-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setleafcontext"><a class="docstring-binding" href="#DynamicPPL.setleafcontext"><code>DynamicPPL.setleafcontext</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setleafcontext(left::AbstractContext, right::AbstractContext)</code></pre><p>Return <code>left</code> but now with its leaf context replaced by <code>right</code>.</p><p>Note that this also works even if <code>right</code> is not a leaf context, in which case effectively append <code>right</code> to <code>left</code>, dropping the original leaf context of <code>left</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL: leafcontext, setleafcontext, childcontext, setchildcontext, AbstractContext, InitContext

julia&gt; struct ParentContext{C} &lt;: AbstractParentContext
           context::C
       end

julia&gt; DynamicPPL.childcontext(context::ParentContext) = context.context

julia&gt; DynamicPPL.setchildcontext(::ParentContext, child) = ParentContext(child)

julia&gt; Base.show(io::IO, c::ParentContext) = print(io, &quot;ParentContext(&quot;, childcontext(c), &quot;)&quot;)

julia&gt; ctx = ParentContext(ParentContext(DefaultContext()))
ParentContext(ParentContext(DefaultContext()))

julia&gt; # Replace the leaf context with another leaf.
       leafcontext(setleafcontext(ctx, InitContext(MersenneTwister(23), InitFromPrior(), UnlinkAll())))
InitContext{MersenneTwister, InitFromPrior, UnlinkAll}(MersenneTwister(23), InitFromPrior(), UnlinkAll())

julia&gt; # Append another parent context.
       setleafcontext(ctx, ParentContext(DefaultContext()))
ParentContext(ParentContext(ParentContext(DefaultContext())))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts.jl#L53-L87">source</a></section><section><div><pre><code class="language-julia hljs">setleafcontext(model::Model, context::AbstractContext)</code></pre><p>Return a new <code>Model</code> with its leaf context set to <code>context</code>. This is a convenience shortcut for <code>contextualize(model, setleafcontext(model.context, context)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L119-L124">source</a></section></details></article><h3 id="VarInfo-initialisation"><a class="docs-heading-anchor" href="#VarInfo-initialisation">VarInfo initialisation</a><a id="VarInfo-initialisation-1"></a><a class="docs-heading-anchor-permalink" href="#VarInfo-initialisation" title="Permalink"></a></h3><p>The function <code>init!!</code> is used to initialise, or overwrite, values in a VarInfo. It is really a thin wrapper around using <code>evaluate!!</code> with an <code>InitContext</code>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.init!!"><a class="docstring-binding" href="#DynamicPPL.init!!"><code>DynamicPPL.init!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">init!!(
    [rng::Random.AbstractRNG,]
    model::Model,
    varinfo::AbstractVarInfo,
    init_strategy::AbstractInitStrategy,
    [transform_strategy::AbstractTransformStrategy=get_transform_strategy(varinfo),]
)</code></pre><p>Evaluate the <code>model</code> and replace the values of the model&#39;s random variables in the given <code>varinfo</code> with new values, using a specified initialisation strategy. If the values in <code>varinfo</code> are not set, they will be added using a specified initialisation strategy.</p><p><code>transform_strategy</code> tells the model evaluation whether variables should be interpreted as linked or unlinked. Right now, it is slightly complicated because the default behaviour depends on the <code>varinfo</code> provided. If <code>varinfo isa VarInfo</code>, then the transform strategy is inferred from the VarInfo, i.e., linked variables in the VarInfo are treated as linked during evaluation. Conversely, if <code>varinfo isa OnlyAccsVarInfo</code>, then you must specify the transform strategy explicitly, since an <code>OnlyAccsVarInfo</code> does not contain any information about which variables are transformed.</p><p>Returns a tuple of the model&#39;s return value, plus the updated <code>varinfo</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L771-L793">source</a></section></details></article><p>To accomplish this, an initialisation <em>strategy</em> is required, which defines how new values are to be obtained. There are several concrete strategies provided in DynamicPPL: see the <a href="../init/#init-strategies">initialisation strategies page</a> for more information.</p><p>If you wish to write your own, you have to subtype <a href="#DynamicPPL.AbstractInitStrategy"><code>DynamicPPL.AbstractInitStrategy</code></a> and implement the <code>init</code> method. In very rare situations, you may also need to implement <code>get_param_eltype</code>, which defines the element type of the parameters generated by the strategy.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractInitStrategy"><a class="docstring-binding" href="#DynamicPPL.AbstractInitStrategy"><code>DynamicPPL.AbstractInitStrategy</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractInitStrategy</code></pre><p>Abstract type representing the possible ways of initialising new values for the random variables in a model (e.g., when creating a new VarInfo).</p><p>Any subtype of <code>AbstractInitStrategy</code> must implement the <a href="#DynamicPPL.init"><code>DynamicPPL.init</code></a> method, and in some cases, <a href="#DynamicPPL.get_param_eltype"><code>DynamicPPL.get_param_eltype</code></a> (see its docstring for details).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts/init.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.init"><a class="docstring-binding" href="#DynamicPPL.init"><code>DynamicPPL.init</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">init(rng::Random.AbstractRNG, vn::VarName, dist::Distribution, strategy::AbstractInitStrategy)</code></pre><p>Generate a new value for a random variable with the given distribution.</p><p>This function must return an <code>AbstractTransformedValue</code>.</p><p>If <code>strategy</code> provides values that are already untransformed (e.g., a Float64 within (0, 1) for <code>dist::Beta</code>, then you should return an <code>UntransformedValue</code>.</p><p>Otherwise, often there are cases where this will return either a <code>VectorValue</code> or a <code>LinkedVectorValue</code>, for example, if the strategy is reading from an existing <code>VarInfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts/init.jl#L12-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.get_param_eltype"><a class="docstring-binding" href="#DynamicPPL.get_param_eltype"><code>DynamicPPL.get_param_eltype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.get_param_eltype(strategy::AbstractInitStrategy)</code></pre><p>Return the element type of the parameters generated from the given initialisation strategy.</p><p>The default implementation returns <code>Any</code>. However, for <code>InitFromParams</code> which provides known parameters for evaluating the model, methods are sometimes implemented in order to return more specific types.</p><p>In general, if you are implementing a custom <code>AbstractInitStrategy</code>, correct behaviour can only be guaranteed if you implement this method as well. However, quite often, the default return value of <code>Any</code> will actually suffice. The cases where this does <em>not</em> suffice, and where you <em>do</em> have to manually implement <code>get_param_eltype</code>, are explained in the extended help (see <code>??DynamicPPL.get_param_eltype</code> in the REPL).</p><p><strong>Extended help</strong></p><p>There are a few edge cases in DynamicPPL where the element type is needed. These largely relate to determining the element type of accumulators ahead of time (<em>before</em> evaluation), as well as promoting type parameters in model arguments. The classic case is when evaluating a model with ForwardDiff: the log-probability accumulators must be promoted to contain <code>Dual</code>s, and any <code>Vector{Float64}</code> arguments must be promoted to <code>Vector{Dual}</code>. Other tracer types, for example those in SparseConnectivityTracer.jl, also require similar treatment.</p><p>If the <code>AbstractInitStrategy</code> is never used in combination with tracer types, then it is perfectly safe to return <code>Any</code>. This does not lead to type instability downstream because the actual accumulators will still be created with concrete Float types (the <code>Any</code> is just used to determine whether the float type needs to be modified).</p><p>In case that wasn&#39;t enough: in fact, even the above is not always true. Firstly, the accumulator argument is only true when evaluating with ThreadSafeVarInfo. See the comments in <code>DynamicPPL.unflatten!!</code> for more details. For non-threadsafe evaluation, Julia is capable of automatically promoting the types on its own. Secondly, the promotion only matters if you are trying to directly assign into a <code>Vector{Float64}</code> with a <code>ForwardDiff.Dual</code> or similar tracer type, for example using <code>xs[i] = MyDual</code>. This doesn&#39;t actually apply to tilde-statements like <code>xs[i] ~ ...</code> because those use <code>Accessors.set</code> under the hood, which also does the promotion for you. For the gory details, see the following issues:</p><ul><li>https://github.com/TuringLang/DynamicPPL.jl/issues/906 for accumulator types</li><li>https://github.com/TuringLang/DynamicPPL.jl/issues/823 for type argument promotion</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/contexts/init.jl#L27-L69">source</a></section><section><div><pre><code class="language-julia hljs">get_param_eltype(varinfo::AbstractVarInfo, context::AbstractContext)</code></pre><p>Get the element type of the parameters being used to evaluate a model, using a <code>varinfo</code> under the given <code>context</code>. For example, when evaluating a model with ForwardDiff AD, this should return <code>ForwardDiff.Dual</code>.</p><p>By default, this uses <code>eltype(varinfo)</code> which is slightly cursed. This relies on the fact that typically, before evaluation, the parameters will have been inserted into the VarInfo&#39;s metadata field.</p><p>For <code>InitContext</code>, it&#39;s quite different: because <code>InitContext</code> is responsible for supplying the parameters, we can avoid using <code>eltype(varinfo)</code> and instead query the parameters inside it. See the docstring of <code>get_param_eltype(strategy::AbstractInitStrategy)</code> for more explanation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/model.jl#L940-L955">source</a></section></details></article><p>The function <a href="#DynamicPPL.init"><code>DynamicPPL.init</code></a> should return an <code>AbstractTransformedValue</code>. There are three subtypes currently available:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractTransformedValue"><a class="docstring-binding" href="#DynamicPPL.AbstractTransformedValue"><code>DynamicPPL.AbstractTransformedValue</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractTransformedValue</code></pre><p>An abstract type for values that enter the DynamicPPL tilde-pipeline.</p><p>These values are generated by an <a href="#DynamicPPL.AbstractInitStrategy"><code>AbstractInitStrategy</code></a>: the function <a href="#DynamicPPL.init"><code>DynamicPPL.init</code></a> should return an <code>AbstractTransformedValue</code>.</p><p>Each <code>AbstractTransformedValue</code> contains some version of the actual variable&#39;s value, together with a transformation that can be used to convert the internal value back to the original space.</p><p>Current subtypes are <a href="#DynamicPPL.VectorValue"><code>VectorValue</code></a>, <a href="#DynamicPPL.LinkedVectorValue"><code>LinkedVectorValue</code></a>, and <a href="#DynamicPPL.UntransformedValue"><code>UntransformedValue</code></a>. DynamicPPL&#39;s <a href="../vnt/arraylikeblocks/#VarInfo"><code>VarInfo</code></a> type stores either <code>VectorValue</code>s or <code>LinkedVectorValue</code>s internally, depending on the link status of the <code>VarInfo</code>.</p><div class="admonition is-warning" id="Warning-a6c1ae0b104979c8"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-a6c1ae0b104979c8" title="Permalink"></a></header><div class="admonition-body"><p>Even though the subtypes listed above are public, this abstract type is not itself part of the public API and should not be subtyped by end users. Much of DynamicPPL&#39;s model evaluation methods depends on these subtypes having predictable behaviour, i.e., their transforms should always be <code>from_linked_vec_transform(dist)</code>, <code>from_vec_transform(dist)</code>, or their inverse. If you create a new subtype of <code>AbstractTransformedValue</code> and use it, DynamicPPL will not know how to handle it and may either error or silently give incorrect results.</p><p>In principle, it should be possible to subtype this and allow for custom transformations to be used (not just the &#39;default&#39; ones). However, this is not currently implemented.</p></div></div><p>Subtypes of this should implement the following functions:</p><ul><li><p><code>DynamicPPL.get_transform(tv::AbstractTransformedValue)</code>: Get the transformation that converts the internal value back to the original space.</p></li><li><p><code>DynamicPPL.get_internal_value(tv::AbstractTransformedValue)</code>: Get the internal value stored in <code>tv</code>.</p></li><li><p><code>DynamicPPL.set_internal_value(tv::AbstractTransformedValue, new_val)</code>: Create a new <code>AbstractTransformedValue</code> with the same transformation as <code>tv</code>, but with internal value <code>new_val</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L27-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.VectorValue"><a class="docstring-binding" href="#DynamicPPL.VectorValue"><code>DynamicPPL.VectorValue</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VectorValue{V&lt;:AbstractVector,T}</code></pre><p>A transformed value that stores its internal value as a vectorised form. This is what VarInfo sees as an &quot;unlinked value&quot;.</p><p>These values can be generated when using <code>InitFromParams</code> with a VarInfo&#39;s internal values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L101-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.LinkedVectorValue"><a class="docstring-binding" href="#DynamicPPL.LinkedVectorValue"><code>DynamicPPL.LinkedVectorValue</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinkedVectorValue{V&lt;:AbstractVector,T}</code></pre><p>A transformed value that stores its internal value as a linked and vectorised form. This is what VarInfo sees as a &quot;linked value&quot;.</p><p>These values can be generated when using <code>InitFromParams</code> with a VarInfo&#39;s internal values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L125-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.UntransformedValue"><a class="docstring-binding" href="#DynamicPPL.UntransformedValue"><code>DynamicPPL.UntransformedValue</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UntransformedValue{V}</code></pre><p>A raw, untransformed, value.</p><p>These values can be generated from initialisation strategies such as <code>InitFromPrior</code>, <code>InitFromUniform</code>, and <code>InitFromParams</code> on a standard container type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L167-L174">source</a></section></details></article><p>The interface for working with transformed values consists of:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.get_transform"><a class="docstring-binding" href="#DynamicPPL.get_transform"><code>DynamicPPL.get_transform</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_transform(tv::AbstractTransformedValue)</code></pre><p>Get the transformation that converts the internal value back to the raw value.</p><div class="admonition is-warning" id="Warning-9ea44482cb4d6418"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-9ea44482cb4d6418" title="Permalink"></a></header><div class="admonition-body"><p>If the distribution associated with the variable has changed since this <code>AbstractTransformedValue</code> was created, this transform may be inaccurate. This can happen e.g. if <code>unflatten!!</code> has been called on a VarInfo containing this.</p><p>Consequently, when the distribution on the right-hand side of a tilde-statement is available, you should always prefer regenerating the transform from that distribution rather than using this function.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L70-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.get_internal_value"><a class="docstring-binding" href="#DynamicPPL.get_internal_value"><code>DynamicPPL.get_internal_value</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_internal_value(tv::AbstractTransformedValue)</code></pre><p>Get the internal value stored in <code>tv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L86-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.set_internal_value"><a class="docstring-binding" href="#DynamicPPL.set_internal_value"><code>DynamicPPL.set_internal_value</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_internal_value(tv::AbstractTransformedValue, new_val)</code></pre><p>Create a new <code>AbstractTransformedValue</code> with the same transformation as <code>tv</code>, but with internal value <code>new_val</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/transformed_values.jl#L93-L98">source</a></section></details></article><h3 id="Converting-VarInfos-to/from-chains"><a class="docs-heading-anchor" href="#Converting-VarInfos-to/from-chains">Converting VarInfos to/from chains</a><a id="Converting-VarInfos-to/from-chains-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-VarInfos-to/from-chains" title="Permalink"></a></h3><p>It is a fairly common operation to want to convert a collection of <code>VarInfo</code> objects into a chains object for downstream analysis.</p><p>This can be accomplished by first converting each <code>VarInfo</code> into a <code>ParamsWithStats</code> object:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.ParamsWithStats"><a class="docstring-binding" href="#DynamicPPL.ParamsWithStats"><code>DynamicPPL.ParamsWithStats</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ParamsWithStats</code></pre><p>A struct which contains parameter values extracted from a <code>VarInfo</code>, along with any statistics associated with the VarInfo. The statistics are provided as a NamedTuple and are optional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/src/chains.jl#L1-L7">source</a></section></details></article><p>Once you have a <strong>matrix</strong> of these, you can convert them into a chains object using:</p><article><details class="docstring" open="true"><summary id="AbstractMCMC.from_samples-Tuple{Type{Chains}, AbstractMatrix{&lt;:ParamsWithStats}}"><a class="docstring-binding" href="#AbstractMCMC.from_samples-Tuple{Type{Chains}, AbstractMatrix{&lt;:ParamsWithStats}}"><code>AbstractMCMC.from_samples</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AbstractMCMC.from_samples(
    ::Type{MCMCChains.Chains},
    params_and_stats::AbstractMatrix{&lt;:DynamicPPL.ParamsWithStats}
)</code></pre><p>Convert an array of <code>DynamicPPL.ParamsWithStats</code> to an <code>MCMCChains.Chains</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMCMCChainsExt.jl#L30-L37">source</a></section></details></article><p>If you only have a vector you can use <code>hcat</code> to convert it into an <code>N×1</code> matrix first.</p><p>Furthermore, one can convert chains back into a collection of parameter dictionaries and/or stats with:</p><article><details class="docstring" open="true"><summary id="AbstractMCMC.to_samples-Tuple{Type{ParamsWithStats}, Chains, Model}"><a class="docstring-binding" href="#AbstractMCMC.to_samples-Tuple{Type{ParamsWithStats}, Chains, Model}"><code>AbstractMCMC.to_samples</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AbstractMCMC.to_samples(
    ::Type{DynamicPPL.ParamsWithStats},
    chain::MCMCChains.Chains,
    model::DynamicPPL.Model
)</code></pre><p>Convert an <code>MCMCChains.Chains</code> object to an array of <code>DynamicPPL.ParamsWithStats</code>.</p><p>For this to work, <code>chain</code> must contain the <code>varname_to_symbol</code> mapping in its <code>info</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/1d419d890729efa20bd07f12998e83d1075a8a1a/ext/DynamicPPLMCMCChainsExt.jl#L95-L105">source</a></section></details></article><p>(Note that the model argument is mandatory as it provides templating information for the variables in the chains.) With these, you can (for example) extract the parameter dictionaries and use <code>InitFromParams</code> to re-evaluate a model at each point in the chain.</p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../migration/">« Migrating old VarInfo code</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 00:20">Wednesday 25 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
