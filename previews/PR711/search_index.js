var documenterSearchIndex = {"docs":
[{"location":"internals/varinfo/#Design-of-VarInfo","page":"Design of VarInfo","title":"Design of VarInfo","text":"","category":"section"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"VarInfo is a fairly simple structure.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"VarInfo","category":"page"},{"location":"internals/varinfo/#DynamicPPL.VarInfo-internals-varinfo","page":"Design of VarInfo","title":"DynamicPPL.VarInfo","text":"struct VarInfo{Tmeta, Tlogp} <: AbstractVarInfo\n    metadata::Tmeta\n    logp::Base.RefValue{Tlogp}\n    num_produce::Base.RefValue{Int}\nend\n\nA light wrapper over one or more instances of Metadata. Let vi be an instance of VarInfo. If vi isa VarInfo{<:Metadata}, then only one Metadata instance is used for all the sybmols. VarInfo{<:Metadata} is aliased UntypedVarInfo. If vi isa VarInfo{<:NamedTuple}, then vi.metadata is a NamedTuple that maps each symbol used on the LHS of ~ in the model to its Metadata instance. The latter allows for the type specialization of vi after the first sampling iteration when all the symbols have been observed. VarInfo{<:NamedTuple} is aliased TypedVarInfo.\n\nNote: It is the user's responsibility to ensure that each \"symbol\" is visited at least once whenever the model is called, regardless of any stochastic branching. Each symbol refers to a Julia variable and can be a hierarchical array of many random variables, e.g. x[1] ~ ... and x[2] ~ ... both have the same symbol x.\n\n\n\n\n\n","category":"type"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"It contains","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"a logp field for accumulation of the log-density evaluation, and\na metadata field for storing information about the realizations of the different variables.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Representing logp is fairly straight-forward: we'll just use a Real or an array of Real, depending on the context.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Representing metadata is a bit trickier. This is supposed to contain all the necessary information for each VarName to enable the different executions of the model + extraction of different properties of interest after execution, e.g. the realization / value corresponding to a variable @varname(x).","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"note: Note\nWe want to work with VarName rather than something like Symbol or String as VarName contains additional structural information, e.g. a Symbol(\"x[1]\") can be a result of either var\"x[1]\" ~ Normal() or x[1] ~ Normal(); these scenarios are disambiguated by VarName.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"To ensure that VarInfo is simple and intuitive to work with, we want VarInfo, and hence the underlying metadata, to replicate the following functionality of Dict:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"keys(::Dict): return all the VarNames present in metadata.\nhaskey(::Dict): check if a particular VarName is present in metadata.\ngetindex(::Dict, ::VarName): return the realization corresponding to a particular VarName.\nsetindex!(::Dict, val, ::VarName): set the realization corresponding to a particular VarName.\npush!(::Dict, ::Pair): add a new key-value pair to the container.\ndelete!(::Dict, ::VarName): delete the realization corresponding to a particular VarName.\nempty!(::Dict): delete all realizations in metadata.\nmerge(::Dict, ::Dict): merge two metadata structures according to similar rules as Dict.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"But for general-purpose samplers, we often want to work with a simple flattened structure, typically a Vector{<:Real}. One can access a vectorised version of a variable's value with the following vector-like functions:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"getindex_internal(::VarInfo, ::VarName): get the flattened value of a single variable.\ngetindex_internal(::VarInfo, ::Colon): get the flattened values of all variables.\ngetindex_internal(::VarInfo, i::Int): get ith value of the flattened vector of all values\nsetindex_internal!(::VarInfo, ::AbstractVector, ::VarName): set the flattened value of a variable.\nsetindex_internal!(::VarInfo, val, i::Int): set the ith value of the flattened vector of all values\nlength_internal(::VarInfo): return the length of the flat representation of metadata.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"The functions have _internal in their name because internally VarInfo always stores values as vectorised.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Moreover, a link transformation can be applied to a VarInfo with link!! (and reversed with invlink!!), which applies a reversible transformation to the internal storage format of a variable that makes the range of the random variable cover all of Euclidean space. getindex_internal and setindex_internal! give direct access to the vectorised value after such a transformation, which is what samplers often need to be able sample in unconstrained space. One can also manually set a transformation by giving setindex_internal! a fourth, optional argument, that is a function that maps internally stored value to the actual value of the variable.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Finally, we want want the underlying representation used in metadata to have a few performance-related properties:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Type-stable when possible, but functional when not.\nEfficient storage and iteration when possible, but functional when not.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"The \"but functional when not\" is important as we want to support arbitrary models, which means that we can't always have these performance properties.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"In the following sections, we'll outline how we achieve this in VarInfo.","category":"page"},{"location":"internals/varinfo/#Type-stability","page":"Design of VarInfo","title":"Type-stability","text":"","category":"section"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Ensuring type-stability is somewhat non-trivial to address since we want this to be the case even when models mix continuous (typically Float64) and discrete (typically Int) variables.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Suppose we have an implementation of metadata which implements the functionality outlined in the previous section. The way we approach this in VarInfo is to use a NamedTuple with a separate metadata for each distinct Symbol used. For example, if we have a model of the form","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"using DynamicPPL, Distributions, FillArrays\n\n@model function demo()\n    x ~ product_distribution(Fill(Bernoulli(0.5), 2))\n    y ~ Normal(0, 1)\n    return nothing\nend","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"then we construct a type-stable representation by using a NamedTuple{(:x, :y), Tuple{Vx, Vy}} where","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Vx is a container with eltype Bool, and\nVy is a container with eltype Float64.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Since VarName contains the Symbol used in its type, something like getindex(varinfo, @varname(x)) can be resolved to getindex(varinfo.metadata.x, @varname(x)) at compile-time.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"For example, with the model above we have","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"# Type-unstable `VarInfo`\nvarinfo_untyped = DynamicPPL.untyped_varinfo(\n    demo(), SampleFromPrior(), DefaultContext(), DynamicPPL.Metadata()\n)\ntypeof(varinfo_untyped.metadata)","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"# Type-stable `VarInfo`\nvarinfo_typed = DynamicPPL.typed_varinfo(demo())\ntypeof(varinfo_typed.metadata)","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"They both work as expected but one results in concrete typing and the other does not:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"varinfo_untyped[@varname(x)], varinfo_untyped[@varname(y)]","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"varinfo_typed[@varname(x)], varinfo_typed[@varname(y)]","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Notice that the untyped VarInfo uses Vector{Real} to store the boolean entries while the typed uses Vector{Bool}. This is because the untyped version needs the underlying container to be able to handle both the Bool for x and the Float64 for y, while the typed version can use a Vector{Bool} for x and a Vector{Float64} for y due to its usage of NamedTuple.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"warning: Warning\nOf course, this NamedTuple approach is not necessarily going to help us in scenarios where the Symbol does not correspond to a unique type, e.g.x[1] ~ Bernoulli(0.5)\nx[2] ~ Normal(0, 1)In this case we'll end up with a NamedTuple((:x,), Tuple{Vx}) where Vx is a container with eltype Union{Bool, Float64} or something worse. This is not type-stable but will still be functional.In practice, we rarely observe such mixing of types, therefore in DynamicPPL, and more widely in Turing.jl, we use a NamedTuple approach for type-stability with great success.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"warning: Warning\nAnother downside with such a NamedTuple approach is that if we have a model with lots of tilde-statements, e.g. a ~ Normal(), b ~ Normal(), ..., z ~ Normal() will result in a NamedTuple with 27 entries, potentially leading to long compilation times.For these scenarios it can be useful to fall back to \"untyped\" representations.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Hence we obtain a \"type-stable when possible\"-representation by wrapping it in a NamedTuple and partially resolving the getindex, setindex!, etc. methods at compile-time. When type-stability is not desired, we can simply use a single metadata for all VarNames instead of a NamedTuple wrapping a collection of metadatas.","category":"page"},{"location":"internals/varinfo/#Efficient-storage-and-iteration","page":"Design of VarInfo","title":"Efficient storage and iteration","text":"","category":"section"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Efficient storage and iteration we achieve through implementation of the metadata. In particular, we do so with DynamicPPL.VarNamedVector:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"DynamicPPL.VarNamedVector","category":"page"},{"location":"internals/varinfo/#DynamicPPL.VarNamedVector","page":"Design of VarInfo","title":"DynamicPPL.VarNamedVector","text":"VarNamedVector\n\nA container that stores values in a vectorised form, but indexable by variable names.\n\nA VarNamedVector can be thought of as an ordered mapping from VarNames to pairs of (internal_value, transform). Here internal_value is a vectorised value for the variable and transform is a function such that transform(internal_value) is the \"original\" value of the variable, the one that the user sees. For instance, if the variable has a matrix value, internal_value could bea flattened Vector of its elements, and transform would be a reshape call.\n\ntransform may implement simply vectorisation, but it may do more. Most importantly, it may implement linking, where the internal storage of a random variable is in a form where all values in Euclidean space are valid. This is useful for sampling, because the sampler can make changes to internal_value without worrying about constraints on the space of the random variable.\n\nThe way to access this storage format directly is through the functions getindex_internal and setindex_internal. The transform argument for setindex_internal is optional, by default it is either the identity, or the existing transform if a value already exists for this VarName.\n\nVarNamedVector also provides a Dict-like interface that hides away the internal vectorisation. This can be accessed with getindex and setindex!. setindex! only takes the value, the transform is automatically set to be a simple vectorisation. The only notable deviation from the behavior of a Dict is that setindex! will throw an error if one tries to set a new value for a variable that lives in a different \"space\" than the old one (e.g. is of a different type or size). This is because setindex! does not change the transform of a variable, e.g. preserve linking, and thus the new value must be compatible with the old transform.\n\nFor now, a third value is in fact stored for each VarName: a boolean indicating whether the variable has been transformed to unconstrained Euclidean space or not. This is only in place temporarily due to the needs of our old Gibbs sampler.\n\nInternally, VarNamedVector stores the values of all variables in a single contiguous vector. This makes some operations more efficient, and means that one can access the entire contents of the internal storage quickly with getindex_internal(vnv, :). The other fields of VarNamedVector are mostly used to keep track of which part of the internal storage belongs to which VarName.\n\nFields\n\nvarname_to_index: mapping from a VarName to its integer index in varnames, ranges and transforms\n\nvarnames: vector of VarNames for the variables, where varnames[varname_to_index[vn]] == vn\n\nranges: vector of index ranges in vals corresponding to varnames; each VarName vn has a single index or a set of contiguous indices, such that the values of vn can be found at vals[ranges[varname_to_index[vn]]]\n\nvals: vector of values of all variables; the value(s) of vn is/are vals[ranges[varname_to_index[vn]]]\n\ntransforms: vector of transformations, so that transforms[varname_to_index[vn]] is a callable that transforms the value of vn back to its original space, undoing any linking and vectorisation\n\nis_unconstrained: vector of booleans indicating whether a variable has been transformed to unconstrained Euclidean space or not, i.e. whether its domain is all of ℝ^ⁿ. Having is_unconstrained[varname_to_index[vn]] == false does not necessarily mean that a variable is constrained, but rather that it's not guaranteed to not be.\n\nnum_inactive: mapping from a variable index to the number of inactive entries for that variable. Inactive entries are elements in vals that are not part of the value of any variable. They arise when a variable is set to a new value with a different dimension, in-place. Inactive entries always come after the last active entry for the given variable. See the extended help with ??VarNamedVector for more details.\n\nExtended help\n\nThe values for different variables are internally all stored in a single vector. For instance,\n\njulia> using DynamicPPL: ReshapeTransform, VarNamedVector, @varname, setindex!, update!, getindex_internal\n\njulia> vnv = VarNamedVector();\n\njulia> setindex!(vnv, [0.0, 0.0, 0.0, 0.0], @varname(x));\n\njulia> setindex!(vnv, reshape(1:6, (2,3)), @varname(y));\n\njulia> vnv.vals\n10-element Vector{Real}:\n 0.0\n 0.0\n 0.0\n 0.0\n 1\n 2\n 3\n 4\n 5\n 6\n\nThe varnames, ranges, and varname_to_index fields keep track of which value belongs to which variable. The transforms field stores the transformations that needed to transform the vectorised internal storage back to its original form:\n\njulia> vnv.transforms[vnv.varname_to_index[@varname(y)]] == DynamicPPL.ReshapeTransform((6,), (2,3))\ntrue\n\nIf a variable is updated with a new value that is of a smaller dimension than the old value, rather than resizing vnv.vals, some elements in vnv.vals are marked as inactive.\n\njulia> update!(vnv, [46.0, 48.0], @varname(x))\n\njulia> vnv.vals\n10-element Vector{Real}:\n 46.0\n 48.0\n  0.0\n  0.0\n  1\n  2\n  3\n  4\n  5\n  6\n\njulia> println(vnv.num_inactive);\nOrderedDict(1 => 2)\n\nThis helps avoid unnecessary memory allocations for values that repeatedly change dimension. The user does not have to worry about the inactive entries as long as they use functions like setindex! and getindex! rather than directly accessing vnv.vals.\n\njulia> vnv[@varname(x)]\n2-element Vector{Float64}:\n 46.0\n 48.0\n\njulia> getindex_internal(vnv, :)\n8-element Vector{Real}:\n 46.0\n 48.0\n  1\n  2\n  3\n  4\n  5\n  6\n\n\n\n\n\n","category":"type"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"In a DynamicPPL.VarNamedVector{<:VarName,T}, we achieve the desiderata by storing the values for different VarNames contiguously in a Vector{T} and keeping track of which ranges correspond to which VarNames.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"This does require a bit of book-keeping, in particular when it comes to insertions and deletions. Internally, this is handled by assigning each VarName a unique Int index in the varname_to_index field, which is then used to index into the following fields:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"varnames::Vector{<:VarName}: the VarNames in the order they appear in the Vector{T}.\nranges::Vector{UnitRange{Int}}: the ranges of indices in the Vector{T} that correspond to each VarName.\ntransforms::Vector: the transforms associated with each VarName.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Mutating functions, e.g. setindex_internal!(vnv::VarNamedVector, val, vn::VarName), are then treated according to the following rules:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"If vn is not already present: add it to the end of vnv.varnames, add the val to the underlying vnv.vals, etc.\nIf vn is already present in vnv:\nIf val has the same length as the existing value for vn: replace existing value.\nIf val has a smaller length than the existing value for vn: replace existing value and mark the remaining indices as \"inactive\" by increasing the entry in vnv.num_inactive field.\nIf val has a larger length than the existing value for vn: expand the underlying vnv.vals to accommodate the new value, update all VarNames occuring after vn, and update the vnv.ranges to point to the new range for vn.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"This means that VarNamedVector is allowed to grow as needed, while \"shrinking\" (i.e. insertion of smaller elements) is handled by simply marking the redundant indices as \"inactive\". This turns out to be efficient for use-cases that we are generally interested in.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"For example, we want to optimize code-paths which effectively boil down to inner-loop in the following example:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"# Construct a `VarInfo` with types inferred from `model`.\nvarinfo = VarInfo(model)\n\n# Repeatedly sample from `model`.\nfor _ in 1:num_samples\n    rand!(rng, model, varinfo)\n\n    # Do something with `varinfo`.\n    # ...\nend","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"There are typically a few scenarios where we encounter changing representation sizes of a random variable x:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"We're working with a transformed version x which is represented in a lower-dimensional space, e.g. transforming a x ~ LKJ(2, 1) to unconstrained y = f(x) takes us from 2-by-2 Matrix{Float64} to a 1-length Vector{Float64}.\nx has a random size, e.g. in a mixture model with a prior on the number of components. Here the size of x can vary widly between every realization of the Model.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"In scenario (1), we're usually shrinking the representation of x, and so we end up not making any allocations for the underlying Vector{T} but instead just marking the redundant part as \"inactive\".","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"In scenario (2), we  end up increasing the allocated memory for the randomly sized x, eventually leading to a vector that is large enough to hold realizations without needing to reallocate. But this can still lead to unnecessary memory usage, which might be undesirable. Hence one has to make a decision regarding the trade-off between memory usage and performance for the use-case at hand.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"To help with this, we have the following functions:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"DynamicPPL.has_inactive\nDynamicPPL.num_inactive\nDynamicPPL.num_allocated\nDynamicPPL.is_contiguous\nDynamicPPL.contiguify!","category":"page"},{"location":"internals/varinfo/#DynamicPPL.has_inactive","page":"Design of VarInfo","title":"DynamicPPL.has_inactive","text":"has_inactive(vnv::VarNamedVector)\n\nReturns true if vnv has inactive entries.\n\nSee also: num_inactive\n\n\n\n\n\n","category":"function"},{"location":"internals/varinfo/#DynamicPPL.num_inactive","page":"Design of VarInfo","title":"DynamicPPL.num_inactive","text":"num_inactive(vnv::VarNamedVector)\n\nReturn the number of inactive entries in vnv.\n\nSee also: has_inactive, num_allocated\n\n\n\n\n\nnum_inactive(vnv::VarNamedVector, vn::VarName)\n\nReturns the number of inactive entries for vn in vnv.\n\n\n\n\n\n","category":"function"},{"location":"internals/varinfo/#DynamicPPL.num_allocated","page":"Design of VarInfo","title":"DynamicPPL.num_allocated","text":"num_allocated(vnv::VarNamedVector)\nnum_allocated(vnv::VarNamedVector[, vn::VarName])\nnum_allocated(vnv::VarNamedVector[, idx::Int])\n\nReturn the number of allocated entries in vnv, both active and inactive.\n\nIf either a VarName or an Int index is specified, only count entries allocated for that variable.\n\nAllocated entries take up memory in vnv.vals, but, if inactive, may not currently hold any meaningful data. One can remove them with contiguify!, but doing so may cause more memory allocations in the future if variables change dimension.\n\n\n\n\n\n","category":"function"},{"location":"internals/varinfo/#DynamicPPL.is_contiguous","page":"Design of VarInfo","title":"DynamicPPL.is_contiguous","text":"is_contiguous(vnv::VarNamedVector)\n\nReturns true if the underlying data of vnv is stored in a contiguous array.\n\nThis is equivalent to negating has_inactive(vnv).\n\n\n\n\n\n","category":"function"},{"location":"internals/varinfo/#DynamicPPL.contiguify!","page":"Design of VarInfo","title":"DynamicPPL.contiguify!","text":"contiguify!(vnv::VarNamedVector)\n\nRe-contiguify the underlying vector and shrink if possible.\n\nExamples\n\njulia> using DynamicPPL: VarNamedVector, @varname, contiguify!, update!, has_inactive\n\njulia> vnv = VarNamedVector(@varname(x) => [1.0, 2.0, 3.0], @varname(y) => [3.0]);\n\njulia> update!(vnv, [23.0, 24.0], @varname(x));\n\njulia> has_inactive(vnv)\ntrue\n\njulia> length(vnv.vals)\n4\n\njulia> contiguify!(vnv);\n\njulia> has_inactive(vnv)\nfalse\n\njulia> length(vnv.vals)\n3\n\njulia> vnv[@varname(x)]  # All the values are still there.\n2-element Vector{Float64}:\n 23.0\n 24.0\n\n\n\n\n\n","category":"function"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"For example, one might encounter the following scenario:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"vnv = DynamicPPL.VarNamedVector(@varname(x) => [true])\nprintln(\"Before insertion: number of allocated entries  $(DynamicPPL.num_allocated(vnv))\")\n\nfor i in 1:5\n    x = fill(true, rand(1:100))\n    DynamicPPL.update!(vnv, x, @varname(x))\n    println(\n        \"After insertion #$(i) of length $(length(x)): number of allocated entries  $(DynamicPPL.num_allocated(vnv))\",\n    )\nend","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"We can then insert a call to DynamicPPL.contiguify! after every insertion whenever the allocation grows too large to reduce overall memory usage:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"vnv = DynamicPPL.VarNamedVector(@varname(x) => [true])\nprintln(\"Before insertion: number of allocated entries  $(DynamicPPL.num_allocated(vnv))\")\n\nfor i in 1:5\n    x = fill(true, rand(1:100))\n    DynamicPPL.update!(vnv, x, @varname(x))\n    if DynamicPPL.num_allocated(vnv) > 10\n        DynamicPPL.contiguify!(vnv)\n    end\n    println(\n        \"After insertion #$(i) of length $(length(x)): number of allocated entries  $(DynamicPPL.num_allocated(vnv))\",\n    )\nend","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"This does incur a runtime cost as it requires re-allocation of the ranges in addition to a resize! of the underlying Vector{T}. However, this also ensures that the the underlying Vector{T} is contiguous, which is important for performance. Hence, if we're about to do a lot of work with the VarNamedVector without insertions, etc., it can be worth it to do a sweep to ensure that the underlying Vector{T} is contiguous.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"note: Note\nHigher-dimensional arrays, e.g. Matrix, are handled by simply vectorizing them before storing them in the Vector{T}, and composing the VarName's transformation with a DynamicPPL.ReshapeTransform.","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Continuing from the example from the previous section, we can use a VarInfo with a VarNamedVector as the metadata field:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"# Type-unstable\nvarinfo_untyped_vnv = DynamicPPL.VectorVarInfo(varinfo_untyped)\nvarinfo_untyped_vnv[@varname(x)], varinfo_untyped_vnv[@varname(y)]","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"# Type-stable\nvarinfo_typed_vnv = DynamicPPL.VectorVarInfo(varinfo_typed)\nvarinfo_typed_vnv[@varname(x)], varinfo_typed_vnv[@varname(y)]","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"If we now try to delete! @varname(x)","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"haskey(varinfo_untyped_vnv, @varname(x))","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"DynamicPPL.has_inactive(varinfo_untyped_vnv.metadata)","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"# `delete!`\nDynamicPPL.delete!(varinfo_untyped_vnv.metadata, @varname(x))\nDynamicPPL.has_inactive(varinfo_untyped_vnv.metadata)","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"haskey(varinfo_untyped_vnv, @varname(x))","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Or insert a differently-sized value for @varname(x)","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"DynamicPPL.insert!(varinfo_untyped_vnv.metadata, fill(true, 1), @varname(x))\nvarinfo_untyped_vnv[@varname(x)]","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"DynamicPPL.num_allocated(varinfo_untyped_vnv.metadata, @varname(x))","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"DynamicPPL.update!(varinfo_untyped_vnv.metadata, fill(true, 4), @varname(x))\nvarinfo_untyped_vnv[@varname(x)]","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"DynamicPPL.num_allocated(varinfo_untyped_vnv.metadata, @varname(x))","category":"page"},{"location":"internals/varinfo/#Performance-summary","page":"Design of VarInfo","title":"Performance summary","text":"","category":"section"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"In the end, we have the following \"rough\" performance characteristics for VarNamedVector:","category":"page"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"Method Is blazingly fast?\ngetindex colorgreen checkmark\nsetindex! on a new VarName colorgreen checkmark\ndelete! colorred times\nupdate! on existing VarName colorgreen checkmark if smaller or same size / colorred times if larger size\nvalues_as(::VarNamedVector, Vector{T}) colorgreen checkmark if contiguous / colororange div otherwise","category":"page"},{"location":"internals/varinfo/#Other-methods","page":"Design of VarInfo","title":"Other methods","text":"","category":"section"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"DynamicPPL.replace_raw_storage(::DynamicPPL.VarNamedVector, vals::AbstractVector)","category":"page"},{"location":"internals/varinfo/#DynamicPPL.replace_raw_storage-Tuple{DynamicPPL.VarNamedVector, AbstractVector}","page":"Design of VarInfo","title":"DynamicPPL.replace_raw_storage","text":"replace_raw_storage(vnv::VarNamedVector, vals::AbstractVector)\n\nReplace the values in vnv with vals, as they are stored internally.\n\nThis is useful when we want to update the entire underlying vector of values in one go or if we want to change the how the values are stored, e.g. alter the eltype.\n\nwarning: Warning\nThis replaces the raw underlying values, and so care should be taken when using this function. For example, if vnv has any inactive entries, then the provided vals should also contain the inactive entries to avoid unexpected behavior.\n\nExamples\n\njulia> using DynamicPPL: VarNamedVector, replace_raw_storage\n\njulia> vnv = VarNamedVector(@varname(x) => [1.0]);\n\njulia> replace_raw_storage(vnv, [2.0])[@varname(x)] == [2.0]\ntrue\n\nThis is also useful when we want to differentiate wrt. the values using automatic differentiation, e.g. ForwardDiff.jl.\n\njulia> using ForwardDiff: ForwardDiff\n\njulia> f(x) = sum(abs2, replace_raw_storage(vnv, x)[@varname(x)])\nf (generic function with 1 method)\n\njulia> ForwardDiff.gradient(f, [1.0])\n1-element Vector{Float64}:\n 2.0\n\n\n\n\n\n","category":"method"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"DynamicPPL.values_as(::DynamicPPL.VarNamedVector)","category":"page"},{"location":"internals/varinfo/#DynamicPPL.values_as-Tuple{DynamicPPL.VarNamedVector}-internals-varinfo","page":"Design of VarInfo","title":"DynamicPPL.values_as","text":"values_as(vnv::VarNamedVector[, T])\n\nReturn the values/realizations in vnv as type T, if implemented.\n\nIf no type T is provided, return values as stored in vnv.\n\nExamples\n\njulia> using DynamicPPL: VarNamedVector\n\njulia> vnv = VarNamedVector(@varname(x) => 1, @varname(y) => [2.0]);\n\njulia> values_as(vnv) == [1.0, 2.0]\ntrue\n\njulia> values_as(vnv, Vector{Float32}) == Vector{Float32}([1.0, 2.0])\ntrue\n\njulia> values_as(vnv, OrderedDict) == OrderedDict(@varname(x) => 1.0, @varname(y) => [2.0])\ntrue\n\njulia> values_as(vnv, NamedTuple) == (x = 1.0, y = [2.0])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"internals/varinfo/","page":"Design of VarInfo","title":"Design of VarInfo","text":"","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Part of the API of DynamicPPL is defined in the more lightweight interface package AbstractPPL.jl and reexported here.","category":"page"},{"location":"api/#Model","page":"API","title":"Model","text":"","category":"section"},{"location":"api/#Macros","page":"API","title":"Macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A core component of DynamicPPL is the @model macro. It can be used to define probabilistic models in an intuitive way by specifying random variables and their distributions with ~ statements. These statements are rewritten by @model as calls of internal functions for sampling the variables and computing their log densities.","category":"page"},{"location":"api/","page":"API","title":"API","text":"@model","category":"page"},{"location":"api/#DynamicPPL.@model","page":"API","title":"DynamicPPL.@model","text":"@model(expr[, warn = false])\n\nMacro to specify a probabilistic model.\n\nIf warn is true, a warning is displayed if internal variable names are used in the model definition.\n\nExamples\n\nModel definition:\n\n@model function model(x, y = 42)\n    ...\nend\n\nTo generate a Model, call model(xvalue) or model(xvalue, yvalue).\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"One can nest models and call another model inside the model function with @submodel.","category":"page"},{"location":"api/","page":"API","title":"API","text":"@submodel","category":"page"},{"location":"api/#DynamicPPL.@submodel","page":"API","title":"DynamicPPL.@submodel","text":"@submodel model\n@submodel ... = model\n\nRun a Turing model nested inside of a Turing model.\n\nExamples\n\njulia> @model function demo1(x)\n           x ~ Normal()\n           return 1 + abs(x)\n       end;\n\njulia> @model function demo2(x, y)\n            @submodel a = demo1(x)\n            return y ~ Uniform(0, a)\n       end;\n\nWhen we sample from the model demo2(missing, 0.4) random variable x will be sampled:\n\njulia> vi = VarInfo(demo2(missing, 0.4));\n\njulia> @varname(x) in keys(vi)\ntrue\n\nVariable a is not tracked since it can be computed from the random variable x that was tracked when running demo1:\n\njulia> @varname(a) in keys(vi)\nfalse\n\nWe can check that the log joint probability of the model accumulated in vi is correct:\n\njulia> x = vi[@varname(x)];\n\njulia> getlogp(vi) ≈ logpdf(Normal(), x) + logpdf(Uniform(0, 1 + abs(x)), 0.4)\ntrue\n\n\n\n\n\n@submodel prefix=... model\n@submodel prefix=... ... = model\n\nRun a Turing model nested inside of a Turing model and add \"prefix.\" as a prefix to all random variables inside of the model.\n\nValid expressions for prefix=... are:\n\nprefix=false: no prefix is used.\nprefix=true: attempt to automatically determine the prefix from the left-hand side ... = model by first converting into a VarName, and then calling Symbol on this.\nprefix=expression: results in the prefix Symbol(expression).\n\nThe prefix makes it possible to run the same Turing model multiple times while keeping track of all random variables correctly.\n\nExamples\n\nExample models\n\njulia> @model function demo1(x)\n           x ~ Normal()\n           return 1 + abs(x)\n       end;\n\njulia> @model function demo2(x, y, z)\n            @submodel prefix=\"sub1\" a = demo1(x)\n            @submodel prefix=\"sub2\" b = demo1(y)\n            return z ~ Uniform(-a, b)\n       end;\n\nWhen we sample from the model demo2(missing, missing, 0.4) random variables sub1.x and sub2.x will be sampled:\n\njulia> vi = VarInfo(demo2(missing, missing, 0.4));\n\njulia> @varname(var\"sub1.x\") in keys(vi)\ntrue\n\njulia> @varname(var\"sub2.x\") in keys(vi)\ntrue\n\nVariables a and b are not tracked since they can be computed from the random variables sub1.x and sub2.x that were tracked when running demo1:\n\njulia> @varname(a) in keys(vi)\nfalse\n\njulia> @varname(b) in keys(vi)\nfalse\n\nWe can check that the log joint probability of the model accumulated in vi is correct:\n\njulia> sub1_x = vi[@varname(var\"sub1.x\")];\n\njulia> sub2_x = vi[@varname(var\"sub2.x\")];\n\njulia> logprior = logpdf(Normal(), sub1_x) + logpdf(Normal(), sub2_x);\n\njulia> loglikelihood = logpdf(Uniform(-1 - abs(sub1_x), 1 + abs(sub2_x)), 0.4);\n\njulia> getlogp(vi) ≈ logprior + loglikelihood\ntrue\n\nDifferent ways of setting the prefix\n\njulia> @model inner() = x ~ Normal()\ninner (generic function with 2 methods)\n\njulia> # When `prefix` is unspecified, no prefix is used.\n       @model submodel_noprefix() = @submodel a = inner()\nsubmodel_noprefix (generic function with 2 methods)\n\njulia> @varname(x) in keys(VarInfo(submodel_noprefix()))\ntrue\n\njulia> # Explicitely don't use any prefix.\n       @model submodel_prefix_false() = @submodel prefix=false a = inner()\nsubmodel_prefix_false (generic function with 2 methods)\n\njulia> @varname(x) in keys(VarInfo(submodel_prefix_false()))\ntrue\n\njulia> # Automatically determined from `a`.\n       @model submodel_prefix_true() = @submodel prefix=true a = inner()\nsubmodel_prefix_true (generic function with 2 methods)\n\njulia> @varname(var\"a.x\") in keys(VarInfo(submodel_prefix_true()))\ntrue\n\njulia> # Using a static string.\n       @model submodel_prefix_string() = @submodel prefix=\"my prefix\" a = inner()\nsubmodel_prefix_string (generic function with 2 methods)\n\njulia> @varname(var\"my prefix.x\") in keys(VarInfo(submodel_prefix_string()))\ntrue\n\njulia> # Using string interpolation.\n       @model submodel_prefix_interpolation() = @submodel prefix=\"$(nameof(inner()))\" a = inner()\nsubmodel_prefix_interpolation (generic function with 2 methods)\n\njulia> @varname(var\"inner.x\") in keys(VarInfo(submodel_prefix_interpolation()))\ntrue\n\njulia> # Or using some arbitrary expression.\n       @model submodel_prefix_expr() = @submodel prefix=1 + 2 a = inner()\nsubmodel_prefix_expr (generic function with 2 methods)\n\njulia> @varname(var\"3.x\") in keys(VarInfo(submodel_prefix_expr()))\ntrue\n\njulia> # (×) Automatic prefixing without a left-hand side expression does not work!\n       @model submodel_prefix_error() = @submodel prefix=true inner()\nERROR: LoadError: cannot automatically prefix with no left-hand side\n[...]\n\nNotes\n\nThe choice prefix=expression means that the prefixing will incur a runtime cost. This is also the case for prefix=true, depending on whether the expression on the the right-hand side of ... = model requires runtime-information or not, e.g. x = model will result in the static prefix x, while x[i] = model will be resolved at runtime.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Type","page":"API","title":"Type","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Model can be created by calling the model function, as defined by @model.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Model","category":"page"},{"location":"api/#DynamicPPL.Model","page":"API","title":"DynamicPPL.Model","text":"struct Model{F,argnames,defaultnames,missings,Targs,Tdefaults,Ctx<:AbstactContext}\n    f::F\n    args::NamedTuple{argnames,Targs}\n    defaults::NamedTuple{defaultnames,Tdefaults}\n    context::Ctx=DefaultContext()\nend\n\nA Model struct with model evaluation function of type F, arguments of names argnames types Targs, default arguments of names defaultnames with types Tdefaults, missing arguments missings, and evaluation context of type Ctx.\n\nHere argnames, defaultargnames, and missings are tuples of symbols, e.g. (:a, :b). context is by default DefaultContext().\n\nAn argument with a type of Missing will be in missings by default. However, in non-traditional use-cases missings can be defined differently. All variables in missings are treated as random variables rather than observations.\n\nThe default arguments are used internally when constructing instances of the same model with different arguments.\n\nExamples\n\njulia> Model(f, (x = 1.0, y = 2.0))\nModel{typeof(f),(:x, :y),(),(),Tuple{Float64,Float64},Tuple{}}(f, (x = 1.0, y = 2.0), NamedTuple())\n\njulia> Model(f, (x = 1.0, y = 2.0), (x = 42,))\nModel{typeof(f),(:x, :y),(:x,),(),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))\n\njulia> Model{(:y,)}(f, (x = 1.0, y = 2.0), (x = 42,)) # with special definition of missings\nModel{typeof(f),(:x, :y),(:x,),(:y,),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Models are callable structs.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Model()","category":"page"},{"location":"api/#DynamicPPL.Model-Tuple{}","page":"API","title":"DynamicPPL.Model","text":"(model::Model)([rng, varinfo, sampler, context])\n\nSample from the model using the sampler with random number generator rng and the context, and store the sample and log joint probability in varinfo.\n\nThe method resets the log joint probability of varinfo and increases the evaluation number of sampler.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Basic properties of a model can be accessed with getargnames, getmissings, and nameof.","category":"page"},{"location":"api/","page":"API","title":"API","text":"nameof(::Model)\ngetargnames\ngetmissings","category":"page"},{"location":"api/#Base.nameof-Tuple{Model}","page":"API","title":"Base.nameof","text":"nameof(model::Model)\n\nGet the name of the model as Symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicPPL.getargnames","page":"API","title":"DynamicPPL.getargnames","text":"getargnames(model::Model)\n\nGet a tuple of the argument names of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.getmissings","page":"API","title":"DynamicPPL.getmissings","text":"getmissings(model::Model)\n\nGet a tuple of the names of the missing arguments of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Evaluation","page":"API","title":"Evaluation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"With rand one can draw samples from the prior distribution of a Model.","category":"page"},{"location":"api/","page":"API","title":"API","text":"rand","category":"page"},{"location":"api/#Base.rand","page":"API","title":"Base.rand","text":"rand([rng=Random.default_rng()], [T=NamedTuple], model::Model)\n\nGenerate a sample of type T from the prior distribution of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"One can also evaluate the log prior, log likelihood, and log joint probability.","category":"page"},{"location":"api/","page":"API","title":"API","text":"logprior\nloglikelihood\nlogjoint","category":"page"},{"location":"api/#DynamicPPL.logprior","page":"API","title":"DynamicPPL.logprior","text":"logprior(model::Model, varinfo::AbstractVarInfo)\n\nReturn the log prior probability of variables varinfo for the probabilistic model.\n\nSee also logjoint and loglikelihood.\n\n\n\n\n\nlogprior(model::Model, chain::AbstractMCMC.AbstractChains)\n\nReturn an array of log prior probabilities evaluated at each sample in an MCMC chain.\n\nExamples\n\njulia> using MCMCChains, Distributions\n\njulia> @model function demo_model(x)\n           s ~ InverseGamma(2, 3)\n           m ~ Normal(0, sqrt(s))\n           for i in eachindex(x)\n               x[i] ~ Normal(m, sqrt(s))\n           end\n       end;\n\njulia> # construct a chain of samples using MCMCChains\n       chain = Chains(rand(10, 2, 3), [:s, :m]);\n\njulia> logprior(demo_model([1., 2.]), chain);\n\n\n\n\n\nlogprior(model::Model, θ)\n\nReturn the log prior probability of variables θ for the probabilistic model.\n\nSee also logjoint and loglikelihood.\n\nExamples\n\njulia> @model function demo(x)\n           m ~ Normal()\n           for i in eachindex(x)\n               x[i] ~ Normal(m, 1.0)\n           end\n       end\ndemo (generic function with 2 methods)\n\njulia> # Using a `NamedTuple`.\n       logprior(demo([1.0]), (m = 100.0, ))\n-5000.918938533205\n\njulia> # Using a `OrderedDict`.\n       logprior(demo([1.0]), OrderedDict(@varname(m) => 100.0))\n-5000.918938533205\n\njulia> # Truth.\n       logpdf(Normal(), 100.0)\n-5000.918938533205\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.loglikelihood","page":"API","title":"StatsAPI.loglikelihood","text":"loglikelihood(model::Model, varinfo::AbstractVarInfo)\n\nReturn the log likelihood of variables varinfo for the probabilistic model.\n\nSee also logjoint and logprior.\n\n\n\n\n\nloglikelihood(model::Model, chain::AbstractMCMC.AbstractChains)\n\nReturn an array of log likelihoods evaluated at each sample in an MCMC chain.\n\nExamples\n\njulia> using MCMCChains, Distributions\n\njulia> @model function demo_model(x)\n           s ~ InverseGamma(2, 3)\n           m ~ Normal(0, sqrt(s))\n           for i in eachindex(x)\n               x[i] ~ Normal(m, sqrt(s))\n           end\n       end;\n\njulia> # construct a chain of samples using MCMCChains\n       chain = Chains(rand(10, 2, 3), [:s, :m]);\n\njulia> loglikelihood(demo_model([1., 2.]), chain);\n\n\n\n\n\nloglikelihood(model::Model, θ)\n\nReturn the log likelihood of variables θ for the probabilistic model.\n\nSee also logjoint and logprior.\n\nExamples\n\njulia> @model function demo(x)\n           m ~ Normal()\n           for i in eachindex(x)\n               x[i] ~ Normal(m, 1.0)\n           end\n       end\ndemo (generic function with 2 methods)\n\njulia> # Using a `NamedTuple`.\n       loglikelihood(demo([1.0]), (m = 100.0, ))\n-4901.418938533205\n\njulia> # Using a `OrderedDict`.\n       loglikelihood(demo([1.0]), OrderedDict(@varname(m) => 100.0))\n-4901.418938533205\n\njulia> # Truth.\n       logpdf(Normal(100.0, 1.0), 1.0)\n-4901.418938533205\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.logjoint","page":"API","title":"DynamicPPL.logjoint","text":"logjoint(model::Model, varinfo::AbstractVarInfo)\n\nReturn the log joint probability of variables varinfo for the probabilistic model.\n\nSee logprior and loglikelihood.\n\n\n\n\n\nlogjoint(model::Model, chain::AbstractMCMC.AbstractChains)\n\nReturn an array of log joint probabilities evaluated at each sample in an MCMC chain.\n\nExamples\n\njulia> using MCMCChains, Distributions\n\njulia> @model function demo_model(x)\n           s ~ InverseGamma(2, 3)\n           m ~ Normal(0, sqrt(s))\n           for i in eachindex(x)\n               x[i] ~ Normal(m, sqrt(s))\n           end\n       end;\n\njulia> # construct a chain of samples using MCMCChains\n       chain = Chains(rand(10, 2, 3), [:s, :m]);\n\njulia> logjoint(demo_model([1., 2.]), chain);\n\n\n\n\n\nlogjoint(model::Model, θ)\n\nReturn the log joint probability of variables θ for the probabilistic model.\n\nSee logprior and loglikelihood.\n\nExamples\n\njulia> @model function demo(x)\n           m ~ Normal()\n           for i in eachindex(x)\n               x[i] ~ Normal(m, 1.0)\n           end\n       end\ndemo (generic function with 2 methods)\n\njulia> # Using a `NamedTuple`.\n       logjoint(demo([1.0]), (m = 100.0, ))\n-9902.33787706641\n\njulia> # Using a `OrderedDict`.\n       logjoint(demo([1.0]), OrderedDict(@varname(m) => 100.0))\n-9902.33787706641\n\njulia> # Truth.\n       logpdf(Normal(100.0, 1.0), 1.0) + logpdf(Normal(), 100.0)\n-9902.33787706641\n\n\n\n\n\n","category":"function"},{"location":"api/#LogDensityProblems.jl-interface","page":"API","title":"LogDensityProblems.jl interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The LogDensityProblems.jl interface is also supported by simply wrapping a Model in a DynamicPPL.LogDensityFunction:","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.LogDensityFunction","category":"page"},{"location":"api/#DynamicPPL.LogDensityFunction","page":"API","title":"DynamicPPL.LogDensityFunction","text":"LogDensityFunction\n\nA callable representing a log density function of a model.\n\nFields\n\nvarinfo: varinfo used for evaluation\nmodel: model used for evaluation\ncontext: context used for evaluation; if nothing, leafcontext(model.context) will be used when applicable\n\nExamples\n\njulia> using Distributions\n\njulia> using DynamicPPL: LogDensityFunction, contextualize\n\njulia> @model function demo(x)\n           m ~ Normal()\n           x ~ Normal(m, 1)\n       end\ndemo (generic function with 2 methods)\n\njulia> model = demo(1.0);\n\njulia> f = LogDensityFunction(model);\n\njulia> # It implements the interface of LogDensityProblems.jl.\n       using LogDensityProblems\n\njulia> LogDensityProblems.logdensity(f, [0.0])\n-2.3378770664093453\n\njulia> LogDensityProblems.dimension(f)\n1\n\njulia> # By default it uses `VarInfo` under the hood, but this is not necessary.\n       f = LogDensityFunction(model, SimpleVarInfo(model));\n\njulia> LogDensityProblems.logdensity(f, [0.0])\n-2.3378770664093453\n\njulia> # This also respects the context in `model`.\n       f_prior = LogDensityFunction(contextualize(model, DynamicPPL.PriorContext()), VarInfo(model));\n\njulia> LogDensityProblems.logdensity(f_prior, [0.0]) == logpdf(Normal(), 0.0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/#Condition-and-decondition","page":"API","title":"Condition and decondition","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Model can be conditioned on a set of observations with AbstractPPL.condition or its alias |.","category":"page"},{"location":"api/","page":"API","title":"API","text":"|(::Model, ::Any)\ncondition\nDynamicPPL.conditioned","category":"page"},{"location":"api/#Base.:|-Tuple{Model, Any}","page":"API","title":"Base.:|","text":"model | (x = 1.0, ...)\n\nReturn a Model which now treats variables on the right-hand side as observations.\n\nSee condition for more information and examples.\n\n\n\n\n\n","category":"method"},{"location":"api/#AbstractPPL.condition","page":"API","title":"AbstractPPL.condition","text":"condition(model::Model; values...)\ncondition(model::Model, values::NamedTuple)\n\nReturn a Model which now treats the variables in values as observations.\n\nSee also: decondition, conditioned\n\nLimitations\n\nThis does currently not work with variables that are provided to the model as arguments, e.g. @model function demo(x) ... end means that condition will not affect the variable x.\n\nTherefore if one wants to make use of condition and decondition one should not be specifying any random variables as arguments.\n\nThis is done for the sake of backwards compatibility.\n\nExamples\n\nSimple univariate model\n\njulia> using Distributions\n\njulia> @model function demo()\n           m ~ Normal()\n           x ~ Normal(m, 1)\n           return (; m=m, x=x)\n       end\ndemo (generic function with 2 methods)\n\njulia> model = demo();\n\njulia> m, x = model(); (m ≠ 1.0 && x ≠ 100.0)\ntrue\n\njulia> # Create a new instance which treats `x` as observed\n       # with value `100.0`, and similarly for `m=1.0`.\n       conditioned_model = condition(model, x=100.0, m=1.0);\n\njulia> m, x = conditioned_model(); (m == 1.0 && x == 100.0)\ntrue\n\njulia> # Let's only condition on `x = 100.0`.\n       conditioned_model = condition(model, x = 100.0);\n\njulia> m, x =conditioned_model(); (m ≠ 1.0 && x == 100.0)\ntrue\n\njulia> # We can also use the nicer `|` syntax.\n       conditioned_model = model | (x = 100.0, );\n\njulia> m, x = conditioned_model(); (m ≠ 1.0 && x == 100.0)\ntrue\n\nThe above uses a NamedTuple to hold the conditioning variables, which allows us to perform some additional optimizations; in many cases, the above has zero runtime-overhead.\n\nBut we can also use a Dict, which offers more flexibility in the conditioning (see examples further below) but generally has worse performance than the NamedTuple approach:\n\njulia> conditioned_model_dict = condition(model, Dict(@varname(x) => 100.0));\n\njulia> m, x = conditioned_model_dict(); (m ≠ 1.0 && x == 100.0)\ntrue\n\njulia> # There's also an option using `|` by letting the right-hand side be a tuple\n       # with elements of type `Pair{<:VarName}`, i.e. `vn => value` with `vn isa VarName`.\n       conditioned_model_dict = model | (@varname(x) => 100.0, );\n\njulia> m, x = conditioned_model_dict(); (m ≠ 1.0 && x == 100.0)\ntrue\n\nCondition only a part of a multivariate variable\n\nNot only can be condition on multivariate random variables, but we can also use the standard mechanism of setting something to missing in the call to condition to only condition on a part of the variable.\n\njulia> @model function demo_mv(::Type{TV}=Float64) where {TV}\n           m = Vector{TV}(undef, 2)\n           m[1] ~ Normal()\n           m[2] ~ Normal()\n           return m\n       end\ndemo_mv (generic function with 4 methods)\n\njulia> model = demo_mv();\n\njulia> conditioned_model = condition(model, m = [missing, 1.0]);\n\njulia> # (✓) `m[1]` sampled while `m[2]` is fixed\n       m = conditioned_model(); (m[1] ≠ 1.0 && m[2] == 1.0)\ntrue\n\nIntuitively one might also expect to be able to write model | (m[1] = 1.0, ). Unfortunately this is not supported as it has the potential of increasing compilation times but without offering any benefit with respect to runtime:\n\njulia> # (×) `m[2]` is not set to 1.0.\n       m = condition(model, var\"m[2]\" = 1.0)(); m[2] == 1.0\nfalse\n\nBut you can do this if you use a Dict as the underlying storage instead:\n\njulia> # Alternatives:\n       # - `model | (@varname(m[2]) => 1.0,)`\n       # - `condition(model, Dict(@varname(m[2] => 1.0)))`\n       # (✓) `m[2]` is set to 1.0.\n       m = condition(model, @varname(m[2]) => 1.0)(); (m[1] ≠ 1.0 && m[2] == 1.0)\ntrue\n\nNested models\n\ncondition of course also supports the use of nested models through the use of @submodel.\n\njulia> @model demo_inner() = m ~ Normal()\ndemo_inner (generic function with 2 methods)\n\njulia> @model function demo_outer()\n           @submodel m = demo_inner()\n           return m\n       end\ndemo_outer (generic function with 2 methods)\n\njulia> model = demo_outer();\n\njulia> model() ≠ 1.0\ntrue\n\njulia> conditioned_model = model | (m = 1.0, );\n\njulia> conditioned_model()\n1.0\n\nBut one needs to be careful when prefixing variables in the nested models:\n\njulia> @model function demo_outer_prefix()\n           @submodel prefix=\"inner\" m = demo_inner()\n           return m\n       end\ndemo_outer_prefix (generic function with 2 methods)\n\njulia> # (×) This doesn't work now!\n       conditioned_model = demo_outer_prefix() | (m = 1.0, );\n\njulia> conditioned_model() == 1.0\nfalse\n\njulia> # (✓) `m` in `demo_inner` is referred to as `inner.m` internally, so we do:\n       conditioned_model = demo_outer_prefix() | (var\"inner.m\" = 1.0, );\n\njulia> conditioned_model()\n1.0\n\njulia> # Note that the above `var\"...\"` is just standard Julia syntax:\n       keys((var\"inner.m\" = 1.0, ))\n(Symbol(\"inner.m\"),)\n\nAnd similarly when using Dict:\n\njulia> conditioned_model_dict = demo_outer_prefix() | (@varname(var\"inner.m\") => 1.0);\n\njulia> conditioned_model_dict()\n1.0\n\nThe difference is maybe more obvious once we look at how these different in their trace/VarInfo:\n\njulia> keys(VarInfo(demo_outer()))\n1-element Vector{VarName{:m, typeof(identity)}}:\n m\n\njulia> keys(VarInfo(demo_outer_prefix()))\n1-element Vector{VarName{Symbol(\"inner.m\"), typeof(identity)}}:\n inner.m\n\nFrom this we can tell what the correct way to condition m within demo_inner is in the two different models.\n\n\n\n\n\ncondition([context::AbstractContext,] values::NamedTuple)\ncondition([context::AbstractContext]; values...)\n\nReturn ConditionContext with values and context if values is non-empty, otherwise return context which is DefaultContext by default.\n\nSee also: decondition\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.conditioned","page":"API","title":"DynamicPPL.conditioned","text":"conditioned(model::Model)\n\nReturn the conditioned values in model.\n\nExamples\n\njulia> using Distributions\n\njulia> using DynamicPPL: conditioned, contextualize\n\njulia> @model function demo()\n           m ~ Normal()\n           x ~ Normal(m, 1)\n       end\ndemo (generic function with 2 methods)\n\njulia> m = demo();\n\njulia> # Returns all the variables we have conditioned on + their values.\n       conditioned(condition(m, x=100.0, m=1.0))\n(x = 100.0, m = 1.0)\n\njulia> # Nested ones also work (note that `PrefixContext` does nothing to the result).\n       cm = condition(contextualize(m, PrefixContext{:a}(condition(m=1.0))), x=100.0);\n\njulia> conditioned(cm)\n(x = 100.0, m = 1.0)\n\njulia> # Since we conditioned on `m`, not `a.m` as it will appear after prefixed,\n       # `a.m` is treated as a random variable.\n       keys(VarInfo(cm))\n1-element Vector{VarName{Symbol(\"a.m\"), typeof(identity)}}:\n a.m\n\njulia> # If we instead condition on `a.m`, `m` in the model will be considered an observation.\n       cm = condition(contextualize(m, PrefixContext{:a}(condition(var\"a.m\"=1.0))), x=100.0);\n\njulia> conditioned(cm).x\n100.0\n\njulia> conditioned(cm).var\"a.m\"\n1.0\n\njulia> keys(VarInfo(cm)) # <= no variables are sampled\nVarName[]\n\n\n\n\n\nconditioned(context::AbstractContext)\n\nReturn NamedTuple of values that are conditioned on under context`.\n\nNote that this will recursively traverse the context stack and return a merged version of the condition values.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Similarly, one can specify with AbstractPPL.decondition that certain, or all, random variables are not observed.","category":"page"},{"location":"api/","page":"API","title":"API","text":"decondition","category":"page"},{"location":"api/#AbstractPPL.decondition","page":"API","title":"AbstractPPL.decondition","text":"decondition(model::Model)\ndecondition(model::Model, variables...)\n\nReturn a Model for which variables... are not considered observations. If no variables are provided, then all variables currently considered observations will no longer be.\n\nThis is essentially the inverse of condition. This also means that it suffers from the same limitiations.\n\nNote that currently we only support variables to take on explicit values provided to condition.\n\nExamples\n\njulia> using Distributions\n\njulia> @model function demo()\n           m ~ Normal()\n           x ~ Normal(m, 1)\n           return (; m=m, x=x)\n       end\ndemo (generic function with 2 methods)\n\njulia> conditioned_model = condition(demo(), m = 1.0, x = 10.0);\n\njulia> conditioned_model()\n(m = 1.0, x = 10.0)\n\njulia> # By specifying the `VarName` to `decondition`.\n       model = decondition(conditioned_model, @varname(m));\n\njulia> (m, x) = model(); (m ≠ 1.0 && x == 10.0)\ntrue\n\njulia> # When `NamedTuple` is used as the underlying, you can also provide\n       # the symbol directly (though the `@varname` approach is preferable if\n       # if the variable is known at compile-time).\n       model = decondition(conditioned_model, :m);\n\njulia> (m, x) = model(); (m ≠ 1.0 && x == 10.0)\ntrue\n\njulia> # `decondition` multiple at once:\n       (m, x) = decondition(model, :m, :x)(); (m ≠ 1.0 && x ≠ 10.0)\ntrue\n\njulia> # `decondition` without any symbols will `decondition` all variables.\n       (m, x) = decondition(model)(); (m ≠ 1.0 && x ≠ 10.0)\ntrue\n\njulia> # Usage of `Val` to perform `decondition` at compile-time if possible\n       # is also supported.\n       model = decondition(conditioned_model, Val{:m}());\n\njulia> (m, x) = model(); (m ≠ 1.0 && x == 10.0)\ntrue\n\nSimilarly when using a Dict:\n\njulia> conditioned_model_dict = condition(demo(), @varname(m) => 1.0, @varname(x) => 10.0);\n\njulia> conditioned_model_dict()\n(m = 1.0, x = 10.0)\n\njulia> deconditioned_model_dict = decondition(conditioned_model_dict, @varname(m));\n\njulia> (m, x) = deconditioned_model_dict(); m ≠ 1.0 && x == 10.0\ntrue\n\nBut, as mentioned, decondition is only supported for variables explicitly provided to condition earlier;\n\njulia> @model function demo_mv(::Type{TV}=Float64) where {TV}\n           m = Vector{TV}(undef, 2)\n           m[1] ~ Normal()\n           m[2] ~ Normal()\n           return m\n       end\ndemo_mv (generic function with 4 methods)\n\njulia> model = demo_mv();\n\njulia> conditioned_model = condition(model, @varname(m) => [1.0, 2.0]);\n\njulia> conditioned_model()\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> deconditioned_model = decondition(conditioned_model, @varname(m[1]));\n\njulia> deconditioned_model()  # (×) `m[1]` is still conditioned\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> # (✓) this works though\n       deconditioned_model_2 = deconditioned_model | (@varname(m[1]) => missing);\n\njulia> m = deconditioned_model_2(); (m[1] ≠ 1.0 && m[2] == 2.0)\ntrue\n\n\n\n\n\ndecondition(context::AbstractContext, syms...)\n\nReturn context but with syms no longer conditioned on.\n\nNote that this recursively traverses contexts, deconditioning all along the way.\n\nSee also: condition\n\n\n\n\n\n","category":"function"},{"location":"api/#Fixing-and-unfixing","page":"API","title":"Fixing and unfixing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"We can also fix a collection of variables in a Model to certain using fix.","category":"page"},{"location":"api/","page":"API","title":"API","text":"This might seem quite similar to the aforementioned condition and its siblings, but they are indeed different operations:","category":"page"},{"location":"api/","page":"API","title":"API","text":"conditioned variables are considered to be observations, and are thus included in the computation logjoint and loglikelihood, but not in logprior.\nfixed variables are considered to be constant, and are thus not included in any log-probability computations.","category":"page"},{"location":"api/","page":"API","title":"API","text":"The differences are more clearly spelled out in the docstring of fix below.","category":"page"},{"location":"api/","page":"API","title":"API","text":"fix\nDynamicPPL.fixed","category":"page"},{"location":"api/#DynamicPPL.fix","page":"API","title":"DynamicPPL.fix","text":"fix(model::Model; values...)\nfix(model::Model, values::NamedTuple)\n\nReturn a Model which now treats the variables in values as fixed.\n\nSee also: unfix, fixed\n\nExamples\n\nSimple univariate model\n\njulia> using Distributions\n\njulia> @model function demo()\n           m ~ Normal()\n           x ~ Normal(m, 1)\n           return (; m=m, x=x)\n       end\ndemo (generic function with 2 methods)\n\njulia> model = demo();\n\njulia> m, x = model(); (m ≠ 1.0 && x ≠ 100.0)\ntrue\n\njulia> # Create a new instance which treats `x` as observed\n       # with value `100.0`, and similarly for `m=1.0`.\n       fixed_model = fix(model, x=100.0, m=1.0);\n\njulia> m, x = fixed_model(); (m == 1.0 && x == 100.0)\ntrue\n\njulia> # Let's only fix on `x = 100.0`.\n       fixed_model = fix(model, x = 100.0);\n\njulia> m, x = fixed_model(); (m ≠ 1.0 && x == 100.0)\ntrue\n\nThe above uses a NamedTuple to hold the fixed variables, which allows us to perform some additional optimizations; in many cases, the above has zero runtime-overhead.\n\nBut we can also use a Dict, which offers more flexibility in the fixing (see examples further below) but generally has worse performance than the NamedTuple approach:\n\njulia> fixed_model_dict = fix(model, Dict(@varname(x) => 100.0));\n\njulia> m, x = fixed_model_dict(); (m ≠ 1.0 && x == 100.0)\ntrue\n\njulia> # Alternative: pass `Pair{<:VarName}` as positional argument.\n       fixed_model_dict = fix(model, @varname(x) => 100.0, );\n\njulia> m, x = fixed_model_dict(); (m ≠ 1.0 && x == 100.0)\ntrue\n\nFix only a part of a multivariate variable\n\nWe can not only fix multivariate random variables, but we can also use the standard mechanism of setting something to missing in the call to fix to only fix a part of the variable.\n\njulia> @model function demo_mv(::Type{TV}=Float64) where {TV}\n           m = Vector{TV}(undef, 2)\n           m[1] ~ Normal()\n           m[2] ~ Normal()\n           return m\n       end\ndemo_mv (generic function with 4 methods)\n\njulia> model = demo_mv();\n\njulia> fixed_model = fix(model, m = [missing, 1.0]);\n\njulia> # (✓) `m[1]` sampled while `m[2]` is fixed\n       m = fixed_model(); (m[1] ≠ 1.0 && m[2] == 1.0)\ntrue\n\nIntuitively one might also expect to be able to write something like fix(model, var\"m[1]\" = 1.0, ). Unfortunately this is not supported as it has the potential of increasing compilation times but without offering any benefit with respect to runtime:\n\njulia> # (×) `m[2]` is not set to 1.0.\n       m = fix(model, var\"m[2]\" = 1.0)(); m[2] == 1.0\nfalse\n\nBut you can do this if you use a Dict as the underlying storage instead:\n\njulia> # Alternative: `fix(model, Dict(@varname(m[2] => 1.0)))`\n       # (✓) `m[2]` is set to 1.0.\n       m = fix(model, @varname(m[2]) => 1.0)(); (m[1] ≠ 1.0 && m[2] == 1.0)\ntrue\n\nNested models\n\nfix of course also supports the use of nested models through the use of @submodel.\n\njulia> @model demo_inner() = m ~ Normal()\ndemo_inner (generic function with 2 methods)\n\njulia> @model function demo_outer()\n           @submodel m = demo_inner()\n           return m\n       end\ndemo_outer (generic function with 2 methods)\n\njulia> model = demo_outer();\n\njulia> model() ≠ 1.0\ntrue\n\njulia> fixed_model = model | (m = 1.0, );\n\njulia> fixed_model()\n1.0\n\nBut one needs to be careful when prefixing variables in the nested models:\n\njulia> @model function demo_outer_prefix()\n           @submodel prefix=\"inner\" m = demo_inner()\n           return m\n       end\ndemo_outer_prefix (generic function with 2 methods)\n\njulia> # (×) This doesn't work now!\n       fixed_model = demo_outer_prefix() | (m = 1.0, );\n\njulia> fixed_model() == 1.0\nfalse\n\njulia> # (✓) `m` in `demo_inner` is referred to as `inner.m` internally, so we do:\n       fixed_model = demo_outer_prefix() | (var\"inner.m\" = 1.0, );\n\njulia> fixed_model()\n1.0\n\njulia> # Note that the above `var\"...\"` is just standard Julia syntax:\n       keys((var\"inner.m\" = 1.0, ))\n(Symbol(\"inner.m\"),)\n\nAnd similarly when using Dict:\n\njulia> fixed_model_dict = demo_outer_prefix() | (@varname(var\"inner.m\") => 1.0);\n\njulia> fixed_model_dict()\n1.0\n\nThe difference is maybe more obvious once we look at how these different in their trace/VarInfo:\n\njulia> keys(VarInfo(demo_outer()))\n1-element Vector{VarName{:m, typeof(identity)}}:\n m\n\njulia> keys(VarInfo(demo_outer_prefix()))\n1-element Vector{VarName{Symbol(\"inner.m\"), typeof(identity)}}:\n inner.m\n\nFrom this we can tell what the correct way to fix m within demo_inner is in the two different models.\n\nDifference from condition\n\nA very similar functionality is also provided by condition which, not surprisingly, conditions variables instead of fixing them. The only difference between fixing and conditioning is as follows:\n\nconditioned variables are considered to be observations, and are thus included in the computation logjoint and loglikelihood, but not in logprior.\nfixed variables are considered to be constant, and are thus not included in any log-probability computations.\n\njulia> @model function demo()\n           m ~ Normal()\n           x ~ Normal(m, 1)\n           return (; m=m, x=x)\n       end\ndemo (generic function with 2 methods)\n\njulia> model = demo();\n\njulia> model_fixed = fix(model, m = 1.0);\n\njulia> model_conditioned = condition(model, m = 1.0);\n\njulia> logjoint(model_fixed, (x=1.0,))\n-0.9189385332046728\n\njulia> # Different!\n       logjoint(model_conditioned, (x=1.0,))\n-2.3378770664093453\n\njulia> # And the difference is the missing log-probability of `m`:\n       logjoint(model_fixed, (x=1.0,)) + logpdf(Normal(), 1.0) == logjoint(model_conditioned, (x=1.0,))\ntrue\n\n\n\n\n\nfix([context::AbstractContext,] values::NamedTuple)\nfix([context::AbstractContext]; values...)\n\nReturn FixedContext with values and context if values is non-empty, otherwise return context which is DefaultContext by default.\n\nSee also: unfix\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.fixed","page":"API","title":"DynamicPPL.fixed","text":"fixed(model::Model)\n\nReturn the fixed values in model.\n\nExamples\n\njulia> using Distributions\n\njulia> using DynamicPPL: fixed, contextualize\n\njulia> @model function demo()\n           m ~ Normal()\n           x ~ Normal(m, 1)\n       end\ndemo (generic function with 2 methods)\n\njulia> m = demo();\n\njulia> # Returns all the variables we have fixed on + their values.\n       fixed(fix(m, x=100.0, m=1.0))\n(x = 100.0, m = 1.0)\n\njulia> # Nested ones also work (note that `PrefixContext` does nothing to the result).\n       cm = fix(contextualize(m, PrefixContext{:a}(fix(m=1.0))), x=100.0);\n\njulia> fixed(cm)\n(x = 100.0, m = 1.0)\n\njulia> # Since we fixed on `m`, not `a.m` as it will appear after prefixed,\n       # `a.m` is treated as a random variable.\n       keys(VarInfo(cm))\n1-element Vector{VarName{Symbol(\"a.m\"), typeof(identity)}}:\n a.m\n\njulia> # If we instead fix on `a.m`, `m` in the model will be considered an observation.\n       cm = fix(contextualize(m, PrefixContext{:a}(fix(var\"a.m\"=1.0))), x=100.0);\n\njulia> fixed(cm).x\n100.0\n\njulia> fixed(cm).var\"a.m\"\n1.0\n\njulia> keys(VarInfo(cm)) # <= no variables are sampled\nVarName[]\n\n\n\n\n\nfixed(context::AbstractContext)\n\nReturn the values that are fixed under context.\n\nNote that this will recursively traverse the context stack and return a merged version of the fix values.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The difference between fix and condition is described in the docstring of fix above.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Similarly, we can unfix variables, i.e. return them to their original meaning:","category":"page"},{"location":"api/","page":"API","title":"API","text":"unfix","category":"page"},{"location":"api/#DynamicPPL.unfix","page":"API","title":"DynamicPPL.unfix","text":"unfix(model::Model)\nunfix(model::Model, variables...)\n\nReturn a Model for which variables... are not considered fixed. If no variables are provided, then all variables currently considered fixed will no longer be.\n\nThis is essentially the inverse of fix. This also means that it suffers from the same limitiations.\n\nNote that currently we only support variables to take on explicit values provided to fix.\n\nExamples\n\njulia> using Distributions\n\njulia> @model function demo()\n           m ~ Normal()\n           x ~ Normal(m, 1)\n           return (; m=m, x=x)\n       end\ndemo (generic function with 2 methods)\n\njulia> fixed_model = fix(demo(), m = 1.0, x = 10.0);\n\njulia> fixed_model()\n(m = 1.0, x = 10.0)\n\njulia> # By specifying the `VarName` to `unfix`.\n       model = unfix(fixed_model, @varname(m));\n\njulia> (m, x) = model(); (m ≠ 1.0 && x == 10.0)\ntrue\n\njulia> # When `NamedTuple` is used as the underlying, you can also provide\n       # the symbol directly (though the `@varname` approach is preferable if\n       # if the variable is known at compile-time).\n       model = unfix(fixed_model, :m);\n\njulia> (m, x) = model(); (m ≠ 1.0 && x == 10.0)\ntrue\n\njulia> # `unfix` multiple at once:\n       (m, x) = unfix(model, :m, :x)(); (m ≠ 1.0 && x ≠ 10.0)\ntrue\n\njulia> # `unfix` without any symbols will `unfix` all variables.\n       (m, x) = unfix(model)(); (m ≠ 1.0 && x ≠ 10.0)\ntrue\n\njulia> # Usage of `Val` to perform `unfix` at compile-time if possible\n       # is also supported.\n       model = unfix(fixed_model, Val{:m}());\n\njulia> (m, x) = model(); (m ≠ 1.0 && x == 10.0)\ntrue\n\nSimilarly when using a Dict:\n\njulia> fixed_model_dict = fix(demo(), @varname(m) => 1.0, @varname(x) => 10.0);\n\njulia> fixed_model_dict()\n(m = 1.0, x = 10.0)\n\njulia> unfixed_model_dict = unfix(fixed_model_dict, @varname(m));\n\njulia> (m, x) = unfixed_model_dict(); m ≠ 1.0 && x == 10.0\ntrue\n\nBut, as mentioned, unfix is only supported for variables explicitly provided to fix earlier:\n\njulia> @model function demo_mv(::Type{TV}=Float64) where {TV}\n           m = Vector{TV}(undef, 2)\n           m[1] ~ Normal()\n           m[2] ~ Normal()\n           return m\n       end\ndemo_mv (generic function with 4 methods)\n\njulia> model = demo_mv();\n\njulia> fixed_model = fix(model, @varname(m) => [1.0, 2.0]);\n\njulia> fixed_model()\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> unfixed_model = unfix(fixed_model, @varname(m[1]));\n\njulia> unfixed_model()  # (×) `m[1]` is still fixed\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> # (✓) this works though\n       unfixed_model_2 = fix(unfixed_model, @varname(m[1]) => missing);\n\njulia> m = unfixed_model_2(); (m[1] ≠ 1.0 && m[2] == 2.0)\ntrue\n\n\n\n\n\nunfix(context::AbstractContext, syms...)\n\nReturn context but with syms no longer fixed.\n\nNote that this recursively traverses contexts, unfixing all along the way.\n\nSee also: fix\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"It is possible to manually increase (or decrease) the accumulated log density from within a model function.","category":"page"},{"location":"api/","page":"API","title":"API","text":"@addlogprob!","category":"page"},{"location":"api/#DynamicPPL.@addlogprob!","page":"API","title":"DynamicPPL.@addlogprob!","text":"@addlogprob!(ex)\n\nAdd the result of the evaluation of ex to the joint log probability.\n\nExamples\n\nThis macro allows you to include arbitrary terms in the likelihood\n\njulia> myloglikelihood(x, μ) = loglikelihood(Normal(μ, 1), x);\n\njulia> @model function demo(x)\n           μ ~ Normal()\n           @addlogprob! myloglikelihood(x, μ)\n       end;\n\njulia> x = [1.3, -2.1];\n\njulia> loglikelihood(demo(x), (μ=0.2,)) ≈ myloglikelihood(x, 0.2)\ntrue\n\nand to reject samples:\n\njulia> @model function demo(x)\n           m ~ MvNormal(zero(x), I)\n           if dot(m, x) < 0\n               @addlogprob! -Inf\n               # Exit the model evaluation early\n               return\n           end\n           x ~ MvNormal(m, I)\n           return\n       end;\n\njulia> logjoint(demo([-2.1]), (m=[0.2],)) == -Inf\ntrue\n\nnote: Note\nThe @addlogprob! macro increases the accumulated log probability regardless of the evaluation context, i.e., regardless of whether you evaluate the log prior, the log likelihood or the log joint density. If you would like to avoid this behaviour you should check the evaluation context. It can be accessed with the internal variable __context__. For instance, in the following example the log density is not accumulated when only the log prior is computed:julia> myloglikelihood(x, μ) = loglikelihood(Normal(μ, 1), x);\n\njulia> @model function demo(x)\n           μ ~ Normal()\n           if DynamicPPL.leafcontext(__context__) !== PriorContext()\n               @addlogprob! myloglikelihood(x, μ)\n           end\n       end;\n\njulia> x = [1.3, -2.1];\n\njulia> logprior(demo(x), (μ=0.2,)) ≈ logpdf(Normal(), 0.2)\ntrue\n\njulia> loglikelihood(demo(x), (μ=0.2,)) ≈ myloglikelihood(x, 0.2)\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"Return values of the model function for a collection of samples can be obtained with generated_quantities.","category":"page"},{"location":"api/","page":"API","title":"API","text":"generated_quantities","category":"page"},{"location":"api/#DynamicPPL.generated_quantities","page":"API","title":"DynamicPPL.generated_quantities","text":"generated_quantities(model::Model, parameters::NamedTuple)\ngenerated_quantities(model::Model, values, keys)\ngenerated_quantities(model::Model, values, keys)\n\nExecute model with variables keys set to values and return the values returned by the model.\n\nIf a NamedTuple is given, keys=keys(parameters) and values=values(parameters).\n\nExample\n\njulia> using DynamicPPL, Distributions\n\njulia> @model function demo(xs)\n           s ~ InverseGamma(2, 3)\n           m_shifted ~ Normal(10, √s)\n           m = m_shifted - 10\n           for i in eachindex(xs)\n               xs[i] ~ Normal(m, √s)\n           end\n           return (m, )\n       end\ndemo (generic function with 2 methods)\n\njulia> model = demo(randn(10));\n\njulia> parameters = (; s = 1.0, m_shifted=10.0);\n\njulia> generated_quantities(model, parameters)\n(0.0,)\n\njulia> generated_quantities(model, values(parameters), keys(parameters))\n(0.0,)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"For a chain of samples, one can compute the pointwise log-likelihoods of each observed random variable with pointwise_loglikelihoods. Similarly, the log-densities of the priors using pointwise_prior_logdensities or both, i.e. all variables, using pointwise_logdensities.","category":"page"},{"location":"api/","page":"API","title":"API","text":"pointwise_logdensities\npointwise_loglikelihoods\npointwise_prior_logdensities","category":"page"},{"location":"api/#DynamicPPL.pointwise_logdensities","page":"API","title":"DynamicPPL.pointwise_logdensities","text":"pointwise_logdensities(model::Model, chain::Chains, keytype = String)\n\nRuns model on each sample in chain returning a OrderedDict{String, Matrix{Float64}} with keys corresponding to symbols of the variables, and values being matrices of shape (num_chains, num_samples).\n\nkeytype specifies what the type of the keys used in the returned OrderedDict are. Currently, only String and VarName are supported.\n\nNotes\n\nSay y is a Vector of n i.i.d. Normal(μ, σ) variables, with μ and σ both being <:Real. Then the observe (i.e. when the left-hand side is an observation) statements can be implemented in three ways:\n\nusing a for loop:\n\nfor i in eachindex(y)\n    y[i] ~ Normal(μ, σ)\nend\n\nusing .~:\n\ny .~ Normal(μ, σ)\n\nusing MvNormal:\n\ny ~ MvNormal(fill(μ, n), σ^2 * I)\n\nIn (1) and (2), y will be treated as a collection of n i.i.d. 1-dimensional variables, while in (3) y will be treated as a single n-dimensional observation.\n\nThis is important to keep in mind, in particular if the computation is used for downstream computations.\n\nExamples\n\nFrom chain\n\njulia> using MCMCChains\n\njulia> @model function demo(xs, y)\n           s ~ InverseGamma(2, 3)\n           m ~ Normal(0, √s)\n           for i in eachindex(xs)\n               xs[i] ~ Normal(m, √s)\n           end\n           y ~ Normal(m, √s)\n       end\ndemo (generic function with 2 methods)\n\njulia> # Example observations.\n       model = demo([1.0, 2.0, 3.0], [4.0]);\n\njulia> # A chain with 3 iterations.\n       chain = Chains(\n           reshape(1.:6., 3, 2),\n           [:s, :m]\n       );\n\njulia> pointwise_logdensities(model, chain)\nOrderedDict{String, Matrix{Float64}} with 6 entries:\n  \"s\"     => [-0.802775; -1.38222; -2.09861;;]\n  \"m\"     => [-8.91894; -7.51551; -7.46824;;]\n  \"xs[1]\" => [-5.41894; -5.26551; -5.63491;;]\n  \"xs[2]\" => [-2.91894; -3.51551; -4.13491;;]\n  \"xs[3]\" => [-1.41894; -2.26551; -2.96824;;]\n  \"y\"     => [-0.918939; -1.51551; -2.13491;;]\n\njulia> pointwise_logdensities(model, chain, String)\nOrderedDict{String, Matrix{Float64}} with 6 entries:\n  \"s\"     => [-0.802775; -1.38222; -2.09861;;]\n  \"m\"     => [-8.91894; -7.51551; -7.46824;;]\n  \"xs[1]\" => [-5.41894; -5.26551; -5.63491;;]\n  \"xs[2]\" => [-2.91894; -3.51551; -4.13491;;]\n  \"xs[3]\" => [-1.41894; -2.26551; -2.96824;;]\n  \"y\"     => [-0.918939; -1.51551; -2.13491;;]\n\njulia> pointwise_logdensities(model, chain, VarName)\nOrderedDict{VarName, Matrix{Float64}} with 6 entries:\n  s     => [-0.802775; -1.38222; -2.09861;;]\n  m     => [-8.91894; -7.51551; -7.46824;;]\n  xs[1] => [-5.41894; -5.26551; -5.63491;;]\n  xs[2] => [-2.91894; -3.51551; -4.13491;;]\n  xs[3] => [-1.41894; -2.26551; -2.96824;;]\n  y     => [-0.918939; -1.51551; -2.13491;;]\n\nBroadcasting\n\nNote that x .~ Dist() will treat x as a collection of independent observations rather than as a single observation.\n\njulia> @model function demo(x)\n           x .~ Normal()\n       end;\n\njulia> m = demo([1.0, ]);\n\njulia> ℓ = pointwise_logdensities(m, VarInfo(m)); first(ℓ[@varname(x[1])])\n-1.4189385332046727\n\njulia> m = demo([1.0; 1.0]);\n\njulia> ℓ = pointwise_logdensities(m, VarInfo(m)); first.((ℓ[@varname(x[1])], ℓ[@varname(x[2])]))\n(-1.4189385332046727, -1.4189385332046727)\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.pointwise_loglikelihoods","page":"API","title":"DynamicPPL.pointwise_loglikelihoods","text":"pointwise_loglikelihoods(model, chain[, keytype, context])\n\nCompute the pointwise log-likelihoods of the model given the chain. This is the same as pointwise_logdensities(model, chain, context), but only including the likelihood terms. See also: pointwise_logdensities.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.pointwise_prior_logdensities","page":"API","title":"DynamicPPL.pointwise_prior_logdensities","text":"pointwise_prior_logdensities(model, chain[, keytype, context])\n\nCompute the pointwise log-prior-densities of the model given the chain. This is the same as pointwise_logdensities(model, chain, context), but only including the prior terms. See also: pointwise_logdensities.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"For converting a chain into a format that can more easily be fed into a Model again, for example using condition, you can use value_iterator_from_chain.","category":"page"},{"location":"api/","page":"API","title":"API","text":"value_iterator_from_chain\n","category":"page"},{"location":"api/#DynamicPPL.value_iterator_from_chain","page":"API","title":"DynamicPPL.value_iterator_from_chain","text":"value_iterator_from_chain(model::Model, chain)\nvalue_iterator_from_chain(varinfo::AbstractVarInfo, chain)\n\nReturn an iterator over the values in chain for each variable in model/varinfo.\n\nExample\n\njulia> using MCMCChains, DynamicPPL, Distributions, StableRNGs\n\njulia> rng = StableRNG(42);\n\njulia> @model function demo_model(x)\n           s ~ InverseGamma(2, 3)\n           m ~ Normal(0, sqrt(s))\n           for i in eachindex(x)\n               x[i] ~ Normal(m, sqrt(s))\n           end\n\n           return s, m\n       end\ndemo_model (generic function with 2 methods)\n\njulia> model = demo_model([1.0, 2.0]);\n\njulia> chain = Chains(rand(rng, 10, 2, 3), [:s, :m]);\n\njulia> iter = value_iterator_from_chain(model, chain);\n\njulia> first(iter)\nOrderedDict{VarName, Any} with 2 entries:\n  s => 0.580515\n  m => 0.739328\n\njulia> collect(iter)\n10×3 Matrix{OrderedDict{VarName, Any}}:\n OrderedDict(s=>0.580515, m=>0.739328)  …  OrderedDict(s=>0.186047, m=>0.402423)\n OrderedDict(s=>0.191241, m=>0.627342)     OrderedDict(s=>0.776277, m=>0.166342)\n OrderedDict(s=>0.971133, m=>0.637584)     OrderedDict(s=>0.651655, m=>0.712044)\n OrderedDict(s=>0.74345, m=>0.110359)      OrderedDict(s=>0.469214, m=>0.104502)\n OrderedDict(s=>0.170969, m=>0.598514)     OrderedDict(s=>0.853546, m=>0.185399)\n OrderedDict(s=>0.704776, m=>0.322111)  …  OrderedDict(s=>0.638301, m=>0.853802)\n OrderedDict(s=>0.441044, m=>0.162285)     OrderedDict(s=>0.852959, m=>0.0956922)\n OrderedDict(s=>0.803972, m=>0.643369)     OrderedDict(s=>0.245049, m=>0.871985)\n OrderedDict(s=>0.772384, m=>0.646323)     OrderedDict(s=>0.906603, m=>0.385502)\n OrderedDict(s=>0.70882, m=>0.253105)      OrderedDict(s=>0.413222, m=>0.953288)\n\njulia> # This can be used to `condition` a `Model`.\n       conditioned_model = model | first(iter);\n\njulia> conditioned_model()  # <= results in same values as the `first(iter)` above\n(0.5805148626851955, 0.7393275279160691)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Sometimes it can be useful to extract the priors of a model. This is the possible using extract_priors.","category":"page"},{"location":"api/","page":"API","title":"API","text":"extract_priors","category":"page"},{"location":"api/#DynamicPPL.extract_priors","page":"API","title":"DynamicPPL.extract_priors","text":"extract_priors([rng::Random.AbstractRNG, ]model::Model)\n\nExtract the priors from a model.\n\nThis is done by sampling from the model and recording the distributions that are used to generate the samples.\n\nwarning: Warning\nBecause the extraction is done by execution of the model, there are several caveats:If one variable, say, y ~ Normal(0, x), where x ~ Normal() is also a random variable, then the extracted prior will have different parameters in every extraction!\nIf the model does not have static support, say, n ~ Categorical(1:10); x ~ MvNormmal(zeros(n), I), then the extracted priors themselves will be different between extractions, not just their parameters.Both of these caveats are demonstrated below.\n\nExamples\n\nChanging parameters\n\njulia> using Distributions, StableRNGs\n\njulia> rng = StableRNG(42);\n\njulia> @model function model_dynamic_parameters()\n           x ~ Normal(0, 1)\n           y ~ Normal(x, 1)\n       end;\n\njulia> model = model_dynamic_parameters();\n\njulia> extract_priors(rng, model)[@varname(y)]\nNormal{Float64}(μ=-0.6702516921145671, σ=1.0)\n\njulia> extract_priors(rng, model)[@varname(y)]\nNormal{Float64}(μ=1.3736306979834252, σ=1.0)\n\nChanging support\n\njulia> using LinearAlgebra, Distributions, StableRNGs\n\njulia> rng = StableRNG(42);\n\njulia> @model function model_dynamic_support()\n           n ~ Categorical(ones(10) ./ 10)\n           x ~ MvNormal(zeros(n), I)\n       end;\n\njulia> model = model_dynamic_support();\n\njulia> length(extract_priors(rng, model)[@varname(x)])\n6\n\njulia> length(extract_priors(rng, model)[@varname(x)])\n9\n\n\n\n\n\nextract_priors(model::Model, varinfo::AbstractVarInfo)\n\nExtract the priors from a model.\n\nThis is done by evaluating the model at the values present in varinfo and recording the distributions that are present at each tilde statement.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Safe extraction of values from a given AbstractVarInfo as they are seen in the model can be done using values_as_in_model.","category":"page"},{"location":"api/","page":"API","title":"API","text":"values_as_in_model","category":"page"},{"location":"api/#DynamicPPL.values_as_in_model","page":"API","title":"DynamicPPL.values_as_in_model","text":"values_as_in_model(model::Model[, varinfo::AbstractVarInfo, context::AbstractContext])\nvalues_as_in_model(rng::Random.AbstractRNG, model::Model[, varinfo::AbstractVarInfo, context::AbstractContext])\n\nGet the values of varinfo as they would be seen in the model.\n\nIf no varinfo is provided, then this is effectively the same as Base.rand(rng::Random.AbstractRNG, model::Model).\n\nMore specifically, this method attempts to extract the realization as seen in the model. For example, x[1] ~ truncated(Normal(); lower=0) will result in a realization compatible with truncated(Normal(); lower=0) regardless of whether varinfo is working in unconstrained space.\n\nHence this method is a \"safe\" way of obtaining realizations in constrained space at the cost of additional model evaluations.\n\nArguments\n\nmodel::Model: model to extract realizations from.\nvarinfo::AbstractVarInfo: variable information to use for the extraction.\ncontext::AbstractContext: context to use for the extraction. If rng is specified, then context   will be wrapped in a SamplingContext with the provided rng.\n\nExamples\n\nWhen VarInfo fails\n\nThe following demonstrates a common pitfall when working with VarInfo and constrained variables.\n\njulia> using Distributions, StableRNGs\n\njulia> rng = StableRNG(42);\n\njulia> @model function model_changing_support()\n           x ~ Bernoulli(0.5)\n           y ~ x == 1 ? Uniform(0, 1) : Uniform(11, 12)\n       end;\n\njulia> model = model_changing_support();\n\njulia> # Construct initial type-stable `VarInfo`.\n       varinfo = VarInfo(rng, model);\n\njulia> # Link it so it works in unconstrained space.\n       varinfo_linked = DynamicPPL.link(varinfo, model);\n\njulia> # Perform computations in unconstrained space, e.g. changing the values of `θ`.\n       # Flip `x` so we hit the other support of `y`.\n       θ = [!varinfo[@varname(x)], rand(rng)];\n\njulia> # Update the `VarInfo` with the new values.\n       varinfo_linked = DynamicPPL.unflatten(varinfo_linked, θ);\n\njulia> # Determine the expected support of `y`.\n       lb, ub = θ[1] == 1 ? (0, 1) : (11, 12)\n(0, 1)\n\njulia> # Approach 1: Convert back to constrained space using `invlink` and extract.\n       varinfo_invlinked = DynamicPPL.invlink(varinfo_linked, model);\n\njulia> # (×) Fails! Because `VarInfo` _saves_ the original distributions\n       # used in the very first model evaluation, hence the support of `y`\n       # is not updated even though `x` has changed.\n       lb ≤ first(varinfo_invlinked[@varname(y)]) ≤ ub\nfalse\n\njulia> # Approach 2: Extract realizations using `values_as_in_model`.\n       # (✓) `values_as_in_model` will re-run the model and extract\n       # the correct realization of `y` given the new values of `x`.\n       lb ≤ values_as_in_model(model, varinfo_linked)[@varname(y)] ≤ ub\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"NamedDist","category":"page"},{"location":"api/#DynamicPPL.NamedDist","page":"API","title":"DynamicPPL.NamedDist","text":"A named distribution that carries the name of the random variable with it.\n\n\n\n\n\n","category":"type"},{"location":"api/#Testing-Utilities","page":"API","title":"Testing Utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL provides several demo models and helpers for testing samplers in the DynamicPPL.TestUtils submodule.","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.TestUtils.test_sampler\nDynamicPPL.TestUtils.test_sampler_on_demo_models\nDynamicPPL.TestUtils.test_sampler_continuous\nDynamicPPL.TestUtils.marginal_mean_of_samples","category":"page"},{"location":"api/#DynamicPPL.TestUtils.test_sampler","page":"API","title":"DynamicPPL.TestUtils.test_sampler","text":"test_sampler(models, sampler, args...; kwargs...)\n\nTest that sampler produces correct marginal posterior means on each model in models.\n\nIn short, this method iterates through models, calls AbstractMCMC.sample on the model and sampler to produce a chain, and then checks marginal_mean_of_samples(chain, vn) for every (leaf) varname vn against the corresponding value returned by posterior_mean for each model.\n\nTo change how comparison is done for a particular chain type, one can overload marginal_mean_of_samples for the corresponding type.\n\nArguments\n\nmodels: A collection of instaces of DynamicPPL.Model to test on.\nsampler: The AbstractMCMC.AbstractSampler to test.\nargs...: Arguments forwarded to sample.\n\nKeyword arguments\n\nvarnames_filter: A filter to apply to varnames(model), allowing comparison for only   a subset of the varnames.\natol=1e-1: Absolute tolerance used in @test.\nrtol=1e-3: Relative tolerance used in @test.\nkwargs...: Keyword arguments forwarded to sample.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.TestUtils.test_sampler_on_demo_models","page":"API","title":"DynamicPPL.TestUtils.test_sampler_on_demo_models","text":"test_sampler_on_demo_models(meanfunction, sampler, args...; kwargs...)\n\nTest sampler on every model in DEMO_MODELS.\n\nThis is just a proxy for test_sampler(meanfunction, DEMO_MODELS, sampler, args...; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.TestUtils.test_sampler_continuous","page":"API","title":"DynamicPPL.TestUtils.test_sampler_continuous","text":"test_sampler_continuous(sampler, args...; kwargs...)\n\nTest that sampler produces the correct marginal posterior means on all models in demo_models.\n\nAs of right now, this is just an alias for test_sampler_on_demo_models.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.TestUtils.marginal_mean_of_samples","page":"API","title":"DynamicPPL.TestUtils.marginal_mean_of_samples","text":"marginal_mean_of_samples(chain, varname)\n\nReturn the mean of variable represented by varname in chain.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.TestUtils.DEMO_MODELS","category":"page"},{"location":"api/#DynamicPPL.TestUtils.DEMO_MODELS","page":"API","title":"DynamicPPL.TestUtils.DEMO_MODELS","text":"A collection of models corresponding to the posterior distribution defined by the generative process\n\ns ~ InverseGamma(2, 3)\nm ~ Normal(0, √s)\n1.5 ~ Normal(m, √s)\n2.0 ~ Normal(m, √s)\n\nor by\n\ns[1] ~ InverseGamma(2, 3)\ns[2] ~ InverseGamma(2, 3)\nm[1] ~ Normal(0, √s)\nm[2] ~ Normal(0, √s)\n1.5 ~ Normal(m[1], √s[1])\n2.0 ~ Normal(m[2], √s[2])\n\nThese are examples of a Normal-InverseGamma conjugate prior with Normal likelihood, for which the posterior is known in closed form.\n\nIn particular, for the univariate model (the former one):\n\nmean(s) == 49 / 24\nmean(m) == 7 / 6\n\nAnd for the multivariate one (the latter one):\n\nmean(s[1]) == 19 / 8\nmean(m[1]) == 3 / 4\nmean(s[2]) == 8 / 3\nmean(m[2]) == 1\n\n\n\n\n\n","category":"constant"},{"location":"api/","page":"API","title":"API","text":"For every demo model, one can define the true log prior, log likelihood, and log joint probabilities.","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.TestUtils.logprior_true\nDynamicPPL.TestUtils.loglikelihood_true\nDynamicPPL.TestUtils.logjoint_true","category":"page"},{"location":"api/#DynamicPPL.TestUtils.logprior_true","page":"API","title":"DynamicPPL.TestUtils.logprior_true","text":"logprior_true(model, args...)\n\nReturn the logprior of model for args.\n\nThis should generally be implemented by hand for every specific model.\n\nSee also: logjoint_true, loglikelihood_true.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.TestUtils.loglikelihood_true","page":"API","title":"DynamicPPL.TestUtils.loglikelihood_true","text":"loglikelihood_true(model, args...)\n\nReturn the loglikelihood of model for args.\n\nThis should generally be implemented by hand for every specific model.\n\nSee also: logjoint_true, logprior_true.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.TestUtils.logjoint_true","page":"API","title":"DynamicPPL.TestUtils.logjoint_true","text":"logjoint_true(model, args...)\n\nReturn the logjoint of model for args.\n\nDefaults to logprior_true(model, args...) + loglikelihood_true(model, args..).\n\nThis should generally be implemented by hand for every specific model so that the returned value can be used as a ground-truth for testing things like:\n\nValidity of evaluation of model using a particular implementation of AbstractVarInfo.\nValidity of a sampler when combined with DynamicPPL by running the sampler twice: once targeting ground-truth functions, e.g. logjoint_true, and once targeting model.\n\nAnd more.\n\nSee also: logprior_true, loglikelihood_true.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"And in the case where the model includes constrained variables, it can also be useful to define","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian\nDynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian","category":"page"},{"location":"api/#DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian","page":"API","title":"DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian","text":"logprior_true_with_logabsdet_jacobian(model::Model, args...)\n\nReturn a tuple (args_unconstrained, logprior_unconstrained) of model for args....\n\nUnlike logprior_true, the returned logprior computation includes the log-absdet-jacobian adjustment, thus computing logprior for the unconstrained variables.\n\nNote that args are assumed be in the support of model, while args_unconstrained will be unconstrained.\n\nSee also: logprior_true.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian","page":"API","title":"DynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian","text":"logjoint_true_with_logabsdet_jacobian(model::Model, args...)\n\nReturn a tuple (args_unconstrained, logjoint) of model for args.\n\nUnlike logjoint_true, the returned logjoint computation includes the log-absdet-jacobian adjustment, thus computing logjoint for the unconstrained variables.\n\nNote that args are assumed be in the support of model, while args_unconstrained will be unconstrained.\n\nThis should generally not be implemented directly, instead one should implement logprior_true_with_logabsdet_jacobian for a given model.\n\nSee also: logjoint_true, logprior_true_with_logabsdet_jacobian.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Finally, the following methods can also be of use:","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.TestUtils.varnames\nDynamicPPL.TestUtils.posterior_mean\nDynamicPPL.TestUtils.setup_varinfos\nDynamicPPL.TestUtils.update_values!!\nDynamicPPL.TestUtils.test_values","category":"page"},{"location":"api/#DynamicPPL.TestUtils.varnames","page":"API","title":"DynamicPPL.TestUtils.varnames","text":"varnames(model::Model)\n\nReturn a collection of VarName as they are expected to appear in the model.\n\nEven though it is recommended to implement this by hand for a particular Model, a default implementation using SimpleVarInfo{<:Dict} is provided.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.TestUtils.posterior_mean","page":"API","title":"DynamicPPL.TestUtils.posterior_mean","text":"posterior_mean(model::Model)\n\nReturn a NamedTuple compatible with varnames(model) where the values represent the posterior mean under model.\n\n\"Compatible\" means that a varname from varnames(model) can be used to extract the corresponding value using get, e.g. get(posterior_mean(model), varname).\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.TestUtils.setup_varinfos","page":"API","title":"DynamicPPL.TestUtils.setup_varinfos","text":"setup_varinfos(model::Model, example_values::NamedTuple, varnames; include_threadsafe::Bool=false)\n\nReturn a tuple of instances for different implementations of AbstractVarInfo with each vi, supposedly, satisfying vi[vn] == get(example_values, vn) for vn in varnames.\n\nIf include_threadsafe is true, then the returned tuple will also include thread-safe versions of the varinfo instances.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.update_values!!","page":"API","title":"DynamicPPL.update_values!!","text":"update_values!!(vi::AbstractVarInfo, vals::NamedTuple, vns)\n\nReturn instance similar to vi but with vns set to values from vals.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.TestUtils.test_values","page":"API","title":"DynamicPPL.TestUtils.test_values","text":"test_values(vi::AbstractVarInfo, vals::NamedTuple, vns)\n\nTest that vi[vn] corresponds to the correct value in vals for every vn in vns.\n\n\n\n\n\n","category":"function"},{"location":"api/#Debugging-Utilities","page":"API","title":"Debugging Utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL provides a few methods for checking validity of a model-definition.","category":"page"},{"location":"api/","page":"API","title":"API","text":"check_model\ncheck_model_and_trace","category":"page"},{"location":"api/#DynamicPPL.DebugUtils.check_model","page":"API","title":"DynamicPPL.DebugUtils.check_model","text":"check_model([rng, ]model::Model; kwargs...)\n\nCheck that model is valid, warning about any potential issues.\n\nSee check_model_and_trace for more details on supported keword arguments and details of which types of checks are performed.\n\nReturns\n\nissuccess::Bool: Whether the model check succeeded.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.DebugUtils.check_model_and_trace","page":"API","title":"DynamicPPL.DebugUtils.check_model_and_trace","text":"check_model_and_trace([rng, ]model::Model; kwargs...)\n\nCheck that model is valid, warning about any potential issues.\n\nThis will check the model for the following issues:\n\nRepeated usage of the same varname in a model.\nIncorrectly treating a variable as random rather than fixed, and vice versa.\n\nArguments\n\nrng::Random.AbstractRNG: The random number generator to use when evaluating the model.\nmodel::Model: The model to check.\n\nKeyword Arguments\n\nvarinfo::VarInfo: The varinfo to use when evaluating the model. Default: VarInfo(model).\ncontext::AbstractContext: The context to use when evaluating the model. Default: DefaultContext.\nerror_on_failure::Bool: Whether to throw an error if the model check fails. Default: false.\n\nReturns\n\nissuccess::Bool: Whether the model check succeeded.\ntrace::Vector{Stmt}: The trace of statements executed during the model check.\n\nExamples\n\nCorrect model\n\njulia> using StableRNGs\n\njulia> rng = StableRNG(42);\n\njulia> @model demo_correct() = x ~ Normal()\ndemo_correct (generic function with 2 methods)\n\njulia> issuccess, trace = check_model_and_trace(rng, demo_correct());\n\njulia> issuccess\ntrue\n\njulia> print(trace)\n assume: x ~ Normal{Float64}(μ=0.0, σ=1.0) ⟼ -0.670252 (logprob = -1.14356)\n\njulia> issuccess, trace = check_model_and_trace(rng, demo_correct() | (x = 1.0,));\n\njulia> issuccess\ntrue\n\njulia> print(trace)\nobserve: 1.0 ~ Normal{Float64}(μ=0.0, σ=1.0) (logprob = -1.41894)\n\nIncorrect model\n\njulia> @model function demo_incorrect()\n           # (×) Sampling `x` twice will lead to incorrect log-probabilities!\n           x ~ Normal()\n           x ~ Exponential()\n       end\ndemo_incorrect (generic function with 2 methods)\n\njulia> issuccess, trace = check_model_and_trace(rng, demo_incorrect(); error_on_failure=true);\nERROR: varname x used multiple times in model\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"And some which might be useful to determine certain properties of the model based on the debug trace.","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.has_static_constraints","category":"page"},{"location":"api/#DynamicPPL.DebugUtils.has_static_constraints","page":"API","title":"DynamicPPL.DebugUtils.has_static_constraints","text":"has_static_constraints([rng, ]model::Model; num_evals=5, kwargs...)\n\nReturn true if the model has static constraints, false otherwise.\n\nNote that this is a heuristic check based on sampling from the model multiple times and checking if the model is consistent across runs.\n\nArguments\n\nrng::Random.AbstractRNG: The random number generator to use when evaluating the model.\nmodel::Model: The model to check.\n\nKeyword Arguments\n\nnum_evals::Int: The number of evaluations to perform. Default: 5.\nkwargs...: Additional keyword arguments to pass to check_model_and_trace.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"For determining whether one might have type instabilities in the model, the following can be useful","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.DebugUtils.model_warntype\nDynamicPPL.DebugUtils.model_typed","category":"page"},{"location":"api/#DynamicPPL.DebugUtils.model_warntype","page":"API","title":"DynamicPPL.DebugUtils.model_warntype","text":"model_warntype(model[, varinfo, context]; optimize=true)\n\nCheck the type stability of the model's evaluator, warning about any potential issues.\n\nThis simply calls @code_warntype on the model's evaluator, filling in internal arguments where needed.\n\nArguments\n\nmodel::Model: The model to check.\nvarinfo::AbstractVarInfo: The varinfo to use when evaluating the model. Default: VarInfo(model).\ncontext::AbstractContext: The context to use when evaluating the model. Default: DefaultContext.\n\nKeyword Arguments\n\noptimize::Bool: Whether to generate optimized code. Default: false.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.DebugUtils.model_typed","page":"API","title":"DynamicPPL.DebugUtils.model_typed","text":"model_typed(model[, varinfo, context]; optimize=true)\n\nReturn the type inference for the model's evaluator.\n\nThis simply calls @code_typed on the model's evaluator, filling in internal arguments where needed.\n\nArguments\n\nmodel::Model: The model to check.\nvarinfo::AbstractVarInfo: The varinfo to use when evaluating the model. Default: VarInfo(model).\ncontext::AbstractContext: The context to use when evaluating the model. Default: DefaultContext.\n\nKeyword Arguments\n\noptimize::Bool: Whether to generate optimized code. Default: true.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Interally, the type-checking methods make use of the following method for construction of the call with the argument types:","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.DebugUtils.gen_evaluator_call_with_types","category":"page"},{"location":"api/#DynamicPPL.DebugUtils.gen_evaluator_call_with_types","page":"API","title":"DynamicPPL.DebugUtils.gen_evaluator_call_with_types","text":"gen_evaluator_call_with_types(model[, varinfo, context])\n\nGenerate the evaluator call and the types of the arguments.\n\nArguments\n\nmodel::Model: The model whose evaluator is of interest.\nvarinfo::AbstractVarInfo: The varinfo to use when evaluating the model. Default: VarInfo(model).\ncontext::AbstractContext: The context to use when evaluating the model. Default: DefaultContext.\n\nReturns\n\nA 2-tuple with the following elements:\n\nf: This is either model.f or Core.kwcall, depending on whether   the model has keyword arguments.\nargtypes::Type{<:Tuple}: The types of the arguments for the evaluator.\n\n\n\n\n\n","category":"function"},{"location":"api/#Advanced","page":"API","title":"Advanced","text":"","category":"section"},{"location":"api/#Variable-names","page":"API","title":"Variable names","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Names and possibly nested indices of variables are described with AbstractPPL.VarName. They can be defined with AbstractPPL.@varname. Please see the documentation of AbstractPPL.jl for further information.","category":"page"},{"location":"api/#Data-Structures-of-Variables","page":"API","title":"Data Structures of Variables","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL provides different data structures used in for storing samples and accumulation of the log-probabilities, all of which are subtypes of AbstractVarInfo.","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractVarInfo","category":"page"},{"location":"api/#DynamicPPL.AbstractVarInfo","page":"API","title":"DynamicPPL.AbstractVarInfo","text":"AbstractVarInfo\n\nAbstract supertype for data structures that capture random variables when executing a probabilistic model and accumulate log densities such as the log likelihood or the log joint probability of the model.\n\nSee also: VarInfo, SimpleVarInfo.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"But exactly how a AbstractVarInfo stores this information can vary.","category":"page"},{"location":"api/#VarInfo","page":"API","title":"VarInfo","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VarInfo\nTypedVarInfo","category":"page"},{"location":"api/#DynamicPPL.VarInfo","page":"API","title":"DynamicPPL.VarInfo","text":"struct VarInfo{Tmeta, Tlogp} <: AbstractVarInfo\n    metadata::Tmeta\n    logp::Base.RefValue{Tlogp}\n    num_produce::Base.RefValue{Int}\nend\n\nA light wrapper over one or more instances of Metadata. Let vi be an instance of VarInfo. If vi isa VarInfo{<:Metadata}, then only one Metadata instance is used for all the sybmols. VarInfo{<:Metadata} is aliased UntypedVarInfo. If vi isa VarInfo{<:NamedTuple}, then vi.metadata is a NamedTuple that maps each symbol used on the LHS of ~ in the model to its Metadata instance. The latter allows for the type specialization of vi after the first sampling iteration when all the symbols have been observed. VarInfo{<:NamedTuple} is aliased TypedVarInfo.\n\nNote: It is the user's responsibility to ensure that each \"symbol\" is visited at least once whenever the model is called, regardless of any stochastic branching. Each symbol refers to a Julia variable and can be a hierarchical array of many random variables, e.g. x[1] ~ ... and x[2] ~ ... both have the same symbol x.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicPPL.TypedVarInfo","page":"API","title":"DynamicPPL.TypedVarInfo","text":"TypedVarInfo(vi::UntypedVarInfo)\n\nThis function finds all the unique syms from the instances of VarName{sym} found in vi.metadata.vns. It then extracts the metadata associated with each symbol from the global vi.metadata field. Finally, a new VarInfo is created with a new metadata as a NamedTuple mapping from symbols to type-stable Metadata instances, one for each symbol.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"One main characteristic of VarInfo is that samples are stored in a linearized form.","category":"page"},{"location":"api/","page":"API","title":"API","text":"link!\ninvlink!","category":"page"},{"location":"api/#DynamicPPL.link!","page":"API","title":"DynamicPPL.link!","text":"link!(vi::VarInfo, spl::Sampler)\n\nTransform the values of the random variables sampled by spl in vi from the support of their distributions to the Euclidean space and set their corresponding \"trans\" flag values to true.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.invlink!","page":"API","title":"DynamicPPL.invlink!","text":"invlink!(vi::VarInfo, spl::AbstractSampler)\n\nTransform the values of the random variables sampled by spl in vi from the Euclidean space back to the support of their distributions and sets their corresponding \"trans\" flag values to false.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"set_flag!\nunset_flag!\nis_flagged","category":"page"},{"location":"api/#DynamicPPL.set_flag!","page":"API","title":"DynamicPPL.set_flag!","text":"set_flag!(vi::VarInfo, vn::VarName, flag::String)\n\nSet vn's value for flag to true in vi.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.unset_flag!","page":"API","title":"DynamicPPL.unset_flag!","text":"unset_flag!(vi::VarInfo, vn::VarName, flag::String, ignorable::Bool=false\n\nSet vn's value for flag to false in vi.\n\nSetting some flags for some VarInfo types is not possible, and by default attempting to do so will error. If ignorable is set to true then this will silently be ignored instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.is_flagged","page":"API","title":"DynamicPPL.is_flagged","text":"is_flagged(vi::VarInfo, vn::VarName, flag::String)\n\nCheck whether vn has a true value for flag in vi.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"For Gibbs sampling the following functions were added.","category":"page"},{"location":"api/","page":"API","title":"API","text":"setgid!\nupdategid!","category":"page"},{"location":"api/#DynamicPPL.setgid!","page":"API","title":"DynamicPPL.setgid!","text":"setgid!(vi::VarInfo, gid::Selector, vn::VarName)\n\nAdd gid to the set of sampler selectors associated with vn in vi.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.updategid!","page":"API","title":"DynamicPPL.updategid!","text":"updategid!(vi::VarInfo, vn::VarName, spl::Sampler)\n\nSet vn's gid to Set([spl.selector]), if vn does not have a sampler selector linked and vn's symbol is in the space of spl.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The following functions were used for sequential Monte Carlo methods.","category":"page"},{"location":"api/","page":"API","title":"API","text":"get_num_produce\nset_num_produce!\nincrement_num_produce!\nreset_num_produce!\nsetorder!\nset_retained_vns_del_by_spl!","category":"page"},{"location":"api/#DynamicPPL.get_num_produce","page":"API","title":"DynamicPPL.get_num_produce","text":"get_num_produce(vi::VarInfo)\n\nReturn the num_produce of vi.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.set_num_produce!","page":"API","title":"DynamicPPL.set_num_produce!","text":"set_num_produce!(vi::VarInfo, n::Int)\n\nSet the num_produce field of vi to n.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.increment_num_produce!","page":"API","title":"DynamicPPL.increment_num_produce!","text":"increment_num_produce!(vi::VarInfo)\n\nAdd 1 to num_produce in vi.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.reset_num_produce!","page":"API","title":"DynamicPPL.reset_num_produce!","text":"reset_num_produce!(vi::VarInfo)\n\nReset the value of num_produce the log of the joint probability of the observed data and parameters sampled in vi to 0.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.setorder!","page":"API","title":"DynamicPPL.setorder!","text":"setorder!(vi::VarInfo, vn::VarName, index::Int)\n\nSet the order of vn in vi to index, where order is the number of observe statements run before samplingvn`.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.set_retained_vns_del_by_spl!","page":"API","title":"DynamicPPL.set_retained_vns_del_by_spl!","text":"set_retained_vns_del_by_spl!(vi::VarInfo, spl::Sampler)\n\nSet the \"del\" flag of variables in vi with order > vi.num_produce[] to true.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Base.empty!","category":"page"},{"location":"api/#Base.empty!","page":"API","title":"Base.empty!","text":"empty!(meta::Metadata)\n\nEmpty the fields of meta.\n\nThis is useful when using a sampling algorithm that assumes an empty meta, e.g. SMC.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimpleVarInfo","page":"API","title":"SimpleVarInfo","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SimpleVarInfo","category":"page"},{"location":"api/#DynamicPPL.SimpleVarInfo","page":"API","title":"DynamicPPL.SimpleVarInfo","text":"struct SimpleVarInfo{NT, T, C<:DynamicPPL.AbstractTransformation} <: AbstractVarInfo\n\nA simple wrapper of the parameters with a logp field for accumulation of the logdensity.\n\nCurrently only implemented for NT<:NamedTuple and NT<:AbstractDict.\n\nFields\n\nvalues: underlying representation of the realization represented\nlogp: holds the accumulated log-probability\ntransformation: represents whether it assumes variables to be transformed\n\nNotes\n\nThe major differences between this and TypedVarInfo are:\n\nSimpleVarInfo does not require linearization.\nSimpleVarInfo can use more efficient bijectors.\nSimpleVarInfo is only type-stable if NT<:NamedTuple and either a) no indexing is used in tilde-statements, or b) the values have been specified with the correct shapes.\n\nExamples\n\nGeneral usage\n\njulia> using StableRNGs\n\njulia> @model function demo()\n           m ~ Normal()\n           x = Vector{Float64}(undef, 2)\n           for i in eachindex(x)\n               x[i] ~ Normal()\n           end\n           return x\n       end\ndemo (generic function with 2 methods)\n\njulia> m = demo();\n\njulia> rng = StableRNG(42);\n\njulia> ### Sampling ###\n       ctx = SamplingContext(rng, SampleFromPrior(), DefaultContext());\n\njulia> # In the `NamedTuple` version we need to provide the place-holder values for\n       # the variables which are using \"containers\", e.g. `Array`.\n       # In this case, this means that we need to specify `x` but not `m`.\n       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo((x = ones(2), )), ctx);\n\njulia> # (✓) Vroom, vroom! FAST!!!\n       vi[@varname(x[1])]\n0.4471218424633827\n\njulia> # We can also access arbitrary varnames pointing to `x`, e.g.\n       vi[@varname(x)]\n2-element Vector{Float64}:\n 0.4471218424633827\n 1.3736306979834252\n\njulia> vi[@varname(x[1:2])]\n2-element Vector{Float64}:\n 0.4471218424633827\n 1.3736306979834252\n\njulia> # (×) If we don't provide the container...\n       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo(), ctx); vi\nERROR: type NamedTuple has no field x\n[...]\n\njulia> # If one does not know the varnames, we can use a `OrderedDict` instead.\n       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo{Float64}(OrderedDict()), ctx);\n\njulia> # (✓) Sort of fast, but only possible at runtime.\n       vi[@varname(x[1])]\n-1.019202452456547\n\njulia> # In addtion, we can only access varnames as they appear in the model!\n       vi[@varname(x)]\nERROR: KeyError: key x not found\n[...]\n\njulia> vi[@varname(x[1:2])]\nERROR: KeyError: key x[1:2] not found\n[...]\n\nTechnically, it's possible to use any implementation of AbstractDict in place of OrderedDict, but OrderedDict ensures that certain operations, e.g. linearization/flattening of the values in the varinfo, are consistent between evaluations. Hence OrderedDict is the preferred implementation of AbstractDict to use here.\n\nYou can also sample in transformed space:\n\njulia> @model demo_constrained() = x ~ Exponential()\ndemo_constrained (generic function with 2 methods)\n\njulia> m = demo_constrained();\n\njulia> _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo(), ctx);\n\njulia> vi[@varname(x)] # (✓) 0 ≤ x < ∞\n1.8632965762164932\n\njulia> _, vi = DynamicPPL.evaluate!!(m, DynamicPPL.settrans!!(SimpleVarInfo(), true), ctx);\n\njulia> vi[@varname(x)] # (✓) -∞ < x < ∞\n-0.21080155351918753\n\njulia> xs = [last(DynamicPPL.evaluate!!(m, DynamicPPL.settrans!!(SimpleVarInfo(), true), ctx))[@varname(x)] for i = 1:10];\n\njulia> any(xs .< 0)  # (✓) Positive probability mass on negative numbers!\ntrue\n\njulia> # And with `OrderedDict` of course!\n       _, vi = DynamicPPL.evaluate!!(m, DynamicPPL.settrans!!(SimpleVarInfo(OrderedDict()), true), ctx);\n\njulia> vi[@varname(x)] # (✓) -∞ < x < ∞\n0.6225185067787314\n\njulia> xs = [last(DynamicPPL.evaluate!!(m, DynamicPPL.settrans!!(SimpleVarInfo(), true), ctx))[@varname(x)] for i = 1:10];\n\njulia> any(xs .< 0) # (✓) Positive probability mass on negative numbers!\ntrue\n\nEvaluation in transformed space of course also works:\n\njulia> vi = DynamicPPL.settrans!!(SimpleVarInfo((x = -1.0,)), true)\nTransformed SimpleVarInfo((x = -1.0,), 0.0)\n\njulia> # (✓) Positive probability mass on negative numbers!\n       getlogp(last(DynamicPPL.evaluate!!(m, vi, DynamicPPL.DefaultContext())))\n-1.3678794411714423\n\njulia> # While if we forget to indicate that it's transformed:\n       vi = DynamicPPL.settrans!!(SimpleVarInfo((x = -1.0,)), false)\nSimpleVarInfo((x = -1.0,), 0.0)\n\njulia> # (✓) No probability mass on negative numbers!\n       getlogp(last(DynamicPPL.evaluate!!(m, vi, DynamicPPL.DefaultContext())))\n-Inf\n\nIndexing\n\nUsing NamedTuple as underlying storage.\n\njulia> svi_nt = SimpleVarInfo((m = (a = [1.0], ), ));\n\njulia> svi_nt[@varname(m)]\n(a = [1.0],)\n\njulia> svi_nt[@varname(m.a)]\n1-element Vector{Float64}:\n 1.0\n\njulia> svi_nt[@varname(m.a[1])]\n1.0\n\njulia> svi_nt[@varname(m.a[2])]\nERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]\n[...]\n\njulia> svi_nt[@varname(m.b)]\nERROR: type NamedTuple has no field b\n[...]\n\nUsing OrderedDict as underlying storage.\n\njulia> svi_dict = SimpleVarInfo(OrderedDict(@varname(m) => (a = [1.0], )));\n\njulia> svi_dict[@varname(m)]\n(a = [1.0],)\n\njulia> svi_dict[@varname(m.a)]\n1-element Vector{Float64}:\n 1.0\n\njulia> svi_dict[@varname(m.a[1])]\n1.0\n\njulia> svi_dict[@varname(m.a[2])]\nERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]\n[...]\n\njulia> svi_dict[@varname(m.b)]\nERROR: type NamedTuple has no field b\n[...]\n\n\n\n\n\n","category":"type"},{"location":"api/#Common-API","page":"API","title":"Common API","text":"","category":"section"},{"location":"api/#Accumulation-of-log-probabilities","page":"API","title":"Accumulation of log-probabilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"getlogp\nsetlogp!!\nacclogp!!\nresetlogp!!","category":"page"},{"location":"api/#DynamicPPL.getlogp","page":"API","title":"DynamicPPL.getlogp","text":"getlogp(vi::AbstractVarInfo)\n\nReturn the log of the joint probability of the observed data and parameters sampled in vi.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.setlogp!!","page":"API","title":"DynamicPPL.setlogp!!","text":"setlogp!!(vi::AbstractVarInfo, logp)\n\nSet the log of the joint probability of the observed data and parameters sampled in vi to logp, mutating if it makes sense.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.acclogp!!","page":"API","title":"DynamicPPL.acclogp!!","text":"acclogp!!([context::AbstractContext, ]vi::AbstractVarInfo, logp)\n\nAdd logp to the value of the log of the joint probability of the observed data and parameters sampled in vi, mutating if it makes sense.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.resetlogp!!","page":"API","title":"DynamicPPL.resetlogp!!","text":"resetlogp!!(vi::AbstractVarInfo)\n\nReset the value of the log of the joint probability of the observed data and parameters sampled in vi to 0, mutating if it makes sense.\n\n\n\n\n\n","category":"function"},{"location":"api/#Variables-and-their-realizations","page":"API","title":"Variables and their realizations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"keys\ngetindex\npush!!\nempty!!\nisempty\nDynamicPPL.getindex_internal\nDynamicPPL.setindex_internal!\nDynamicPPL.update_internal!\nDynamicPPL.insert_internal!\nDynamicPPL.length_internal\nDynamicPPL.reset!\nDynamicPPL.update!\nDynamicPPL.insert!\nDynamicPPL.loosen_types!!\nDynamicPPL.tighten_types","category":"page"},{"location":"api/#Base.keys","page":"API","title":"Base.keys","text":"keys(vi::AbstractVarInfo)\n\nReturn an iterator over all vns in vi.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.getindex","page":"API","title":"Base.getindex","text":"getindex(vi::AbstractVarInfo, vn::VarName[, dist::Distribution])\ngetindex(vi::AbstractVarInfo, vns::Vector{<:VarName}[, dist::Distribution])\n\nReturn the current value(s) of vn (vns) in vi in the support of its (their) distribution(s).\n\nIf dist is specified, the value(s) will be massaged into the representation expected by dist.\n\n\n\n\n\n","category":"function"},{"location":"api/#BangBang.push!!","page":"API","title":"BangBang.push!!","text":"push!!(vi::AbstractVarInfo, vn::VarName, r, dist::Distribution)\n\nPush a new random variable vn with a sampled value r from a distribution dist to the VarInfo vi, mutating if it makes sense.\n\n\n\n\n\npush!!(vi::AbstractVarInfo, vn::VarName, r, dist::Distribution, spl::AbstractSampler)\n\nPush a new random variable vn with a sampled value r sampled with a sampler spl from a distribution dist to VarInfo vi, if it makes sense.\n\nThe sampler is passed here to invalidate its cache where defined.\n\nwarning: Warning\nThis method is considered legacy, and is likely to be deprecated in the future.\n\n\n\n\n\npush!!(vi::AbstractVarInfo, vn::VarName, r, dist::Distribution, gid::Selector)\n\nPush a new random variable vn with a sampled value r sampled with a sampler of selector gid from a distribution dist to VarInfo vi.\n\nwarning: Warning\nThis method is considered legacy, and is likely to be deprecated in the future.\n\n\n\n\n\n","category":"function"},{"location":"api/#BangBang.empty!!","page":"API","title":"BangBang.empty!!","text":"empty!!(vi::AbstractVarInfo)\n\nEmpty the fields of vi.metadata and reset vi.logp[] and vi.num_produce[] to zeros.\n\nThis is useful when using a sampling algorithm that assumes an empty vi, e.g. SMC.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.isempty","page":"API","title":"Base.isempty","text":"isempty(vi::AbstractVarInfo)\n\nReturn true if vi is empty and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.getindex_internal","page":"API","title":"DynamicPPL.getindex_internal","text":"getindex_internal(vi::AbstractVarInfo, vn::VarName)\ngetindex_internal(vi::AbstractVarInfo, vns::Vector{<:VarName})\n\nReturn the current value(s) of vn (vns) in vi as represented internally in vi.\n\nSee also: getindex(vi::AbstractVarInfo, vn::VarName, dist::Distribution)\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.setindex_internal!","page":"API","title":"DynamicPPL.setindex_internal!","text":"setindex_internal!(vnv::VarNamedVector, val, i::Int)\n\nSets the ith element of the internal storage vector, ignoring inactive entries.\n\n\n\n\n\nsetindex_internal!(vnv::VarNamedVector, val, vn::VarName[, transform])\n\nLike setindex!, but sets the values as they are stored internally in vnv.\n\nOptionally can set the transformation, such that transform(val) is the original value of the variable. By default, the transform is the identity if creating a new entry in vnv, or the existing transform if updating an existing entry.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.update_internal!","page":"API","title":"DynamicPPL.update_internal!","text":"update_internal!(vnv::VarNamedVector, vn::VarName, val::AbstractVector[, transform])\n\nUpdate an existing entry for vn in vnv with the value val.\n\nLike setindex_internal!, but errors if the key vn doesn't exist.\n\ntransform should be a function that converts val to the original representation. By default it's the same as the old transform for vn.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.insert_internal!","page":"API","title":"DynamicPPL.insert_internal!","text":"insert_internal!(vnv::VarNamedVector, val::AbstractVector, vn::VarName[, transform])\n\nAdd a variable with given value to vnv.\n\nLike setindex_internal!, but errors if the key vn already exists.\n\ntransform should be a function that converts val to the original representation. By default it's identity.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.length_internal","page":"API","title":"DynamicPPL.length_internal","text":"length_internal(vnv::VarNamedVector)\n\nReturn the length of the internal storage vector of vnv, ignoring inactive entries.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.reset!","page":"API","title":"DynamicPPL.reset!","text":"reset!(vnv::VarNamedVector, val, vn::VarName)\n\nReset the value of vn in vnv to val.\n\nThis differs from setindex! in that it will always change the transform of the variable to be the default vectorisation transform. This undoes any possible linking.\n\nExamples\n\njulia> using DynamicPPL: VarNamedVector, @varname, reset!\n\njulia> vnv = VarNamedVector();\n\njulia> vnv[@varname(x)] = reshape(1:9, (3, 3));\n\njulia> setindex!(vnv, 2.0, @varname(x))\nERROR: An error occurred while assigning the value 2.0 to variable x. If you are changing the type or size of a variable you'll need to call reset!\n[...]\n\njulia> reset!(vnv, 2.0, @varname(x));\n\njulia> vnv[@varname(x)]\n2.0\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.update!","page":"API","title":"DynamicPPL.update!","text":"update!(vnv::VarNamedVector, val, vn::VarName)\n\nUpdate the value of vn in vnv to val.\n\nLike setindex!, but errors if the key vn doesn't exist.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.insert!","page":"API","title":"Base.insert!","text":"insert!(vnv::VarNamedVector, val, vn::VarName)\n\nAdd a variable with given value to vnv.\n\nLike setindex!, but errors if the key vn already exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.loosen_types!!","page":"API","title":"DynamicPPL.loosen_types!!","text":"loosen_types!!(vnv::VarNamedVector{K,V,TVN,TVal,TTrans}, ::Type{KNew}, ::Type{TransNew})\n\nLoosen the types of vnv to allow varname type KNew and transformation type TransNew.\n\nIf KNew is a subtype of K and TransNew is a subtype of the element type of the TTrans then this is a no-op and vnv is returned as is. Otherwise a new VarNamedVector is returned with the same data but more abstract types, so that variables of type KNew and transformations of type TransNew can be pushed to it. Some of the underlying storage is shared between vnv and the return value, and thus mutating one may affect the other.\n\nSee also\n\ntighten_types\n\nExamples\n\njulia> using DynamicPPL: VarNamedVector, @varname, loosen_types!!, setindex_internal!\n\njulia> vnv = VarNamedVector(@varname(x) => [1.0]);\n\njulia> y_trans(x) = reshape(x, (2, 2));\n\njulia> setindex_internal!(vnv, collect(1:4), @varname(y), y_trans)\nERROR: MethodError: Cannot `convert` an object of type\n[...]\n\njulia> vnv_loose = DynamicPPL.loosen_types!!(vnv, typeof(@varname(y)), typeof(y_trans));\n\njulia> setindex_internal!(vnv_loose, collect(1:4), @varname(y), y_trans)\n\njulia> vnv_loose[@varname(y)]\n2×2 Matrix{Float64}:\n 1.0  3.0\n 2.0  4.0\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.tighten_types","page":"API","title":"DynamicPPL.tighten_types","text":"tighten_types(vnv::VarNamedVector)\n\nReturn a copy of vnv with the most concrete types possible.\n\nFor instance, if vnv has its vector of transforms have eltype Any, but all the transforms are actually identity transformations, this function will return a new VarNamedVector with the transforms vector having eltype typeof(identity).\n\nThis is a lot like the reverse of loosen_types!!, but with two notable differences: Unlike loosen_types!!, this function does not mutate vnv; it also changes not only the key and transform eltypes, but also the values eltype.\n\nSee also\n\nloosen_types!!\n\nExamples\n\njulia> using DynamicPPL: VarNamedVector, @varname, loosen_types!!, setindex_internal!\n\njulia> vnv = VarNamedVector();\n\njulia> setindex!(vnv, [23], @varname(x))\n\njulia> eltype(vnv)\nReal\n\njulia> vnv.transforms\n1-element Vector{Any}:\n identity (generic function with 1 method)\n\njulia> vnv_tight = DynamicPPL.tighten_types(vnv);\n\njulia> eltype(vnv_tight) == Int\ntrue\n\njulia> vnv_tight.transforms\n1-element Vector{typeof(identity)}:\n identity (generic function with 1 method)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"values_as","category":"page"},{"location":"api/#DynamicPPL.values_as","page":"API","title":"DynamicPPL.values_as","text":"values_as(varinfo[, Type])\n\nReturn the values/realizations in varinfo as Type, if implemented.\n\nIf no Type is provided, return values as stored in varinfo.\n\nExamples\n\nSimpleVarInfo with NamedTuple:\n\njulia> data = (x = 1.0, m = [2.0]);\n\njulia> values_as(SimpleVarInfo(data))\n(x = 1.0, m = [2.0])\n\njulia> values_as(SimpleVarInfo(data), NamedTuple)\n(x = 1.0, m = [2.0])\n\njulia> values_as(SimpleVarInfo(data), OrderedDict)\nOrderedDict{VarName{sym, typeof(identity)} where sym, Any} with 2 entries:\n  x => 1.0\n  m => [2.0]\n\njulia> values_as(SimpleVarInfo(data), Vector)\n2-element Vector{Float64}:\n 1.0\n 2.0\n\nSimpleVarInfo with OrderedDict:\n\njulia> data = OrderedDict{Any,Any}(@varname(x) => 1.0, @varname(m) => [2.0]);\n\njulia> values_as(SimpleVarInfo(data))\nOrderedDict{Any, Any} with 2 entries:\n  x => 1.0\n  m => [2.0]\n\njulia> values_as(SimpleVarInfo(data), NamedTuple)\n(x = 1.0, m = [2.0])\n\njulia> values_as(SimpleVarInfo(data), OrderedDict)\nOrderedDict{Any, Any} with 2 entries:\n  x => 1.0\n  m => [2.0]\n\njulia> values_as(SimpleVarInfo(data), Vector)\n2-element Vector{Float64}:\n 1.0\n 2.0\n\nTypedVarInfo:\n\njulia> # Just use an example model to construct the `VarInfo` because we're lazy.\n       vi = VarInfo(DynamicPPL.TestUtils.demo_assume_dot_observe());\n\njulia> vi[@varname(s)] = 1.0; vi[@varname(m)] = 2.0;\n\njulia> # For the sake of brevity, let's just check the type.\n       md = values_as(vi); md.s isa Union{DynamicPPL.Metadata, DynamicPPL.VarNamedVector}\ntrue\n\njulia> values_as(vi, NamedTuple)\n(s = 1.0, m = 2.0)\n\njulia> values_as(vi, OrderedDict)\nOrderedDict{VarName{sym, typeof(identity)} where sym, Float64} with 2 entries:\n  s => 1.0\n  m => 2.0\n\njulia> values_as(vi, Vector)\n2-element Vector{Float64}:\n 1.0\n 2.0\n\nUntypedVarInfo:\n\njulia> # Just use an example model to construct the `VarInfo` because we're lazy.\n       vi = VarInfo(); DynamicPPL.TestUtils.demo_assume_dot_observe()(vi);\n\njulia> vi[@varname(s)] = 1.0; vi[@varname(m)] = 2.0;\n\njulia> # For the sake of brevity, let's just check the type.\n       values_as(vi) isa Union{DynamicPPL.Metadata, Vector}\ntrue\n\njulia> values_as(vi, NamedTuple)\n(s = 1.0, m = 2.0)\n\njulia> values_as(vi, OrderedDict)\nOrderedDict{VarName{sym, typeof(identity)} where sym, Float64} with 2 entries:\n  s => 1.0\n  m => 2.0\n\njulia> values_as(vi, Vector)\n2-element Vector{Real}:\n 1.0\n 2.0\n\n\n\n\n\n","category":"function"},{"location":"api/#Transformations","page":"API","title":"Transformations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.AbstractTransformation\nDynamicPPL.NoTransformation\nDynamicPPL.DynamicTransformation\nDynamicPPL.StaticTransformation","category":"page"},{"location":"api/#DynamicPPL.AbstractTransformation","page":"API","title":"DynamicPPL.AbstractTransformation","text":"abstract type AbstractTransformation\n\nRepresents a transformation to be used in link!! and invlink!!, amongst others.\n\nA concrete implementation of this should implement the following methods:\n\nlink!!: transforms the AbstractVarInfo to the unconstrained space.\ninvlink!!: transforms the AbstractVarInfo to the constrained space.\n\nAnd potentially:\n\nmaybe_invlink_before_eval!!: hook to decide whether to transform before evaluating the model.\n\nSee also: link!!, invlink!!, maybe_invlink_before_eval!!.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicPPL.NoTransformation","page":"API","title":"DynamicPPL.NoTransformation","text":"struct NoTransformation <: DynamicPPL.AbstractTransformation\n\nTransformation which applies the identity function.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicPPL.DynamicTransformation","page":"API","title":"DynamicPPL.DynamicTransformation","text":"struct DynamicTransformation <: DynamicPPL.AbstractTransformation\n\nTransformation which transforms the variables on a per-need-basis in the execution of a given Model.\n\nThis is in constrast to StaticTransformation which transforms all variables before the execution of a given Model.\n\nSee also: StaticTransformation.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicPPL.StaticTransformation","page":"API","title":"DynamicPPL.StaticTransformation","text":"struct StaticTransformation{F} <: DynamicPPL.AbstractTransformation\n\nTransformation which transforms all variables before the execution of a given Model.\n\nThis is done through the maybe_invlink_before_eval!! method.\n\nSee also: DynamicTransformation, maybe_invlink_before_eval!!.\n\nFields\n\nbijector::Any: The function, assumed to implement the Bijectors interface, to be applied to the variables\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.istrans\nDynamicPPL.settrans!!\nDynamicPPL.transformation\nDynamicPPL.link\nDynamicPPL.invlink\nDynamicPPL.link!!\nDynamicPPL.invlink!!\nDynamicPPL.default_transformation\nDynamicPPL.link_transform\nDynamicPPL.invlink_transform\nDynamicPPL.maybe_invlink_before_eval!!","category":"page"},{"location":"api/#DynamicPPL.istrans","page":"API","title":"DynamicPPL.istrans","text":"istrans(vnv::VarNamedVector, vn::VarName)\n\nReturn a boolean for whether vn is guaranteed to have been transformed so that its domain is all of Euclidean space.\n\n\n\n\n\nistrans(vi::AbstractVarInfo[, vns::Union{VarName, AbstractVector{<:Varname}}])\n\nReturn true if vi is working in unconstrained space, and false if vi is assuming realizations to be in support of the corresponding distributions.\n\nIf vns is provided, then only check if this/these varname(s) are transformed.\n\nwarning: Warning\nNot all implementations of AbstractVarInfo support transforming only a subset of the variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.settrans!!","page":"API","title":"DynamicPPL.settrans!!","text":"settrans!!(vi::AbstractVarInfo, trans::Bool[, vn::VarName])\n\nReturn vi with istrans(vi, vn) evaluating to true.\n\nIf vn is not specified, then istrans(vi) evaluates to true for all variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.transformation","page":"API","title":"DynamicPPL.transformation","text":"transformation(vi::AbstractVarInfo)\n\nReturn the AbstractTransformation related to vi.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bijectors.link","page":"API","title":"Bijectors.link","text":"link([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)\nlink([t::AbstractTransformation, ]vi::AbstractVarInfo, spl::AbstractSampler, model::Model)\n\nTransform the variables in vi to their linked space without mutating vi, using the transformation t.\n\nIf t is not provided, default_transformation(model, vi) will be used.\n\nSee also: default_transformation, invlink.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bijectors.invlink","page":"API","title":"Bijectors.invlink","text":"invlink([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)\ninvlink([t::AbstractTransformation, ]vi::AbstractVarInfo, spl::AbstractSampler, model::Model)\n\nTransform the variables in vi to their constrained space without mutating vi, using the (inverse of) transformation t.\n\nIf t is not provided, default_transformation(model, vi) will be used.\n\nSee also: default_transformation, link.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.link!!","page":"API","title":"DynamicPPL.link!!","text":"link!!([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)\nlink!!([t::AbstractTransformation, ]vi::AbstractVarInfo, spl::AbstractSampler, model::Model)\n\nTransform the variables in vi to their linked space, using the transformation t, mutating vi if possible.\n\nIf t is not provided, default_transformation(model, vi) will be used.\n\nSee also: default_transformation, invlink!!.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.invlink!!","page":"API","title":"DynamicPPL.invlink!!","text":"invlink!!([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)\ninvlink!!([t::AbstractTransformation, ]vi::AbstractVarInfo, spl::AbstractSampler, model::Model)\n\nTransform the variables in vi to their constrained space, using the (inverse of) transformation t, mutating vi if possible.\n\nIf t is not provided, default_transformation(model, vi) will be used.\n\nSee also: default_transformation, link!!.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.default_transformation","page":"API","title":"DynamicPPL.default_transformation","text":"default_transformation(model::Model[, vi::AbstractVarInfo])\n\nReturn the AbstractTransformation currently related to model and, potentially, vi.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.link_transform","page":"API","title":"DynamicPPL.link_transform","text":"link_transform(dist)\n\nReturn the constrained-to-unconstrained bijector for distribution dist.\n\nBy default, this is just Bijectors.bijector(dist).\n\nwarning: Warning\nNote that currently this is not used by Bijectors.logpdf_with_trans, hence that needs to be overloaded separately if the intention is to change behavior of an existing distribution.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.invlink_transform","page":"API","title":"DynamicPPL.invlink_transform","text":"invlink_transform(dist)\n\nReturn the unconstrained-to-constrained bijector for distribution dist.\n\nBy default, this is just inverse(link_transform(dist)).\n\nwarning: Warning\nNote that currently this is not used by Bijectors.logpdf_with_trans, hence that needs to be overloaded separately if the intention is to change behavior of an existing distribution.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.maybe_invlink_before_eval!!","page":"API","title":"DynamicPPL.maybe_invlink_before_eval!!","text":"maybe_invlink_before_eval!!([t::Transformation,] vi, context, model)\n\nReturn a possibly invlinked version of vi.\n\nThis will be called prior to model evaluation, allowing one to perform a single invlink!! before evaluation rather than lazyily evaluating the transforms on as-we-need basis as is done with DynamicTransformation.\n\nSee also: StaticTransformation, DynamicTransformation.\n\nExamples\n\njulia> using DynamicPPL, Distributions, Bijectors\n\njulia> @model demo() = x ~ Normal()\ndemo (generic function with 2 methods)\n\njulia> # By subtyping `Transform`, we inherit the `(inv)link!!`.\n       struct MyBijector <: Bijectors.Transform end\n\njulia> # Define some dummy `inverse` which will be used in the `link!!` call.\n       Bijectors.inverse(f::MyBijector) = identity\n\njulia> # We need to define `with_logabsdet_jacobian` for `MyBijector`\n       # (`identity` already has `with_logabsdet_jacobian` defined)\n       function Bijectors.with_logabsdet_jacobian(::MyBijector, x)\n           # Just using a large number of the logabsdet-jacobian term\n           # for demonstration purposes.\n           return (x, 1000)\n       end\n\njulia> # Change the `default_transformation` for our model to be a\n       # `StaticTransformation` using `MyBijector`.\n       function DynamicPPL.default_transformation(::Model{typeof(demo)})\n           return DynamicPPL.StaticTransformation(MyBijector())\n       end\n\njulia> model = demo();\n\njulia> vi = SimpleVarInfo(x=1.0)\nSimpleVarInfo((x = 1.0,), 0.0)\n\njulia> # Uses the `inverse` of `MyBijector`, which we have defined as `identity`\n       vi_linked = link!!(vi, model)\nTransformed SimpleVarInfo((x = 1.0,), 0.0)\n\njulia> # Now performs a single `invlink!!` before model evaluation.\n       logjoint(model, vi_linked)\n-1001.4189385332047\n\n\n\n\n\n","category":"function"},{"location":"api/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Base.merge(::AbstractVarInfo)\nDynamicPPL.subset\nDynamicPPL.unflatten\nDynamicPPL.varname_leaves\nDynamicPPL.varname_and_value_leaves","category":"page"},{"location":"api/#Base.merge-Tuple{AbstractVarInfo}","page":"API","title":"Base.merge","text":"merge(varinfo, other_varinfos...)\n\nMerge varinfos into one, giving precedence to the right-most varinfo when sensible.\n\nThis is particularly useful when combined with subset(varinfo, vns).\n\nSee docstring of subset(varinfo, vns) for examples.\n\n\n\n\n\n","category":"method"},{"location":"api/#DynamicPPL.subset","page":"API","title":"DynamicPPL.subset","text":"subset(varinfo::AbstractVarInfo, vns::AbstractVector{<:VarName})\n\nSubset a varinfo to only contain the variables vns.\n\nwarning: Warning\nThe ordering of the variables in the resulting varinfo is not guaranteed to follow the ordering of the variables in varinfo. Hence care must be taken, in particular when used in conjunction with other methods which uses the vector-representation of the varinfo, e.g. getindex(varinfo, sampler).\n\nExamples\n\njulia> @model function demo()\n           s ~ InverseGamma(2, 3)\n           m ~ Normal(0, sqrt(s))\n           x = Vector{Float64}(undef, 2)\n           x[1] ~ Normal(m, sqrt(s))\n           x[2] ~ Normal(m, sqrt(s))\n       end\ndemo (generic function with 2 methods)\n\njulia> model = demo();\n\njulia> varinfo = VarInfo(model);\n\njulia> keys(varinfo)\n4-element Vector{VarName}:\n s\n m\n x[1]\n x[2]\n\njulia> for (i, vn) in enumerate(keys(varinfo))\n           varinfo[vn] = i\n       end\n\njulia> varinfo[[@varname(s), @varname(m), @varname(x[1]), @varname(x[2])]]\n4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\njulia> # Extract one with only `m`.\n       varinfo_subset1 = subset(varinfo, [@varname(m),]);\n\n\njulia> keys(varinfo_subset1)\n1-element Vector{VarName{:m, typeof(identity)}}:\n m\n\njulia> varinfo_subset1[@varname(m)]\n2.0\n\njulia> # Extract one with both `s` and `x[2]`.\n       varinfo_subset2 = subset(varinfo, [@varname(s), @varname(x[2])]);\n\njulia> keys(varinfo_subset2)\n2-element Vector{VarName}:\n s\n x[2]\n\njulia> varinfo_subset2[[@varname(s), @varname(x[2])]]\n2-element Vector{Float64}:\n 1.0\n 4.0\n\nsubset is particularly useful when combined with merge(varinfo::AbstractVarInfo)\n\njulia> # Merge the two.\n       varinfo_subset_merged = merge(varinfo_subset1, varinfo_subset2);\n\njulia> keys(varinfo_subset_merged)\n3-element Vector{VarName}:\n m\n s\n x[2]\n\njulia> varinfo_subset_merged[[@varname(s), @varname(m), @varname(x[2])]]\n3-element Vector{Float64}:\n 1.0\n 2.0\n 4.0\n\njulia> # Merge the two with the original.\n       varinfo_merged = merge(varinfo, varinfo_subset_merged);\n\njulia> keys(varinfo_merged)\n4-element Vector{VarName}:\n s\n m\n x[1]\n x[2]\n\njulia> varinfo_merged[[@varname(s), @varname(m), @varname(x[1]), @varname(x[2])]]\n4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n\nNotes\n\nType-stability\n\nwarning: Warning\nThis function is only type-stable when vns contains only varnames with the same symbol. For exmaple, [@varname(m[1]), @varname(m[2])] will be type-stable, but [@varname(m[1]), @varname(x)] will not be.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.unflatten","page":"API","title":"DynamicPPL.unflatten","text":"unflatten(original, x::AbstractVector)\n\nReturn instance of original constructed from x.\n\n\n\n\n\nunflatten(vnv::VarNamedVector, vals::AbstractVector)\n\nReturn a new instance of vnv with the values of vals assigned to the variables.\n\nThis assumes that vals have been transformed by the same transformations that that the values in vnv have been transformed by. However, unlike replace_raw_storage, unflatten does account for inactive entries in vnv, so that the user does not have to care about them.\n\nThis is in a sense the reverse operation of vnv[:].\n\nUnflatten recontiguifies the internal storage, getting rid of any inactive entries.\n\nExamples\n\n```jldoctest varnamedvector-unflatten julia> using DynamicPPL: VarNamedVector, unflatten\n\njulia> vnv = VarNamedVector(@varname(x) => [1.0, 2.0], @varname(y) => [3.0]);\n\njulia> unflatten(vnv, vnv[:]) == vnv true\n\n\n\n\n\nunflatten(vi::AbstractVarInfo[, context::AbstractContext], x::AbstractVector)\n\nReturn a new instance of vi with the values of x assigned to the variables.\n\nIf context is provided, x is assumed to be realizations only for variables not filtered out by context.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.varname_leaves","page":"API","title":"DynamicPPL.varname_leaves","text":"varname_leaves(vn::VarName, val)\n\nReturn an iterator over all varnames that are represented by vn on val.\n\nExamples\n\njulia> using DynamicPPL: varname_leaves\n\njulia> foreach(println, varname_leaves(@varname(x), rand(2)))\nx[1]\nx[2]\n\njulia> foreach(println, varname_leaves(@varname(x[1:2]), rand(2)))\nx[1:2][1]\nx[1:2][2]\n\njulia> x = (y = 1, z = [[2.0], [3.0]]);\n\njulia> foreach(println, varname_leaves(@varname(x), x))\nx.y\nx.z[1][1]\nx.z[2][1]\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.varname_and_value_leaves","page":"API","title":"DynamicPPL.varname_and_value_leaves","text":"varname_and_value_leaves(vn::VarName, val)\n\nReturn an iterator over all varname-value pairs that are represented by vn on val.\n\nExamples\n\njulia> using DynamicPPL: varname_and_value_leaves\n\njulia> foreach(println, varname_and_value_leaves(@varname(x), 1:2))\n(x[1], 1)\n(x[2], 2)\n\njulia> foreach(println, varname_and_value_leaves(@varname(x[1:2]), 1:2))\n(x[1:2][1], 1)\n(x[1:2][2], 2)\n\njulia> x = (y = 1, z = [[2.0], [3.0]]);\n\njulia> foreach(println, varname_and_value_leaves(@varname(x), x))\n(x.y, 1)\n(x.z[1][1], 2.0)\n(x.z[2][1], 3.0)\n\nThere are also some special handling for certain types:\n\njulia> using LinearAlgebra\n\njulia> x = reshape(1:4, 2, 2);\n\njulia> # `LowerTriangular`\n       foreach(println, varname_and_value_leaves(@varname(x), LowerTriangular(x)))\n(x[1, 1], 1)\n(x[2, 1], 2)\n(x[2, 2], 4)\n\njulia> # `UpperTriangular`\n       foreach(println, varname_and_value_leaves(@varname(x), UpperTriangular(x)))\n(x[1, 1], 1)\n(x[1, 2], 3)\n(x[2, 2], 4)\n\njulia> # `Cholesky` with lower-triangular\n       foreach(println, varname_and_value_leaves(@varname(x), Cholesky([1.0 0.0; 0.0 1.0], 'L', 0)))\n(x.L[1, 1], 1.0)\n(x.L[2, 1], 0.0)\n(x.L[2, 2], 1.0)\n\njulia> # `Cholesky` with upper-triangular\n       foreach(println, varname_and_value_leaves(@varname(x), Cholesky([1.0 0.0; 0.0 1.0], 'U', 0)))\n(x.U[1, 1], 1.0)\n(x.U[1, 2], 0.0)\n(x.U[2, 2], 1.0)\n\n\n\n\n\nvarname_and_value_leaves(container)\n\nReturn an iterator over all varname-value pairs that are represented by container.\n\nThis is the same as varname_and_value_leaves(vn::VarName, x) but over a container containing multiple varnames.\n\nSee also: varname_and_value_leaves(vn::VarName, x).\n\nExamples\n\njulia> using DynamicPPL: varname_and_value_leaves\n\njulia> # With an `OrderedDict`\n       dict = OrderedDict(@varname(y) => 1, @varname(z) => [[2.0], [3.0]]);\n\njulia> foreach(println, varname_and_value_leaves(dict))\n(y, 1)\n(z[1][1], 2.0)\n(z[2][1], 3.0)\n\njulia> # With a `NamedTuple`\n       nt = (y = 1, z = [[2.0], [3.0]]);\n\njulia> foreach(println, varname_and_value_leaves(nt))\n(y, 1)\n(z[1][1], 2.0)\n(z[2][1], 3.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#Evaluation-Contexts","page":"API","title":"Evaluation Contexts","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Internally, both sampling and evaluation of log densities are performed with AbstractPPL.evaluate!!.","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractPPL.evaluate!!","category":"page"},{"location":"api/#AbstractPPL.evaluate!!","page":"API","title":"AbstractPPL.evaluate!!","text":"evaluate!!(model::Model[, rng, varinfo, sampler, context])\n\nSample from the model using the sampler with random number generator rng and the context, and store the sample and log joint probability in varinfo.\n\nReturns both the return-value of the original model, and the resulting varinfo.\n\nThe method resets the log joint probability of varinfo and increases the evaluation number of sampler.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The behaviour of a model execution can be changed with evaluation contexts that are passed as additional argument to the model function. Contexts are subtypes of AbstractPPL.AbstractContext.","category":"page"},{"location":"api/","page":"API","title":"API","text":"SamplingContext\nDefaultContext\nLikelihoodContext\nPriorContext\nMiniBatchContext\nPrefixContext","category":"page"},{"location":"api/#DynamicPPL.SamplingContext","page":"API","title":"DynamicPPL.SamplingContext","text":"SamplingContext(\n        [rng::Random.AbstractRNG=Random.default_rng()],\n        [sampler::AbstractSampler=SampleFromPrior()],\n        [context::AbstractContext=DefaultContext()],\n)\n\nCreate a context that allows you to sample parameters with the sampler when running the model. The context determines how the returned log density is computed when running the model.\n\nSee also: DefaultContext, LikelihoodContext, PriorContext\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicPPL.DefaultContext","page":"API","title":"DynamicPPL.DefaultContext","text":"struct DefaultContext <: AbstractContext end\n\nThe DefaultContext is used by default to compute the log joint probability of the data and parameters when running the model.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicPPL.LikelihoodContext","page":"API","title":"DynamicPPL.LikelihoodContext","text":"LikelihoodContext <: AbstractContext\n\nA leaf context resulting in the exclusion of prior terms when running the model.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicPPL.PriorContext","page":"API","title":"DynamicPPL.PriorContext","text":"PriorContext <: AbstractContext\n\nA leaf context resulting in the exclusion of likelihood terms when running the model.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicPPL.MiniBatchContext","page":"API","title":"DynamicPPL.MiniBatchContext","text":"struct MiniBatchContext{Tctx, T} <: AbstractContext\n    context::Tctx\n    loglike_scalar::T\nend\n\nThe MiniBatchContext enables the computation of log(prior) + s * log(likelihood of a batch) when running the model, where s is the loglike_scalar field, typically equal to the number of data points / batch size. This is useful in batch-based stochastic gradient descent algorithms to be optimizing log(prior) + log(likelihood of all the data points) in the expectation.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicPPL.PrefixContext","page":"API","title":"DynamicPPL.PrefixContext","text":"PrefixContext{Prefix}(context)\n\nCreate a context that allows you to use the wrapped context when running the model and adds the Prefix to all parameters.\n\nThis context is useful in nested models to ensure that the names of the parameters are unique.\n\nSee also: @submodel\n\n\n\n\n\n","category":"type"},{"location":"api/#Samplers","page":"API","title":"Samplers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In DynamicPPL two samplers are defined that are used to initialize unobserved random variables: SampleFromPrior which samples from the prior distribution, and SampleFromUniform which samples from a uniform distribution.","category":"page"},{"location":"api/","page":"API","title":"API","text":"SampleFromPrior\nSampleFromUniform","category":"page"},{"location":"api/#DynamicPPL.SampleFromPrior","page":"API","title":"DynamicPPL.SampleFromPrior","text":"SampleFromPrior\n\nSampling algorithm that samples unobserved random variables from their prior distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicPPL.SampleFromUniform","page":"API","title":"DynamicPPL.SampleFromUniform","text":"SampleFromUniform\n\nSampling algorithm that samples unobserved random variables from a uniform distribution.\n\nReferences\n\nStan reference manual\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Additionally, a generic sampler for inference is implemented.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Sampler","category":"page"},{"location":"api/#DynamicPPL.Sampler","page":"API","title":"DynamicPPL.Sampler","text":"Sampler{T}\n\nGeneric sampler type for inference algorithms of type T in DynamicPPL.\n\nSampler should implement the AbstractMCMC interface, and in particular AbstractMCMC.step. A default implementation of the initial sampling step is provided that supports resuming sampling from a previous state and setting initial parameter values. It requires to overload loadstate and initialstep for loading previous states and actually performing the initial sampling step, respectively. Additionally, sometimes one might want to implement initialsampler that specifies how the initial parameter values are sampled if they are not provided. By default, values are sampled from the prior.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"The default implementation of Sampler uses the following unexported functions.","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.initialstep\nDynamicPPL.loadstate\nDynamicPPL.initialsampler","category":"page"},{"location":"api/#DynamicPPL.initialstep","page":"API","title":"DynamicPPL.initialstep","text":"initialstep(rng, model, sampler, varinfo; kwargs...)\n\nPerform the initial sampling step of the sampler for the model.\n\nThe varinfo contains the initial samples, which can be provided by the user or sampled randomly.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.loadstate","page":"API","title":"DynamicPPL.loadstate","text":"loadstate(data)\n\nLoad sampler state from data.\n\nBy default, data is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.initialsampler","page":"API","title":"DynamicPPL.initialsampler","text":"initialsampler(sampler::Sampler)\n\nReturn the sampler that is used for generating the initial parameters when sampling with sampler.\n\nBy default, it returns an instance of SampleFromPrior.\n\n\n\n\n\n","category":"function"},{"location":"api/#model_internal","page":"API","title":"Model-Internal Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"tilde_assume\ndot_tilde_assume","category":"page"},{"location":"api/#DynamicPPL.tilde_assume","page":"API","title":"DynamicPPL.tilde_assume","text":"tilde_assume(context::SamplingContext, right, vn, vi)\n\nHandle assumed variables, e.g., x ~ Normal() (where x does occur in the model inputs), accumulate the log probability, and return the sampled value with a context associated with a sampler.\n\nFalls back to\n\ntilde_assume(context.rng, context.context, context.sampler, right, vn, vi)\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.dot_tilde_assume","page":"API","title":"DynamicPPL.dot_tilde_assume","text":"dot_tilde_assume(context::SamplingContext, right, left, vn, vi)\n\nHandle broadcasted assumed variables, e.g., x .~ MvNormal() (where x does not occur in the model inputs), accumulate the log probability, and return the sampled value for a context associated with a sampler.\n\nFalls back to\n\ndot_tilde_assume(context.rng, context.context, context.sampler, right, left, vn, vi)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"tilde_observe\ndot_tilde_observe","category":"page"},{"location":"api/#DynamicPPL.tilde_observe","page":"API","title":"DynamicPPL.tilde_observe","text":"tilde_observe(context::SamplingContext, right, left, vi)\n\nHandle observed constants with a context associated with a sampler.\n\nFalls back to tilde_observe(context.context, context.sampler, right, left, vi).\n\n\n\n\n\n","category":"function"},{"location":"api/#DynamicPPL.dot_tilde_observe","page":"API","title":"DynamicPPL.dot_tilde_observe","text":"dot_tilde_observe(context::SamplingContext, right, left, vi)\n\nHandle broadcasted observed constants, e.g., [1.0] .~ MvNormal(), accumulate the log probability, and return the observed value for a context associated with a sampler.\n\nFalls back to dot_tilde_observe(context.context, context.sampler, right, left, vi).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"internals/transformations/#Transforming-variables","page":"Transforming variables","title":"Transforming variables","text":"","category":"section"},{"location":"internals/transformations/#Motivation","page":"Transforming variables","title":"Motivation","text":"","category":"section"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"In a probabilistic programming language (PPL) such as DynamicPPL.jl, one crucial functionality for enabling a large number of inference algorithms to be implemented, in particular gradient-based ones, is the ability to work with \"unconstrained\" variables.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"For example, consider the following model:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"@model function demo()\n    s ~ InverseGamma(2, 3)\n    return m ~ Normal(0, √s)\nend","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Here we have two variables s and m, where s is constrained to be positive, while m can be any real number.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"For certain inference methods, it's necessary / much more convenient to work with an equivalent model to demo but where all the variables can take any real values (they're \"unconstrained\").","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"note: Note\nWe write \"unconstrained\" with quotes because there are many ways to transform a constrained variable to an unconstrained one, and DynamicPPL can work with a much broader class of bijective transformations of variables, not just ones that go to the entire real line. But for MCMC, unconstraining is the most common transformation so we'll stick with that terminology.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"For a large family of constraints encountered in practice, it is indeed possible to transform a (partially) constrained model to a completely unconstrained one in such a way that sampling in the unconstrained space is equivalent to sampling in the constrained space.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"In DynamicPPL.jl, this is often referred to as linking (a term originating in the statistics literature) and is done using transformations from Bijectors.jl.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"For example, the above model could be transformed into (the following pseudo-code; it's not working code):","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"@model function demo()\n    log_s ~ log(InverseGamma(2, 3))\n    s = exp(log_s)\n    return m ~ Normal(0, √s)\nend","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Here log_s is an unconstrained variable, and s is a constrained variable that is a deterministic function of log_s.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"But to ensure that we stay consistent with what the user expects, DynamicPPL.jl does not actually transform the model as above, but instead makes use of transformed variables internally to achieve the same effect, when desired.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"In the end, we'll end up with something that looks like this:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"%%{ init: { 'themeVariables': { 'lineColor': '#000000' } } }%%\n%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TD\n    subgraph assume [\"assume\"]\n        style assume fill:#ffffff,font-family:Courier\n\n        A[\"x ~ Normal()\"]:::boxStyle\n        B[\"vn = <span style='color:#3B6EA8 !important;'>@varname</span>(x)<br>dist = Normal()<br>x, vi = ...\"]:::boxStyle\n        C[\"assume(vn, dist, vi)\"]:::boxStyle\n        D([\"<span style='color:#3B6EA8 !important;'>if</span> istrans(vi, vn)\"]):::boxStyle\n        E[\"f = from_internal_transform(vi, vn, dist)\"]:::boxStyle\n        F[\"f = from_linked_internal_transform(vi, vn, dist)\"]:::boxStyle\n        G[\"x, logjac = with_logabsdet_jacobian(f, getindex_internal(vi, vn, dist))\"]:::boxStyle\n        H[\"<span style='color:#3B6EA8 !important;'>return</span> x, logpdf(dist, x) - logjac, vi\"]:::boxStyle\n        \n        A -.->|<span style='color:#3B6EA8 ; background-color:#ffffff;'>@model</span>| B\n        B -.->|<span style='color:#000000 ; background-color:#ffffff;'>tilde-pipeline</span>| C\n        C --> D\n        D -->|<span style='color:#97365B ; background-color:#ffffff;'>false</span>| E\n        D -->|<span style='color:#97365B ; background-color:#ffffff;'>true</span>| F\n        E --> G\n        F --> G\n        G --> H\n    end\n\n    classDef boxStyle fill:#ffffff,stroke:#000000,font-family:Courier,color:#000000\n    \n    linkStyle default stroke:#000000,stroke-width:1px,color:#000000","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Below we'll see how this is done.","category":"page"},{"location":"internals/transformations/#What-do-we-need?","page":"Transforming variables","title":"What do we need?","text":"","category":"section"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"There are two aspects to transforming from the internal representation of a variable in a varinfo to the representation wanted in the model:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Different implementations of AbstractVarInfo represent realizations of a model in different ways internally, so we need to transform from this internal representation to the desired representation in the model. For example,\nVarInfo represents a realization of a model as a \"flattened\" / vector representation, regardless of the form of the variable in the model.\nSimpleVarInfo represents a realization of a model exactly as in the model (unless it has been transformed; we'll get to that later).\nWe need the ability to transform from \"constrained space\" to \"unconstrained space\", as we saw in the previous section.","category":"page"},{"location":"internals/transformations/#Working-example","page":"Transforming variables","title":"Working example","text":"","category":"section"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"A good and non-trivial example to keep in mind throughout is the following model:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"using DynamicPPL, Distributions\n@model demo_lkj() = x ~ LKJCholesky(2, 1.0)","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"LKJCholesky is a LKJ(2, 1.0) distribution, a distribution over correlation matrices (covariance matrices but with unit diagonal), but working directly with the Cholesky factorization of the correlation matrix rather than the correlation matrix itself (this is more numerically stable and computationally efficient).","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"note: Note\nThis is a particularly \"annoying\" case because the return-value is not a simple Real or AbstractArray{<:Real}, but rather a LineraAlgebra.Cholesky object which wraps a triangular matrix (whether it's upper- or lower-triangular depends on the instance).","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"As mentioned, some implementations of AbstractVarInfo, e.g. VarInfo, works with a \"flattened\" / vector representation of a variable, and so in this case we need two transformations:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"From the Cholesky object to a vector representation.\nFrom the Cholesky object to an \"unconstrained\" / linked vector representation.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"And similarly, we'll need the inverses of these transformations.","category":"page"},{"location":"internals/transformations/#From-internal-representation-to-model-representation","page":"Transforming variables","title":"From internal representation to model representation","text":"","category":"section"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"To go from the internal variable representation of an AbstractVarInfo to the variable representation wanted in the model, e.g. from a Vector{Float64} to Cholesky in the case of VarInfo in demo_lkj, we have the following methods:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"DynamicPPL.to_internal_transform\nDynamicPPL.from_internal_transform","category":"page"},{"location":"internals/transformations/#DynamicPPL.to_internal_transform","page":"Transforming variables","title":"DynamicPPL.to_internal_transform","text":"to_internal_transform(varinfo::AbstractVarInfo, vn::VarName[, dist])\n\nReturn a transformation that transforms from a representation compatible with dist to the internal representation of vn with dist in varinfo.\n\nIf dist is not present, then it is assumed that varinfo knows the correct output for vn.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/#DynamicPPL.from_internal_transform","page":"Transforming variables","title":"DynamicPPL.from_internal_transform","text":"from_internal_transform(varinfo::AbstractVarInfo, vn::VarName[, dist])\n\nReturn a transformation that transforms from the internal representation of vn with dist in varinfo to a representation compatible with dist.\n\nIf dist is not present, then it is assumed that varinfo knows the correct output for vn.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"These methods allow us to extract the internal-to-model transformation function depending on the varinfo, the variable, and the distribution of the variable:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"varinfo + vn defines the internal representation of the variable.\ndist defines the representation expected within the model scope.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"note: Note\nIf vn is not present in varinfo, then the internal representation is fully determined by varinfo alone. This is used when we're about to add a new variable to the varinfo and need to know how to represent it internally.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Continuing from the example above, we can inspect the internal representation of x in demo_lkj with VarInfo using DynamicPPL.getindex_internal:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"model = demo_lkj()\nvarinfo = VarInfo(model)\nx_internal = DynamicPPL.getindex_internal(varinfo, @varname(x))","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"f_from_internal = DynamicPPL.from_internal_transform(\n    varinfo, @varname(x), LKJCholesky(2, 1.0)\n)\nf_from_internal(x_internal)","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Let's confirm that this is the same as varinfo[@varname(x)]:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"x_model = varinfo[@varname(x)]","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Similarly, we can go from the model representation to the internal representation:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"f_to_internal = DynamicPPL.to_internal_transform(varinfo, @varname(x), LKJCholesky(2, 1.0))\n\nf_to_internal(x_model)","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"It's also useful to see how this is done in SimpleVarInfo:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"simple_varinfo = SimpleVarInfo(varinfo)\nDynamicPPL.getindex_internal(simple_varinfo, @varname(x))","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Here see that the internal representation is exactly the same as the model representation, and so we'd expect from_internal_transform to be the identity function:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"DynamicPPL.from_internal_transform(simple_varinfo, @varname(x), LKJCholesky(2, 1.0))","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Great!","category":"page"},{"location":"internals/transformations/#From-*unconstrained*-internal-representation-to-model-representation","page":"Transforming variables","title":"From unconstrained internal representation to model representation","text":"","category":"section"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"In addition to going from internal representation to model representation of a variable, we also need to be able to go from the unconstrained internal representation to the model representation.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"For this, we have the following methods:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"DynamicPPL.to_linked_internal_transform\nDynamicPPL.from_linked_internal_transform","category":"page"},{"location":"internals/transformations/#DynamicPPL.to_linked_internal_transform","page":"Transforming variables","title":"DynamicPPL.to_linked_internal_transform","text":"to_linked_internal_transform(varinfo::AbstractVarInfo, vn::VarName[, dist])\n\nReturn a transformation that transforms from a representation compatible with dist to the linked internal representation of vn with dist in varinfo.\n\nIf dist is not present, then it is assumed that varinfo knows the correct output for vn.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/#DynamicPPL.from_linked_internal_transform","page":"Transforming variables","title":"DynamicPPL.from_linked_internal_transform","text":"from_linked_internal_transform(varinfo::AbstractVarInfo, vn::VarName[, dist])\n\nReturn a transformation that transforms from the linked internal representation of vn with dist in varinfo to a representation compatible with dist.\n\nIf dist is not present, then it is assumed that varinfo knows the correct output for vn.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"These are very similar to DynamicPPL.to_internal_transform and DynamicPPL.from_internal_transform, but here the internal representation is also linked / \"unconstrained\".","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Continuing from the example above:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"f_to_linked_internal = DynamicPPL.to_linked_internal_transform(\n    varinfo, @varname(x), LKJCholesky(2, 1.0)\n)\n\nx_linked_internal = f_to_linked_internal(x_model)","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"f_from_linked_internal = DynamicPPL.from_linked_internal_transform(\n    varinfo, @varname(x), LKJCholesky(2, 1.0)\n)\n\nf_from_linked_internal(x_linked_internal)","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Here we see a significant difference between the linked representation and the non-linked representation: the linked representation is only of length 1, whereas the non-linked representation is of length 4. This is because we actually only need a single element to represent a 2x2 correlation matrix, as the diagonal elements are always 1 and it's symmetric.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"We can also inspect the transforms themselves:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"f_from_internal","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"vs.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"f_from_linked_internal","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Here we see that f_from_linked_internal is a single function taking us directly from the linked representation to the model representation, whereas f_from_internal is a composition of a few functions: one reshaping the underlying length 4 array into 2x2 matrix, and the other converting this matrix into a Cholesky, as required to be compatible with LKJCholesky(2, 1.0).","category":"page"},{"location":"internals/transformations/#Why-do-we-need-both-to_internal_transform-and-to_linked_internal_transform?","page":"Transforming variables","title":"Why do we need both to_internal_transform and to_linked_internal_transform?","text":"","category":"section"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"One might wonder why we need both to_internal_transform and to_linked_internal_transform instead of just a single to_internal_transform which returns the \"standard\" internal representation if the variable is not linked / \"unconstrained\" and the linked / \"unconstrained\" internal representation if it is.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"That is, why can't we just do","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\n%%{ init: { 'themeVariables': { 'lineColor': '#000000' } } }%%\ngraph TD\n    subgraph assume [\"assume\"]\n        style assume fill:#ffffff,font-family:Courier\n\n        A[\"assume(varinfo, <span style='color:#3B6EA8 !important;'>@varname</span>(x), Normal())\"]:::boxStyle\n        B[\"f = from_internal_transform(varinfo, varname, dist)\"]:::boxStyle\n        C[\"x, logjac = with_logabsdet_jacobian(f, assume_internal(varinfo, varname, dist))\"]:::boxStyle\n        D[\"<span style='color:#3B6EA8 !important;'>return</span> x, logpdf(dist, x) - logjac, varinfo\"]:::dashedBox\n        \n        A --> B\n        B --> C\n        C --> D\n    end\n\n    classDef dashedBox fill:#ffffff,stroke:#000000,stroke-dasharray: 5 5,font-family:Courier,color:#000000\n    classDef boxStyle fill:#ffffff,stroke:#000000,font-family:Courier,color:#000000\n\n    linkStyle default stroke:#000000,stroke-width:1px,color:#000000","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Unfortunately, this is not possible in general. Consider for example the following model:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"@model function demo_dynamic_constraint()\n    m ~ Normal()\n    x ~ truncated(Normal(); lower=m)\n\n    return (m=m, x=x)\nend","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Here the variable x is constrained to be in the domain (m, Inf), where m is sampled according to a Normal.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"model = demo_dynamic_constraint()\nvarinfo = VarInfo(model)\nvarinfo[@varname(m)], varinfo[@varname(x)]","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"We see that the realization of x is indeed greater than m, as expected.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"But what if we link this varinfo so that we end up working on an \"unconstrained\" space, i.e. both m and x can take on any values in (-Inf, Inf):","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"varinfo_linked = link(varinfo, model)\nvarinfo_linked[@varname(m)], varinfo_linked[@varname(x)]","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Still get the same values, as expected, since internally varinfo transforms from the linked internal representation to the model representation.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"But what if we change the value of m, to, say, a bit larger than x?","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"# Update realization for `m` in `varinfo_linked`.\nvarinfo_linked[@varname(m)] = varinfo_linked[@varname(x)] + 1\nvarinfo_linked[@varname(m)], varinfo_linked[@varname(x)]","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Now we see that the constraint m < x is no longer satisfied!","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Hence one might expect that if we try to compute, say, the logjoint using varinfo_linked with this \"invalid\" realization, we'll get an error:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"logjoint(model, varinfo_linked)","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"But we don't! In fact, if we look at the actual value used within the model","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"first(DynamicPPL.evaluate!!(model, varinfo_linked, DefaultContext()))","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"we see that we indeed satisfy the constraint m < x, as desired.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"warning: Warning\nOne shouldn't be setting variables in a linked varinfo willy-nilly directly like this unless one knows that the value will be compatible with the constraints of the model.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"The reason for this is that internally in a model evaluation, we construct the transformation from the internal to the model representation based on the current realizations in the model! That is, we take the dist in a x ~ dist expression at model evaluation time and use that to construct the transformation, thus allowing it to change between model evaluations without invalidating the transformation.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"But to be able to do this, we need to know whether the variable is linked / \"unconstrained\" or not, since the transformation is different in the two cases. Hence we need to be able to determine this at model evaluation time. Hence the internals end up looking something like this:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"if istrans(varinfo, varname)\n    from_linked_internal_transform(varinfo, varname, dist)\nelse\n    from_internal_transform(varinfo, varname, dist)\nend","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"That is, if the variable is linked / \"unconstrained\", we use the DynamicPPL.from_linked_internal_transform, otherwise we use DynamicPPL.from_internal_transform.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"And so the earlier diagram becomes:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\n%%{ init: { 'themeVariables': { 'lineColor': '#000000' } } }%%\ngraph TD\n    subgraph assume [\"assume\"]\n        style assume fill:#ffffff,font-family:Courier\n\n        A[\"assume(varinfo, <span style='color:#3B6EA8 !important;'>@varname</span>(x), Normal())\"]:::boxStyle\n        B([\"<span style='color:#3B6EA8 !important;'>if</span> istrans(varinfo, varname)\"]):::boxStyle\n        C[\"f = from_internal_transform(varinfo, varname, dist)\"]:::boxStyle\n        D[\"f = from_linked_internal_transform(varinfo, varname, dist)\"]:::boxStyle\n        E[\"x, logjac = with_logabsdet_jacobian(f, assume_internal(varinfo, varname, dist))\"]:::boxStyle\n        F[\"<span style='color:#3B6EA8 !important;'>return</span> x, logpdf(dist, x) - logjac, varinfo\"]:::dashedBox\n        \n        A --> B\n        B -->|<span style='color:#97365B ; background-color:#ffffff;'>false</span>| C\n        B -->|<span style='color:#97365B ; background-color:#ffffff;'>true</span>| D\n        C --> E\n        D --> E\n        E --> F\n    end\n\n    classDef dashedBox fill:#ffffff,stroke:#000000,stroke-dasharray: 5 5,font-family:Courier,color:#000000\n    classDef boxStyle fill:#ffffff,stroke:#000000,font-family:Courier,color:#000000\n\n    linkStyle default stroke:#000000,stroke-width:1px,color:#000000","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"note: Note\nIf the support of dist was constant, this would not be necessary since we could just determine the transformation at the time of varinfo_linked = link(varinfo, model) and define this as the from_internal_transform for all subsequent evaluations. However, since the support of dist is not constant in general, we need to be able to determine the transformation at the time of the evaluation and thus whether we should construct the transformation from the linked internal representation or the non-linked internal representation. This is annoying, but necessary.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"This is also the reason why we have two definitions of getindex:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"getindex(::AbstractVarInfo, ::VarName, ::Distribution): used internally in model evaluations with the dist in a x ~ dist expression.\ngetindex(::AbstractVarInfo, ::VarName): used externally by the user to get the realization of a variable.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"For getindex we have the following diagram:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\n%%{ init: { 'themeVariables': { 'lineColor': '#000000' } } }%%\ngraph TD\n    subgraph getindex [\"getindex\"]\n        style getindex fill:#ffffff,font-family:Courier\n\n        A[\"x = getindex(varinfo, <span style='color:#3B6EA8 !important;'>@varname</span>(x), Normal())\"]:::boxStyle\n        B([\"<span style='color:#3B6EA8 !important;'>if</span> istrans(varinfo, varname)\"]):::boxStyle\n        C[\"f = from_internal_transform(varinfo, varname, dist)\"]:::boxStyle\n        D[\"f = from_linked_internal_transform(varinfo, varname, dist)\"]:::boxStyle\n        E[\"<span style='color:#3B6EA8 !important;'>return</span> f(getindex_internal(varinfo, varname))\"]:::dashedBox\n        \n        A --> B\n        B -->|<span style='color:#97365B ; background-color:#ffffff;'>false</span>| C\n        B -->|<span style='color:#97365B ; background-color:#ffffff;'>true</span>| D\n        C --> E\n        D --> E\n    end\n\n    classDef dashedBox fill:#ffffff,stroke:#000000,stroke-dasharray: 5 5,font-family:Courier,color:#000000\n    classDef boxStyle fill:#ffffff,stroke:#000000,font-family:Courier,color:#000000\n\n    linkStyle default stroke:#000000,stroke-width:1px,color:#000000","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"While if dist is not provided, we have:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\n%%{ init: { 'themeVariables': { 'lineColor': '#000000' } } }%%\ngraph TD\n    subgraph getindex [\"getindex\"]\n        style getindex fill:#ffffff,font-family:Courier\n\n        A[\"x = getindex(varinfo, <span style='color:#3B6EA8 !important;'>@varname</span>(x))\"]:::boxStyle\n        B([\"<span style='color:#3B6EA8 !important;'>if</span> istrans(varinfo, varname)\"]):::boxStyle\n        C[\"f = from_internal_transform(varinfo, varname)\"]:::boxStyle\n        D[\"f = from_linked_internal_transform(varinfo, varname)\"]:::boxStyle\n        E[\"<span style='color:#3B6EA8 !important;'>return</span> f(getindex_internal(varinfo, varname))\"]:::dashedBox\n        \n        A --> B\n        B -->|<span style='color:#97365B ; background-color:#ffffff;'>false</span>| C\n        B -->|<span style='color:#97365B ; background-color:#ffffff;'>true</span>| D\n        C --> E\n        D --> E\n    end\n\n    classDef dashedBox fill:#ffffff,stroke:#000000,stroke-dasharray: 5 5,font-family:Courier,color:#000000\n    classDef boxStyle fill:#ffffff,stroke:#000000,font-family:Courier,color:#000000\n\n    linkStyle default stroke:#000000,stroke-width:1px,color:#000000","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Notice that dist is not present here, but otherwise the diagrams are the same.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"warning: Warning\nThis does mean that the getindex(varinfo, varname) might not be the same as the getindex(varinfo, varname, dist) that occurs within a model evaluation! This can be confusing, but as outlined above, we do want to allow the dist in a x ~ dist expression to \"override\" whatever transformation varinfo might have.","category":"page"},{"location":"internals/transformations/#Other-functionalities","page":"Transforming variables","title":"Other functionalities","text":"","category":"section"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"There are also some additional methods for transforming between representations that are all automatically implemented from DynamicPPL.from_internal_transform, DynamicPPL.from_linked_internal_transform and their siblings, and thus don't need to be implemented manually.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Convenience methods for constructing transformations:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"DynamicPPL.from_maybe_linked_internal_transform\nDynamicPPL.to_maybe_linked_internal_transform\nDynamicPPL.internal_to_linked_internal_transform\nDynamicPPL.linked_internal_to_internal_transform","category":"page"},{"location":"internals/transformations/#DynamicPPL.from_maybe_linked_internal_transform","page":"Transforming variables","title":"DynamicPPL.from_maybe_linked_internal_transform","text":"from_maybe_linked_internal_transform(varinfo::AbstractVarInfo, vn::VarName[, dist])\n\nReturn a transformation that transforms from the possibly linked internal representation of vn with distn in varinfo to a representation compatible with dist.\n\nIf dist is not present, then it is assumed that varinfo knows the correct output for vn.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/#DynamicPPL.to_maybe_linked_internal_transform","page":"Transforming variables","title":"DynamicPPL.to_maybe_linked_internal_transform","text":"to_maybe_linked_internal_transform(varinfo::AbstractVarInfo, vn::VarName[, dist])\n\nReturn a transformation that transforms from a representation compatible with dist to a possibly linked internal representation of vn with dist in varinfo.\n\nIf dist is not present, then it is assumed that varinfo knows the correct output for vn.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/#DynamicPPL.internal_to_linked_internal_transform","page":"Transforming variables","title":"DynamicPPL.internal_to_linked_internal_transform","text":"internal_to_linked_internal_transform(varinfo::AbstractVarInfo, vn::VarName, dist)\n\nReturn a transformation that transforms from the internal representation of vn with dist in varinfo to a linked internal representation of vn with dist in varinfo.\n\nIf dist is not present, then it is assumed that varinfo knows the correct output for vn.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/#DynamicPPL.linked_internal_to_internal_transform","page":"Transforming variables","title":"DynamicPPL.linked_internal_to_internal_transform","text":"linked_internal_to_internal_transform(varinfo::AbstractVarInfo, vn::VarName[, dist])\n\nReturn a transformation that transforms from a linked internal representation of vn with dist in varinfo to the internal representation of vn with dist in varinfo.\n\nIf dist is not present, then it is assumed that varinfo knows the correct output for vn.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Convenience methods for transforming between representations without having to explicitly construct the transformation:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"DynamicPPL.to_maybe_linked_internal\nDynamicPPL.from_maybe_linked_internal","category":"page"},{"location":"internals/transformations/#DynamicPPL.to_maybe_linked_internal","page":"Transforming variables","title":"DynamicPPL.to_maybe_linked_internal","text":"to_maybe_linked_internal(vi::AbstractVarInfo, vn::VarName, dist, val)\n\nReturn reconstructed val, possibly linked if istrans(vi, vn) is true.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/#DynamicPPL.from_maybe_linked_internal","page":"Transforming variables","title":"DynamicPPL.from_maybe_linked_internal","text":"from_maybe_linked_internal(vi::AbstractVarInfo, vn::VarName, dist, val)\n\nReturn reconstructed val, possibly invlinked if istrans(vi, vn) is true.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/#Supporting-a-new-distribution","page":"Transforming variables","title":"Supporting a new distribution","text":"","category":"section"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"To support a new distribution, one needs to implement for the desired AbstractVarInfo the following methods:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"DynamicPPL.from_internal_transform\nDynamicPPL.from_linked_internal_transform","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"At the time of writing, VarInfo is the one that is most commonly used, whose internal representation is always a Vector. In this scenario, one can just implement the following methods instead:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"DynamicPPL.from_vec_transform(::Distribution)\nDynamicPPL.from_linked_vec_transform(::Distribution)","category":"page"},{"location":"internals/transformations/#DynamicPPL.from_vec_transform-Tuple{Distribution}","page":"Transforming variables","title":"DynamicPPL.from_vec_transform","text":"from_vec_transform(dist::Distribution)\n\nReturn the transformation from the vector representation of a realization from distribution dist to the original representation compatible with dist.\n\n\n\n\n\n","category":"method"},{"location":"internals/transformations/#DynamicPPL.from_linked_vec_transform-Tuple{Distribution}","page":"Transforming variables","title":"DynamicPPL.from_linked_vec_transform","text":"from_linked_vec_transform(dist::Distribution)\n\nReturn the transformation from the unconstrained vector to the constrained realization of distribution dist.\n\nBy default, this is just invlink_transform(dist) ∘ from_vec_transform(dist).\n\nSee also: DynamicPPL.invlink_transform, DynamicPPL.from_vec_transform.\n\n\n\n\n\n","category":"method"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"These are used internally by VarInfo.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"Optionally, if inverse of the above is expensive to compute, one can also implement:","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"DynamicPPL.to_internal_transform\nDynamicPPL.to_linked_internal_transform","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"And similarly, there are corresponding to-methods for the from_*_vec_transform variants too","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"DynamicPPL.to_vec_transform\nDynamicPPL.to_linked_vec_transform","category":"page"},{"location":"internals/transformations/#DynamicPPL.to_vec_transform","page":"Transforming variables","title":"DynamicPPL.to_vec_transform","text":"to_vec_transform(x)\n\nReturn the transformation from the original representation of x to the vector representation.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/#DynamicPPL.to_linked_vec_transform","page":"Transforming variables","title":"DynamicPPL.to_linked_vec_transform","text":"to_linked_vec_transform(dist)\n\nReturn the transformation from the constrained realization of distribution dist to the unconstrained vector.\n\n\n\n\n\n","category":"function"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"warning: Warning\nWhatever the resulting transformation is, it should be invertible, i.e. implement InverseFunctions.inverse, and have a well-defined log-abs-det Jacobian, i.e. implement ChangesOfVariables.with_logabsdet_jacobian.","category":"page"},{"location":"internals/transformations/#TL;DR","page":"Transforming variables","title":"TL;DR","text":"","category":"section"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"DynamicPPL.jl has three representations of a variable: the model representation, the internal representation, and the linked internal representation.\nThe model representation is the representation of the variable as it appears in the model code / is expected by the dist on the right-hand-side of the ~ in the model code.\nThe internal representation is the representation of the variable as it appears in the varinfo, which varies between implementations of AbstractVarInfo, e.g. a Vector in VarInfo. This can be converted to the model representation by DynamicPPL.from_internal_transform.\nThe linked internal representation is the representation of the variable as it appears in the varinfo after linking. This can be converted to the model representation by DynamicPPL.from_linked_internal_transform.\nHaving separation between internal and linked internal is necessary because transformations might be constructed at the time of model evaluation, and thus we need to know whether to construct the transformation from the internal representation or the linked internal representation.","category":"page"},{"location":"internals/transformations/","page":"Transforming variables","title":"Transforming variables","text":"","category":"page"},{"location":"#DynamicPPL.jl","page":"Home","title":"DynamicPPL.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A domain-specific language and backend for probabilistic programming languages, used by Turing.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
