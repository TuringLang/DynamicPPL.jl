<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DynamicPPL</title><meta name="title" content="API · DynamicPPL"/><meta property="og:title" content="API · DynamicPPL"/><meta property="twitter:title" content="API · DynamicPPL"/><meta name="description" content="Documentation for DynamicPPL."/><meta property="og:description" content="Documentation for DynamicPPL."/><meta property="twitter:description" content="Documentation for DynamicPPL."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body>
<!-- NAVBAR START -->
<style>
    @import url('https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap');

    /* Documenter.jl CSS Overrides */
    html {
        scroll-padding-top: calc(var(--navbar-height) + 1rem);
    }
    .docs-sidebar, #documenter {
        margin-top: var(--navbar-height);
    }
    .docs-version-selector {
        margin-bottom: 60px !important;
    }
    @media screen and (max-width: 1056px) {
        .docs-version-selector {
            margin-bottom: 60px !important;
        }
        .docs-sidebar {
            margin-top: 0 !important;
        }
    }
    /* End of Documenter.jl Tweaks */

    /* Color and Font Variables */
    :root {
        --heading-color: #6c757d;
        --item-color: rgb(165, 165, 165);
        --primary-bg: white;
        --hover-color: #8faad2;
        --deprecated-bg: #ff4d4d;
        --deprecated-text: white;
        --icon-color: #6c757d;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --dropdown-hover-bg: #e9ecef;
        
        /* Typography */
        --font-family: "Source Sans Pro", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        --nav-link-font-size: 1.0625rem;
        --turing-title-font-size: 21.25px;
        --icon-font-size: 1.25rem;
        --dropdown-arrow-font-size: 0.6875rem;
        --badge-font-size: 0.75rem;

        /* Sizing and Spacing */
        --navbar-height: 3.75rem;
        --logo-height: 31px;
        --logo-width: auto;
        --logo-padding-top: 7px;
        --logo-margin-left: 0.8rem;
        --title-margin-left: 0.4px;
        --title-nav-spacing: 1.1rem;
        --nav-item-margin-left: 1.3rem;
        --icon-margin-left: 1rem;
        --dropdown-padding: 1.875rem;
        --dropdown-item-width: 12.5rem;
        --dropdown-subitem-width: 15.625rem;
        --dropdown-subitem-padding: 0.125rem 0.625rem;
    }

    /* Dark Theme Variable Overrides */
    html.theme--documenter-dark {
        --heading-color: #e0e0e0;
        --item-color: #bdbdbd;
        --primary-bg: #1f2424;
        --hover-color: #ffffff;
        --icon-color: #e0e0e0;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #424242;
    }

    /* Catppuccin Theme Overrides */
    html.theme--catppuccin-latte {
        --heading-color: #4c4f69;
        --primary-bg: #eff1f5;
        --icon-color: #4c4f69;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --dropdown-hover-bg: #e6e9ef;
    }
    html.theme--catppuccin-frappe {
        --heading-color: #c6d0f5;
        --primary-bg: #303446;
        --icon-color: #c6d0f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #51576d;
    }
    html.theme--catppuccin-macchiato {
        --heading-color: #cad3f5;
        --primary-bg: #24273a;
        --icon-color: #cad3f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #494d64;
    }
    html.theme--catppuccin-mocha {
        --heading-color: #cad3f5;
        --primary-bg: #1e1e2e;
        --icon-color: #cad3f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #45475a;
    }


    /* Main Navigation Bar */
    .ext-navigation {
        font-family: var(--font-family);
        position: fixed;
        height: var(--navbar-height);
        top: 0;
        width: 100%;
        background-color: var(--primary-bg);
        z-index: 1000;
        box-shadow: 0 2px 4px var(--shadow-color);
        display: flex;
        align-items: center;
        padding: 0 1.0625rem;
        transition: transform 0.3s, background-color 0.3s;
    }

    nav.ext-navigation .ext-navbar-logo {
        margin-left: var(--logo-margin-left);
        height: auto;
        max-height: var(--logo-height);
        width: auto;
        padding-top: var(--logo-padding-top);
    }
    
    /* Theme-aware logo text color */
    .ext-navbar-logo .logo-text {
        fill: var(--heading-color);
    }
    
    .ext-navbar-title {
        color: var(--heading-color) !important;
        font-size: var(--turing-title-font-size) !important;
        margin-left: var(--title-margin-left);
        text-decoration: none;
        transition: color 0.2s ease;
    }
    
    .ext-navbar-title:hover {
        color: var(--hover-color) !important;
    }

    .ext-nav-links {
        display: flex;
        align-items: center;
        list-style-type: none;
        margin: 0;
        padding: 0;
        flex-grow: 1;
        margin-left: var(--title-nav-spacing);
    }

    .ext-nav-links li:first-child {
        margin-left: 0 !important;
    }

    .ext-nav-links li {
        margin-left: var(--nav-item-margin-left) !important;
    }

    .ext-nav-link {
        color: var(--heading-color) !important;
        text-decoration: none;
        font-size: var(--nav-link-font-size) !important;
        transition: color 0.2s ease;
        cursor: pointer;
    }

    .ext-nav-link:hover,
    .ext-navbar-item-single a:hover,
    .ext-navbar-icons a:hover {
        color: var(--hover-color) !important;
    }

    .ext-navbar-item-single a {
        color: var(--heading-color) !important;
    }
    
    .ext-navbar-icons {
        display: flex;
        align-items: center;
    }

    .ext-navbar-icons a {
        color: var(--icon-color) !important;
        font-size: var(--icon-font-size) !important;
        transition: color 0.2s ease;
        margin-left: var(--icon-margin-left);
    }

    .ext-menu-toggle {
        display: none;
        font-size: 1.5rem;
        color: var(--heading-color);
        cursor: pointer;
    }

    .ext-dropdown {
        display: none;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        padding: var(--dropdown-padding);
        position: absolute;
        top: var(--navbar-height);
        width: 100%;
        left: 0;
        background-color: var(--primary-bg);
        line-height: 1.875rem;
        opacity: 0;
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out, background-color 0.3s;
        transform: translateY(-0.625rem);
        box-shadow: 0 4px 6px var(--shadow-color);
    }

    #library-handler::after {
        content: "▼";
        font-size: var(--dropdown-arrow-font-size);
        margin-left: 0.3125rem;
        transition: transform 0.3s ease-in-out;
    }

    #library-handler.open::after {
        content: "▲";
    }

    .ext-dropdown.show {
        display: grid;
        opacity: 1;
        transform: translateY(0);
    }

    .ext-dropdown ul {
        width: var(--dropdown-item-width);
        margin-bottom: 1.25rem;
    }

    .ext-dropdown ul li {
        text-align: left;
        display: flex;
        align-items: center;
    }

    .ext-dropdown ul a li {
        color: var(--item-color);
        width: var(--dropdown-subitem-width);
        border-radius: 3px;
        padding: var(--dropdown-subitem-padding);
        transition: background-color 0.2s ease;
    }

    .ext-dropdown ul a li:hover {
        background-color: var(--dropdown-hover-bg);
    }

    .ext-dropdown-item-heading {
        color: var(--heading-color);
        text-align: center;
    }

    .deprecated-badge {
        background-color: var(--deprecated-bg);
        color: var(--deprecated-text);
        font-size: var(--badge-font-size);
        padding: .1rem;
        border-radius: 3px;
        margin-left: 0.5rem;
        line-height: 1;
    }

    @media (max-width: 966px) {
        .ext-dropdown {
            grid-template-columns: 1fr 1fr 1fr;
        }
    }

    @media (max-width: 768px) {
        .ext-nav-links {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            background-color: var(--primary-bg);
            position: absolute;
            top: var(--navbar-height);
            left: 0;
            padding: 0.625rem 0;
            height: auto;
            overflow-y: auto;
            box-shadow: 0 4px 6px var(--shadow-color);
            margin-left: 0;
        }

        .ext-nav-links.show {
            display: flex;
        }

        .ext-nav-links li {
            margin: 0.625rem 0 !important;
            text-align: center;
        }
        
        .ext-menu-toggle {
            display: block;
            margin-left: auto;
        }

        .ext-navigation.hide {
            transform: translateY(calc(-1 * var(--navbar-height)));
        }

        .ext-dropdown {
            position: static;
            display: block;
            opacity: 1;
            transform: none;
            box-shadow: none;
            grid-template-columns: 1fr;
            padding: 0.625rem;
            text-align: center;
        }

        .ext-dropdown ul {
            width: auto;
            display: inline-block;
            margin: 0 auto 0.3125rem;
            text-align: left;
        }
    }
</style>
<nav class="ext-navigation">
    <a href="https://turinglang.org/">
        <svg width="4333" height="1145" viewBox="0 0 4333 1145" fill="none" xmlns="http://www.w3.org/2000/svg" class="ext-navbar-logo">
            <path class="logo-text" d="M0.44603 193.181V66.9868H663.471V193.181H406.62V898H257.297V193.181H0.44603ZM1097.24 635.874V274.74H1244.13V898H1101.7V787.225H1095.21C1081.14 822.121 1058.01 850.66 1025.82 872.842C993.902 895.024 954.542 906.115 907.744 906.115C866.896 906.115 830.783 897.053 799.403 878.929C768.295 860.534 743.948 833.889 726.365 798.993C708.782 763.826 699.99 721.356 699.99 671.581V274.74H846.878V648.858C846.878 688.353 857.699 719.733 879.34 742.997C900.981 766.261 929.385 777.893 964.551 777.893C986.192 777.893 1007.16 772.618 1027.45 762.068C1047.73 751.518 1064.37 735.828 1077.35 714.999C1090.61 693.899 1097.24 667.524 1097.24 635.874ZM1395.17 898V274.74H1537.6V378.617H1544.09C1555.45 342.639 1574.93 314.911 1602.52 295.434C1630.38 275.687 1662.17 265.813 1697.88 265.813C1705.99 265.813 1715.05 266.219 1725.06 267.031C1735.34 267.572 1743.86 268.518 1750.63 269.871V404.992C1744.4 402.828 1734.53 400.934 1721 399.311C1707.75 397.417 1694.9 396.471 1682.46 396.471C1655.68 396.471 1631.6 402.287 1610.23 413.919C1589.13 425.28 1572.49 441.105 1560.32 461.393C1548.15 481.682 1542.06 505.081 1542.06 531.591V898H1395.17ZM1848.21 898V274.74H1995.1V898H1848.21ZM1922.06 186.283C1898.8 186.283 1878.78 178.573 1862.01 163.154C1845.24 147.464 1836.85 128.664 1836.85 106.752C1836.85 84.5701 1845.24 65.7695 1862.01 50.3503C1878.78 34.6606 1898.8 26.8158 1922.06 26.8158C1945.6 26.8158 1965.61 34.6606 1982.12 50.3503C1998.89 65.7695 2007.27 84.5701 2007.27 106.752C2007.27 128.664 1998.89 147.464 1982.12 163.154C1965.61 178.573 1945.6 186.283 1922.06 186.283ZM2293.04 532.809V898H2146.15V274.74H2286.54V380.646H2293.85C2308.18 345.75 2331.04 318.022 2362.42 297.463C2394.07 276.904 2433.16 266.625 2479.69 266.625C2522.7 266.625 2560.17 275.822 2592.09 294.217C2624.28 312.612 2649.17 339.257 2666.75 374.153C2684.6 409.049 2693.39 451.385 2693.12 501.159V898H2546.24V523.882C2546.24 482.223 2535.41 449.626 2513.77 426.092C2492.4 402.557 2462.78 390.79 2424.91 390.79C2399.21 390.79 2376.35 396.471 2356.34 407.832C2336.59 418.923 2321.03 435.019 2309.67 456.119C2298.58 477.218 2293.04 502.782 2293.04 532.809ZM3113.5 1144.71C3060.75 1144.71 3015.44 1137.54 2977.57 1123.2C2939.7 1109.13 2909.26 1090.2 2886.27 1066.39C2863.28 1042.59 2847.32 1016.21 2838.39 987.269L2970.67 955.213C2976.62 967.386 2985.28 979.424 2996.64 991.327C3008 1003.5 3023.28 1013.51 3042.49 1021.35C3061.97 1029.47 3086.45 1033.53 3115.93 1033.53C3157.59 1033.53 3192.08 1023.38 3219.4 1003.09C3246.73 983.076 3260.39 950.074 3260.39 904.087V786.008H3253.08C3245.51 801.157 3234.42 816.711 3219.81 832.671C3205.47 848.632 3186.4 862.022 3162.6 872.842C3139.06 883.663 3109.44 889.073 3073.73 889.073C3025.85 889.073 2982.44 877.847 2943.48 855.394C2904.8 832.671 2873.96 798.857 2850.97 753.952C2828.24 708.777 2816.88 652.24 2816.88 584.341C2816.88 515.902 2828.24 458.147 2850.97 411.078C2873.96 363.739 2904.93 327.896 2943.89 303.55C2982.84 278.933 3026.26 266.625 3074.14 266.625C3110.66 266.625 3140.69 272.847 3164.22 285.29C3188.03 297.463 3206.96 312.206 3221.03 329.519C3235.09 346.561 3245.78 362.657 3253.08 377.805H3261.2V274.74H3406.06V908.144C3406.06 961.435 3393.34 1005.53 3367.92 1040.42C3342.49 1075.32 3307.73 1101.43 3263.63 1118.74C3219.54 1136.05 3169.5 1144.71 3113.5 1144.71ZM3114.72 773.835C3145.83 773.835 3172.34 766.261 3194.25 751.112C3216.16 735.963 3232.79 714.187 3244.16 685.783C3255.52 657.379 3261.2 623.295 3261.2 583.53C3261.2 544.305 3255.52 509.95 3244.16 480.465C3233.07 450.979 3216.56 428.12 3194.65 411.89C3173.01 395.389 3146.37 387.138 3114.72 387.138C3081.98 387.138 3054.66 395.659 3032.75 412.701C3010.84 429.744 2994.34 453.143 2983.25 482.899C2972.16 512.385 2966.61 545.929 2966.61 583.53C2966.61 621.672 2972.16 655.08 2983.25 683.754C2994.61 712.158 3011.25 734.34 3033.16 750.3C3055.34 765.99 3082.53 773.835 3114.72 773.835ZM3647.08 906.927C3622.47 906.927 3601.37 898.271 3583.78 880.958C3566.2 863.645 3557.54 842.545 3557.82 817.658C3557.54 793.312 3566.2 772.482 3583.78 755.17C3601.37 737.857 3622.47 729.2 3647.08 729.2C3670.89 729.2 3691.58 737.857 3709.17 755.17C3727.02 772.482 3736.08 793.312 3736.35 817.658C3736.08 834.159 3731.75 849.173 3723.37 862.698C3715.25 876.224 3704.43 887.044 3690.91 895.16C3677.65 903.004 3663.04 906.927 3647.08 906.927ZM3888.01 274.74H4034.9V933.708C4034.9 978.613 4026.38 1015.67 4009.33 1044.89C3992.29 1074.1 3967.67 1095.88 3935.48 1110.22C3903.29 1124.55 3864.2 1131.72 3818.22 1131.72C3812.81 1131.72 3807.8 1131.59 3803.2 1131.32C3798.6 1131.32 3793.6 1131.18 3788.19 1130.91V1011.21C3792.25 1011.48 3795.9 1011.62 3799.15 1011.62C3802.39 1011.89 3805.77 1012.02 3809.29 1012.02C3837.42 1012.02 3857.58 1005.12 3869.75 991.327C3881.92 977.801 3888.01 957.918 3888.01 931.679V274.74ZM3961.05 186.283C3937.51 186.283 3917.36 178.573 3900.59 163.154C3884.09 147.464 3875.84 128.664 3875.84 106.752C3875.84 84.5701 3884.09 65.7695 3900.59 50.3503C3917.36 34.6606 3937.51 26.8158 3961.05 26.8158C3984.31 26.8158 4004.19 34.6606 4020.7 50.3503C4037.47 65.7695 4045.85 84.5701 4045.85 106.752C4045.85 128.664 4037.47 147.464 4020.7 163.154C4004.19 178.573 3984.31 186.283 3961.05 186.283ZM4332.83 66.9868V898H4185.94V66.9868H4332.83Z" fill="currentColor"/>
            <path d="M4076 108.5C4076 168.424 4027.42 217 3967.5 217C3907.58 217 3859 168.424 3859 108.5C3859 48.5762 3907.58 0 3967.5 0C4027.42 0 4076 48.5762 4076 108.5Z" fill="#389725"/>
            <path d="M3755 814.5C3755 874.424 3706.42 923 3646.5 923C3586.58 923 3538 874.424 3538 814.5C3538 754.576 3586.58 706 3646.5 706C3706.42 706 3755 754.576 3755 814.5Z" fill="#9457B1"/>
            <path d="M2030 108.5C2030 168.424 1981.42 217 1921.5 217C1861.58 217 1813 168.424 1813 108.5C1813 48.5762 1861.58 0 1921.5 0C1981.42 0 2030 48.5762 2030 108.5Z" fill="#CA3B33"/>
        </svg>
    </a>
    <!-- <a class="ext-navbar-title" href="https://turinglang.org/">Turing.jl</a> -->
    
    <ul class="ext-nav-links">
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/getting-started/">Get Started</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/tutorials/">Tutorials</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/faq/">FAQ</a></li>
        <li>
            <p class="ext-nav-link" id="library-handler">Libraries</p>
            <div class="ext-dropdown" id="ext-dropdown-items">
                <ul>
                    <li class="ext-dropdown-item-heading">Modelling Languages</li>
                    <a href="https://turinglang.org/DynamicPPL.jl/"><li>DynamicPPL</li></a>
                    <a href="https://turinglang.org/JuliaBUGS.jl/"><li>JuliaBUGS</li></a>
                    <a href="https://turinglang.org/TuringGLM.jl/"><li>TuringGLM</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">MCMC</li>
                    <a href="https://turinglang.org/AdvancedHMC.jl/"><li>AdvancedHMC</li></a>
                    <a href="https://turinglang.org/AbstractMCMC.jl/"><li>AbstractMCMC</li></a>
                    <a href="https://github.com/theogf/ThermodynamicIntegration.jl"><li>ThermodynamicIntegration</li></a>
                    <a href="https://turinglang.org/AdvancedPS.jl/"><li>AdvancedPS</li></a>
                    <a href="https://turinglang.org/SliceSampling.jl/"><li>SliceSampling</li></a>
                    <a href="https://turinglang.org/EllipticalSliceSampling.jl/"><li>EllipticalSliceSampling</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">Diagnostics</li>
                    <a href="https://turinglang.org/MCMCChains.jl/"><li>MCMCChains</li></a>
                    <a href="https://turinglang.org/MCMCDiagnosticTools.jl/"><li>MCMCDiagnosticTools</li></a>
                    <a href="https://chalk-lab.github.io/ParetoSmooth.jl/"><li>ParetoSmooth</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">Gaussian Processes</li>
                    <a href="https://juliagaussianprocesses.github.io/AbstractGPs.jl/"><li>AbstractGPs</li></a>
                    <a href="https://juliagaussianprocesses.github.io/KernelFunctions.jl/"><li>KernelFunctions</li></a>
                    <a href="https://juliagaussianprocesses.github.io/ApproximateGPs.jl/"><li>ApproximateGPs</li></a>
                </ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/Bijectors.jl/">Bijectors</a></li></ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/TuringCallbacks.jl/">TuringCallbacks</a></li></ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/Deprecated/TuringBenchmarking/">TuringBenchmarking</a><span class="deprecated-badge">Deprecated</span></li></ul>
            </div>
        </li>
        <li><a class="ext-nav-link" href="https://turinglang.org/news/">News</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/team/">Team</a></li>
    </ul>

    <div class="ext-navbar-icons">
        <a href="https://x.com/TuringLang" aria-label="Turing on X"><i class="fa-brands fa-x-twitter"></i></a>
        <a href="https://discourse.julialang.org/c/domain/probprog/48" aria-label="Turing on Discourse"><i class="fa-brands fa-discourse"></i></a>
        <a href="https://julialang.slack.com/archives/CCYDC34A0" aria-label="Turing on Slack"><i class="fa-brands fa-slack"></i></a>
        <a href="https://github.com/TuringLang/" aria-label="Turing.jl on GitHub"><i class="fa-brands fa-github"></i></a>
    </div>

    <span class="ext-menu-toggle"><i class="fa-solid fa-bars"></i></span>
</nav>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const menuToggle = document.querySelector(".ext-menu-toggle");
        const navLinks = document.querySelector(".ext-nav-links");
        const nav = document.querySelector(".ext-navigation");
        const libraryHandler = document.getElementById("library-handler");
        const dropdownContainer = document.getElementById("ext-dropdown-items");
        let lastScrollY = window.scrollY;

        function closeDropdown() {
            if (dropdownContainer.classList.contains("show")) {
                libraryHandler.classList.remove("open");
                dropdownContainer.classList.remove("show");
                setTimeout(() => {
                    if (!dropdownContainer.classList.contains("show")) {
                        dropdownContainer.style.display = "none";
                    }
                }, 300);
            }
        }

        function openDropdown() {
            dropdownContainer.style.display = "grid";
            libraryHandler.classList.add("open");
            setTimeout(() => {
                dropdownContainer.classList.add("show");
            }, 10);
        }

        function setAppropriateHeight() {
            if (window.innerWidth <= 768) {
                const viewportHeight = window.innerHeight;
                const navHeight = nav.offsetHeight;
                navLinks.style.maxHeight = `${viewportHeight - navHeight}px`;
                navLinks.style.overflowY = "auto";
            } else {
                navLinks.style.maxHeight = "";
                navLinks.style.overflowY = "";
            }
        }

        menuToggle.addEventListener("click", (event) => {
            event.stopPropagation();
            navLinks.classList.toggle("show");
            if (navLinks.classList.contains("show")) {
                setAppropriateHeight();
                closeDropdown();
                dropdownContainer.style.display = "none";
            }
        });

        libraryHandler.addEventListener("click", (event) => {
            event.stopPropagation();
            event.preventDefault();
            if (dropdownContainer.classList.contains("show")) {
                closeDropdown();
            } else {
                openDropdown();
            }
            setAppropriateHeight();
        });

        // Close all menus if a click is registered outside the navigation bar.
        document.addEventListener("click", (event) => {
            if (!nav.contains(event.target)) {
                navLinks.classList.remove("show");
                closeDropdown();
            }
        });

        // Hide navigation bar on scroll down in mobile view.
        window.addEventListener("scroll", () => {
            if (window.innerWidth <= 768) {
                if (window.scrollY > lastScrollY && window.scrollY > nav.offsetHeight){
                    nav.classList.add("hide");
                } else {
                    nav.classList.remove("hide");
                }
                lastScrollY = window.scrollY;
            }
        });

        window.addEventListener("resize", setAppropriateHeight);
    });
</script>
<!-- NAVBAR END -->



<div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="DynamicPPL logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DynamicPPL</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Model"><span>Model</span></a></li><li><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li><li><a class="tocitem" href="#Condition-and-decondition"><span>Condition and decondition</span></a></li><li><a class="tocitem" href="#Fixing-and-unfixing"><span>Fixing and unfixing</span></a></li><li><a class="tocitem" href="#Predicting"><span>Predicting</span></a></li><li><a class="tocitem" href="#Marginalisation"><span>Marginalisation</span></a></li><li><a class="tocitem" href="#Models-within-models"><span>Models within models</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#AD-testing-and-benchmarking-utilities"><span>AD testing and benchmarking utilities</span></a></li><li><a class="tocitem" href="#Demo-models"><span>Demo models</span></a></li><li><a class="tocitem" href="#Debugging-Utilities"><span>Debugging Utilities</span></a></li><li><a class="tocitem" href="#Advanced"><span>Advanced</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TuringLang/DynamicPPL.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/TuringLang/DynamicPPL.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>Part of the API of DynamicPPL is defined in the more lightweight interface package <a href="https://github.com/TuringLang/AbstractPPL.jl">AbstractPPL.jl</a> and reexported here.</p><h2 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h2><h3 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h3><p>A core component of DynamicPPL is the <a href="#DynamicPPL.@model"><code>@model</code></a> macro. It can be used to define probabilistic models in an intuitive way by specifying random variables and their distributions with <code>~</code> statements. These statements are rewritten by <code>@model</code> as calls of internal functions for sampling the variables and computing their log densities.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.@model"><a class="docstring-binding" href="#DynamicPPL.@model"><code>DynamicPPL.@model</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@model(expr[, warn = false])</code></pre><p>Macro to specify a probabilistic model.</p><p>If <code>warn</code> is <code>true</code>, a warning is displayed if internal variable names are used in the model definition.</p><p><strong>Examples</strong></p><p>Model definition:</p><pre><code class="language-julia hljs">@model function model(x, y = 42)
    ...
end</code></pre><p>To generate a <code>Model</code>, call <code>model(xvalue)</code> or <code>model(xvalue, yvalue)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/compiler.jl#L274-L293">source</a></section></details></article><h3 id="Type"><a class="docs-heading-anchor" href="#Type">Type</a><a id="Type-1"></a><a class="docs-heading-anchor-permalink" href="#Type" title="Permalink"></a></h3><p>A <a href="#Model"><code>Model</code></a> can be created by calling the model function, as defined by <a href="#DynamicPPL.@model"><code>@model</code></a>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.Model"><a class="docstring-binding" href="#DynamicPPL.Model"><code>DynamicPPL.Model</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Model{F,argnames,defaultnames,missings,Targs,Tdefaults,Ctx&lt;:AbstractContext}
    f::F
    args::NamedTuple{argnames,Targs}
    defaults::NamedTuple{defaultnames,Tdefaults}
    context::Ctx=DefaultContext()
end</code></pre><p>A <code>Model</code> struct with model evaluation function of type <code>F</code>, arguments of names <code>argnames</code> types <code>Targs</code>, default arguments of names <code>defaultnames</code> with types <code>Tdefaults</code>, missing arguments <code>missings</code>, and evaluation context of type <code>Ctx</code>.</p><p>Here <code>argnames</code>, <code>defaultargnames</code>, and <code>missings</code> are tuples of symbols, e.g. <code>(:a, :b)</code>. <code>context</code> is by default <code>DefaultContext()</code>.</p><p>An argument with a type of <code>Missing</code> will be in <code>missings</code> by default. However, in non-traditional use-cases <code>missings</code> can be defined differently. All variables in <code>missings</code> are treated as random variables rather than observations.</p><p>The default arguments are used internally when constructing instances of the same model with different arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Model(f, (x = 1.0, y = 2.0))
Model{typeof(f),(:x, :y),(),(),Tuple{Float64,Float64},Tuple{}}(f, (x = 1.0, y = 2.0), NamedTuple())

julia&gt; Model(f, (x = 1.0, y = 2.0), (x = 42,))
Model{typeof(f),(:x, :y),(:x,),(),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))

julia&gt; Model{(:y,)}(f, (x = 1.0, y = 2.0), (x = 42,)) # with special definition of missings
Model{typeof(f),(:x, :y),(:x,),(:y,),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L1-L35">source</a></section></details></article><p><a href="#Model"><code>Model</code></a>s are callable structs.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.Model-Tuple{}"><a class="docstring-binding" href="#DynamicPPL.Model-Tuple{}"><code>DynamicPPL.Model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(model::Model)([rng, varinfo])</code></pre><p>Sample from the prior of the <code>model</code> with random number generator <code>rng</code>.</p><p>Returns the model&#39;s return value.</p><p>Note that calling this with an existing <code>varinfo</code> object will mutate it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L847-L855">source</a></section></details></article><p>Basic properties of a model can be accessed with <a href="#DynamicPPL.getargnames"><code>getargnames</code></a>, <a href="#DynamicPPL.getmissings"><code>getmissings</code></a>, and <a href="#Base.nameof-Tuple{Model}"><code>nameof</code></a>.</p><article><details class="docstring" open="true"><summary id="Base.nameof-Tuple{Model}"><a class="docstring-binding" href="#Base.nameof-Tuple{Model}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nameof(model::Model)</code></pre><p>Get the name of the <code>model</code> as <code>Symbol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L1023-L1027">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getargnames"><a class="docstring-binding" href="#DynamicPPL.getargnames"><code>DynamicPPL.getargnames</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getargnames(model::Model)</code></pre><p>Get a tuple of the argument names of the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L1009-L1013">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getmissings"><a class="docstring-binding" href="#DynamicPPL.getmissings"><code>DynamicPPL.getmissings</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getmissings(model::Model)</code></pre><p>Get a tuple of the names of the missing arguments of the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L1016-L1020">source</a></section></details></article><p>The context of a model can be set using <a href="#DynamicPPL.contextualize"><code>contextualize</code></a>:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.contextualize"><a class="docstring-binding" href="#DynamicPPL.contextualize"><code>DynamicPPL.contextualize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">contextualize(model::Model, context::AbstractContext)</code></pre><p>Return a new <code>Model</code> with the same evaluation function and other arguments, but with its underlying context set to <code>context</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L88-L93">source</a></section></details></article><h2 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h2><p>With <a href="#Base.rand"><code>rand</code></a> one can draw samples from the prior distribution of a <a href="#Model"><code>Model</code></a>.</p><article><details class="docstring" open="true"><summary id="Base.rand"><a class="docstring-binding" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rand([rng=Random.default_rng()], [T=NamedTuple], model::Model)</code></pre><p>Generate a sample of type <code>T</code> from the prior distribution of the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L1031-L1035">source</a></section></details></article><p>One can also evaluate the log prior, log likelihood, and log joint probability.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.logprior"><a class="docstring-binding" href="#DynamicPPL.logprior"><code>DynamicPPL.logprior</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logprior(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log prior probability of variables <code>varinfo</code> for the probabilistic <code>model</code>.</p><p>Note that this probability always refers to the parameters in unlinked space, i.e., the return value of <code>logprior</code> does not depend on whether <code>VarInfo</code> has been linked or not.</p><p>See also <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L1061-L1071">source</a></section><section><div><pre><code class="language-julia hljs">logprior(model::Model, θ::Union{NamedTuple,AbstractDict})</code></pre><p>Return the log prior probability of variables <code>θ</code> for the probabilistic <code>model</code>.</p><p>See also <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1.0)
           end
       end
demo (generic function with 2 methods)

julia&gt; # Using a `NamedTuple`.
       logprior(demo([1.0]), (m = 100.0, ))
-5000.918938533205

julia&gt; # Using a `OrderedDict`.
       logprior(demo([1.0]), OrderedDict(@varname(m) =&gt; 100.0))
-5000.918938533205

julia&gt; # Truth.
       logpdf(Normal(), 100.0)
-5000.918938533205</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/simple_varinfo.jl#L546-L575">source</a></section><section><div><pre><code class="language-julia hljs">logprior(model::DynamicPPL.Model, chain::MCMCChains.Chains)</code></pre><p>Return an array of log prior probabilities evaluated at each sample in an MCMC <code>chain</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MCMCChains, Distributions

julia&gt; @model function demo_model(x)
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, sqrt(s))
           for i in eachindex(x)
               x[i] ~ Normal(m, sqrt(s))
           end
       end;

julia&gt; # Construct a chain of samples using MCMCChains.
       # This sets s = 0.5 and m = 1.0 for all three samples.
       chain = Chains(repeat([0.5 1.0;;;], 3, 1, 1), [:s, :m]);

julia&gt; logprior(demo_model([1., 2.]), chain)
3×1 Matrix{Float64}:
 -3.2956988239086447
 -3.2956988239086447
 -3.2956988239086447</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMCMCChainsExt.jl#L570-L598">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.loglikelihood"><a class="docstring-binding" href="#StatsAPI.loglikelihood"><code>StatsAPI.loglikelihood</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">loglikelihood(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log likelihood of variables <code>varinfo</code> for the probabilistic <code>model</code>.</p><p>See also <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#DynamicPPL.logprior"><code>logprior</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L1083-L1089">source</a></section><section><div><pre><code class="language-julia hljs">loglikelihood(model::Model, θ::Union{NamedTuple,AbstractDict})</code></pre><p>Return the log likelihood of variables <code>θ</code> for the probabilistic <code>model</code>.</p><p>See also <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#DynamicPPL.logprior"><code>logprior</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1.0)
           end
       end
demo (generic function with 2 methods)

julia&gt; # Using a `NamedTuple`.
       loglikelihood(demo([1.0]), (m = 100.0, ))
-4901.418938533205

julia&gt; # Using a `OrderedDict`.
       loglikelihood(demo([1.0]), OrderedDict(@varname(m) =&gt; 100.0))
-4901.418938533205

julia&gt; # Truth.
       logpdf(Normal(100.0, 1.0), 1.0)
-4901.418938533205</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/simple_varinfo.jl#L579-L608">source</a></section><section><div><pre><code class="language-julia hljs">loglikelihood(model::DynamicPPL.Model, chain::MCMCChains.Chains)</code></pre><p>Return an array of log likelihoods evaluated at each sample in an MCMC <code>chain</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MCMCChains, Distributions

julia&gt; @model function demo_model(x)
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, sqrt(s))
           for i in eachindex(x)
               x[i] ~ Normal(m, sqrt(s))
           end
       end;

julia&gt; # Construct a chain of samples using MCMCChains.
       # This sets s = 0.5 and m = 1.0 for all three samples.
       chain = Chains(repeat([0.5 1.0;;;], 3, 1, 1), [:s, :m]);

julia&gt; loglikelihood(demo_model([1., 2.]), chain)
3×1 Matrix{Float64}:
 -2.1447298858494
 -2.1447298858494
 -2.1447298858494</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMCMCChainsExt.jl#L530-L557">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.logjoint"><a class="docstring-binding" href="#DynamicPPL.logjoint"><code>DynamicPPL.logjoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logjoint(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log joint probability of variables <code>varinfo</code> for the probabilistic <code>model</code>.</p><p>Note that this probability always refers to the parameters in unlinked space, i.e., the return value of <code>logjoint</code> does not depend on whether <code>VarInfo</code> has been linked or not.</p><p>See <a href="#DynamicPPL.logprior"><code>logprior</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L1046-L1056">source</a></section><section><div><pre><code class="language-julia hljs">logjoint(model::Model, θ::Union{NamedTuple,AbstractDict})</code></pre><p>Return the log joint probability of variables <code>θ</code> for the probabilistic <code>model</code>.</p><p>See <a href="#DynamicPPL.logprior"><code>logprior</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1.0)
           end
       end
demo (generic function with 2 methods)

julia&gt; # Using a `NamedTuple`.
       logjoint(demo([1.0]), (m = 100.0, ))
-9902.33787706641

julia&gt; # Using a `OrderedDict`.
       logjoint(demo([1.0]), OrderedDict(@varname(m) =&gt; 100.0))
-9902.33787706641

julia&gt; # Truth.
       logpdf(Normal(100.0, 1.0), 1.0) + logpdf(Normal(), 100.0)
-9902.33787706641</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/simple_varinfo.jl#L513-L542">source</a></section><section><div><pre><code class="language-julia hljs">logjoint(model::Model, chain::MCMCChains.Chains)</code></pre><p>Return an array of log joint probabilities evaluated at each sample in an MCMC <code>chain</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MCMCChains, Distributions

julia&gt; @model function demo_model(x)
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, sqrt(s))
           for i in eachindex(x)
               x[i] ~ Normal(m, sqrt(s))
           end
       end;

julia&gt; # Construct a chain of samples using MCMCChains.
       # This sets s = 0.5 and m = 1.0 for all three samples.
       chain = Chains(repeat([0.5 1.0;;;], 3, 1, 1), [:s, :m]);

julia&gt; logjoint(demo_model([1., 2.]), chain)
3×1 Matrix{Float64}:
 -5.440428709758045
 -5.440428709758045
 -5.440428709758045</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMCMCChainsExt.jl#L489-L517">source</a></section></details></article><h3 id="LogDensityProblems.jl-interface"><a class="docs-heading-anchor" href="#LogDensityProblems.jl-interface">LogDensityProblems.jl interface</a><a id="LogDensityProblems.jl-interface-1"></a><a class="docs-heading-anchor-permalink" href="#LogDensityProblems.jl-interface" title="Permalink"></a></h3><p>The <a href="https://github.com/tpapp/LogDensityProblems.jl">LogDensityProblems.jl</a> interface is also supported by wrapping a <a href="#Model"><code>Model</code></a> in a <code>DynamicPPL.LogDensityFunction</code>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.LogDensityFunction"><a class="docstring-binding" href="#DynamicPPL.LogDensityFunction"><code>DynamicPPL.LogDensityFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LogDensityFunction(
    model::Model,
    getlogdensity::Function=getlogjoint_internal,
    varinfo::AbstractVarInfo=ldf_default_varinfo(model, getlogdensity);
    adtype::Union{ADTypes.AbstractADType,Nothing}=nothing
)</code></pre><p>A struct which contains a model, along with all the information necessary to:</p><ul><li>calculate its log density at a given point;</li><li>and if <code>adtype</code> is provided, calculate the gradient of the log density at</li></ul><p>that point.</p><p>This information can be extracted using the LogDensityProblems.jl interface, specifically, using <code>LogDensityProblems.logdensity</code> and <code>LogDensityProblems.logdensity_and_gradient</code>. If <code>adtype</code> is nothing, then only <code>logdensity</code> is implemented. If <code>adtype</code> is a concrete AD backend type, then <code>logdensity_and_gradient</code> is also implemented.</p><p>There are several options for <code>getlogdensity</code> that are &#39;supported&#39; out of the box:</p><ul><li><a href="#DynamicPPL.getlogjoint_internal"><code>getlogjoint_internal</code></a>: calculate the log joint, including the log-Jacobian term for any variables that have been linked in the provided VarInfo.</li><li><a href="#DynamicPPL.getlogprior_internal"><code>getlogprior_internal</code></a>: calculate the log prior, including the log-Jacobian term for any variables that have been linked in the provided VarInfo.</li><li><a href="#DynamicPPL.getlogjoint"><code>getlogjoint</code></a>: calculate the log joint in the model space, ignoring any effects of linking</li><li><a href="#DynamicPPL.getlogprior"><code>getlogprior</code></a>: calculate the log prior in the model space, ignoring any effects of linking</li><li><a href="#DynamicPPL.getloglikelihood"><code>getloglikelihood</code></a>: calculate the log likelihood (this is unaffected by linking, since transforms are only applied to random variables)</li></ul><div class="admonition is-info" id="Note-d2bc8ab177671010"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d2bc8ab177671010" title="Permalink"></a></header><div class="admonition-body"><p>By default, <code>LogDensityFunction</code> uses <code>getlogjoint_internal</code>, i.e., the result of <code>LogDensityProblems.logdensity(f, x)</code> will depend on whether the <code>LogDensityFunction</code> was created with a linked or unlinked VarInfo. This is done primarily to ease interoperability with MCMC samplers.</p></div></div><p>If you provide one of these functions, a <code>VarInfo</code> will be automatically created for you. If you provide a different function, you have to manually create a VarInfo and pass it as the third argument.</p><p>If the <code>adtype</code> keyword argument is provided, then this struct will also store the adtype along with other information for efficient calculation of the gradient of the log density. Note that preparing a <code>LogDensityFunction</code> with an AD type <code>AutoBackend()</code> requires the AD backend itself to have been loaded (e.g. with <code>import Backend</code>).</p><p><strong>Fields</strong></p><ul><li><p><code>model</code>: model used for evaluation</p></li><li><p><code>getlogdensity</code>: function to be called on <code>varinfo</code> to extract the log density. By default <code>getlogjoint_internal</code>.</p></li><li><p><code>varinfo</code>: varinfo used for evaluation. If not specified, generated with <code>ldf_default_varinfo</code>.</p></li><li><p><code>adtype</code>: AD type used for evaluation of log density gradient. If <code>nothing</code>, no gradient can be calculated</p></li><li><p><code>prep</code>: (internal use only) gradient preparation object for the model</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; using DynamicPPL: LogDensityFunction, setaccs!!

julia&gt; @model function demo(x)
           m ~ Normal()
           x ~ Normal(m, 1)
       end
demo (generic function with 2 methods)

julia&gt; model = demo(1.0);

julia&gt; f = LogDensityFunction(model);

julia&gt; # It implements the interface of LogDensityProblems.jl.
       using LogDensityProblems

julia&gt; LogDensityProblems.logdensity(f, [0.0])
-2.3378770664093453

julia&gt; LogDensityProblems.dimension(f)
1

julia&gt; # By default it uses `VarInfo` under the hood, but this is not necessary.
       f = LogDensityFunction(model, getlogjoint_internal, SimpleVarInfo(model));

julia&gt; LogDensityProblems.logdensity(f, [0.0])
-2.3378770664093453

julia&gt; # One can also specify evaluating e.g. the log prior only:
       f_prior = LogDensityFunction(model, getlogprior);

julia&gt; LogDensityProblems.logdensity(f_prior, [0.0]) == logpdf(Normal(), 0.0)
true

julia&gt; # If we also need to calculate the gradient, we can specify an AD backend.
       import ForwardDiff, ADTypes

julia&gt; f = LogDensityFunction(model, adtype=ADTypes.AutoForwardDiff());

julia&gt; LogDensityProblems.logdensity_and_gradient(f, [0.0])
(-2.3378770664093453, [1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/logdensityfunction.jl#L19-L120">source</a></section></details></article><h2 id="Condition-and-decondition"><a class="docs-heading-anchor" href="#Condition-and-decondition">Condition and decondition</a><a id="Condition-and-decondition-1"></a><a class="docs-heading-anchor-permalink" href="#Condition-and-decondition" title="Permalink"></a></h2><p>A <a href="#Model"><code>Model</code></a> can be conditioned on a set of observations with <a href="#AbstractPPL.condition"><code>AbstractPPL.condition</code></a> or its alias <a href="#Base.:|-Tuple{Model, Union{Tuple, AbstractDict{&lt;:VarName}, NamedTuple}}"><code>|</code></a>.</p><article><details class="docstring" open="true"><summary id="Base.:|-Tuple{Model, Union{Tuple, AbstractDict{&lt;:VarName}, NamedTuple}}"><a class="docstring-binding" href="#Base.:|-Tuple{Model, Union{Tuple, AbstractDict{&lt;:VarName}, NamedTuple}}"><code>Base.:|</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">model | (x = 1.0, ...)</code></pre><p>Return a <code>Model</code> which now treats variables on the right-hand side as observations.</p><p>See <a href="#AbstractPPL.condition"><code>condition</code></a> for more information and examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L108-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractPPL.condition"><a class="docstring-binding" href="#AbstractPPL.condition"><code>AbstractPPL.condition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">condition(model::Model; values...)
condition(model::Model, values::NamedTuple)</code></pre><p>Return a <code>Model</code> which now treats the variables in <code>values</code> as observations.</p><p>See also: <a href="#AbstractPPL.decondition"><code>decondition</code></a>, <a href="#DynamicPPL.conditioned"><code>conditioned</code></a></p><p><strong>Limitations</strong></p><p>This does currently <em>not</em> work with variables that are provided to the model as arguments, e.g. <code>@model function demo(x) ... end</code> means that <code>condition</code> will not affect the variable <code>x</code>.</p><p>Therefore if one wants to make use of <code>condition</code> and <a href="#AbstractPPL.decondition"><code>decondition</code></a> one should not be specifying any random variables as arguments.</p><p>This is done for the sake of backwards compatibility.</p><p><strong>Examples</strong></p><p><strong>Simple univariate model</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; m, x = model(); (m ≠ 1.0 &amp;&amp; x ≠ 100.0)
true

julia&gt; # Create a new instance which treats `x` as observed
       # with value `100.0`, and similarly for `m=1.0`.
       conditioned_model = condition(model, x=100.0, m=1.0);

julia&gt; m, x = conditioned_model(); (m == 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # Let&#39;s only condition on `x = 100.0`.
       conditioned_model = condition(model, x = 100.0);

julia&gt; m, x =conditioned_model(); (m ≠ 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # We can also use the nicer `|` syntax.
       conditioned_model = model | (x = 100.0, );

julia&gt; m, x = conditioned_model(); (m ≠ 1.0 &amp;&amp; x == 100.0)
true</code></pre><p>The above uses a <code>NamedTuple</code> to hold the conditioning variables, which allows us to perform some additional optimizations; in many cases, the above has zero runtime-overhead.</p><p>But we can also use a <code>Dict</code>, which offers more flexibility in the conditioning (see examples further below) but generally has worse performance than the <code>NamedTuple</code> approach:</p><pre><code class="language-julia-repl hljs">julia&gt; conditioned_model_dict = condition(model, Dict(@varname(x) =&gt; 100.0));

julia&gt; m, x = conditioned_model_dict(); (m ≠ 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # There&#39;s also an option using `|` by letting the right-hand side be a tuple
       # with elements of type `Pair{&lt;:VarName}`, i.e. `vn =&gt; value` with `vn isa VarName`.
       conditioned_model_dict = model | (@varname(x) =&gt; 100.0, );

julia&gt; m, x = conditioned_model_dict(); (m ≠ 1.0 &amp;&amp; x == 100.0)
true</code></pre><p><strong>Condition only a part of a multivariate variable</strong></p><p>Not only can be condition on multivariate random variables, but we can also use the standard mechanism of setting something to <code>missing</code> in the call to <code>condition</code> to only condition on a part of the variable.</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_mv(::Type{TV}=Float64) where {TV}
           m = Vector{TV}(undef, 2)
           m[1] ~ Normal()
           m[2] ~ Normal()
           return m
       end
demo_mv (generic function with 4 methods)

julia&gt; model = demo_mv();

julia&gt; conditioned_model = condition(model, m = [missing, 1.0]);

julia&gt; # (✓) `m[1]` sampled while `m[2]` is fixed
       m = conditioned_model(); (m[1] ≠ 1.0 &amp;&amp; m[2] == 1.0)
true</code></pre><p>Intuitively one might also expect to be able to write <code>model | (m[1] = 1.0, )</code>. Unfortunately this is not supported as it has the potential of increasing compilation times but without offering any benefit with respect to runtime:</p><pre><code class="language-julia-repl hljs">julia&gt; # (×) `m[2]` is not set to 1.0.
       m = condition(model, var&quot;m[2]&quot; = 1.0)(); m[2] == 1.0
false</code></pre><p>But you <em>can</em> do this if you use a <code>Dict</code> as the underlying storage instead:</p><pre><code class="language-julia-repl hljs">julia&gt; # Alternatives:
       # - `model | (@varname(m[2]) =&gt; 1.0,)`
       # - `condition(model, Dict(@varname(m[2] =&gt; 1.0)))`
       # (✓) `m[2]` is set to 1.0.
       m = condition(model, @varname(m[2]) =&gt; 1.0)(); (m[1] ≠ 1.0 &amp;&amp; m[2] == 1.0)
true</code></pre><p><strong>Nested models</strong></p><p><code>condition</code> of course also supports the use of nested models through the use of <a href="#DynamicPPL.to_submodel"><code>to_submodel</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; @model demo_inner() = m ~ Normal()
demo_inner (generic function with 2 methods)

julia&gt; @model function demo_outer()
           # By default, `to_submodel` prefixes the variables using the left-hand side of `~`.
           inner ~ to_submodel(demo_inner())
           return inner
       end
demo_outer (generic function with 2 methods)

julia&gt; model = demo_outer();

julia&gt; model() ≠ 1.0
true

julia&gt; # To condition the variable inside `demo_inner` we need to refer to it as `inner.m`.
       conditioned_model = model | (@varname(inner.m) =&gt; 1.0, );

julia&gt; conditioned_model()
1.0

julia&gt; # However, it&#39;s not possible to condition `inner` directly.
       conditioned_model_fail = model | (inner = 1.0, );

julia&gt; conditioned_model_fail()
ERROR: ArgumentError: `x ~ to_submodel(...)` is not supported when `x` is observed
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L118-L274">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.conditioned"><a class="docstring-binding" href="#DynamicPPL.conditioned"><code>DynamicPPL.conditioned</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">conditioned(context::AbstractContext)</code></pre><p>Return <code>NamedTuple</code> of values that are conditioned on under context`.</p><p>Note that this will recursively traverse the context stack and return a merged version of the condition values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/conditionfix.jl#L155-L162">source</a></section><section><div><pre><code class="language-julia hljs">conditioned(model::Model)</code></pre><p>Return the conditioned values in <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; using DynamicPPL: conditioned, contextualize

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
       end
demo (generic function with 2 methods)

julia&gt; m = demo();

julia&gt; # Returns all the variables we have conditioned on + their values.
       conditioned(condition(m, x=100.0, m=1.0))
(x = 100.0, m = 1.0)

julia&gt; # Nested ones also work.
       # (Note that `PrefixContext` also prefixes the variables of any
       # ConditionContext that is _inside_ it; because of this, the type of the
       # container has to be broadened to a `Dict`.)
       cm = condition(contextualize(m, PrefixContext(@varname(a), ConditionContext((m=1.0,)))), x=100.0);

julia&gt; Set(keys(conditioned(cm))) == Set([@varname(a.m), @varname(x)])
true

julia&gt; # Since we conditioned on `a.m`, it is not treated as a random variable.
       # However, `a.x` will still be a random variable.
       keys(VarInfo(cm))
1-element Vector{VarName{:a, Accessors.PropertyLens{:x}}}:
 a.x

julia&gt; # We can also condition on `a.m` _outside_ of the PrefixContext:
       cm = condition(contextualize(m, PrefixContext(@varname(a))), (@varname(a.m) =&gt; 1.0));

julia&gt; conditioned(cm)
Dict{VarName{:a, Accessors.PropertyLens{:m}}, Float64} with 1 entry:
  a.m =&gt; 1.0

julia&gt; # Now `a.x` will be sampled.
       keys(VarInfo(cm))
1-element Vector{VarName{:a, Accessors.PropertyLens{:x}}}:
 a.x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L421-L471">source</a></section></details></article><p>Similarly, one can specify with <a href="#AbstractPPL.decondition"><code>AbstractPPL.decondition</code></a> that certain, or all, random variables are not observed.</p><article><details class="docstring" open="true"><summary id="AbstractPPL.decondition"><a class="docstring-binding" href="#AbstractPPL.decondition"><code>AbstractPPL.decondition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">decondition(model::Model)
decondition(model::Model, variables...)</code></pre><p>Return a <code>Model</code> for which <code>variables...</code> are <em>not</em> considered observations. If no <code>variables</code> are provided, then all variables currently considered observations will no longer be.</p><p>This is essentially the inverse of <a href="#AbstractPPL.condition"><code>condition</code></a>. This also means that it suffers from the same limitiations.</p><p>Note that currently we only support <code>variables</code> to take on explicit values provided to <code>condition</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; conditioned_model = condition(demo(), m = 1.0, x = 10.0);

julia&gt; conditioned_model()
(m = 1.0, x = 10.0)

julia&gt; # By specifying the `VarName` to `decondition`.
       model = decondition(conditioned_model, @varname(m));

julia&gt; (m, x) = model(); (m ≠ 1.0 &amp;&amp; x == 10.0)
true

julia&gt; # When `NamedTuple` is used as the underlying, you can also provide
       # the symbol directly (though the `@varname` approach is preferable if
       # if the variable is known at compile-time).
       model = decondition(conditioned_model, :m);

julia&gt; (m, x) = model(); (m ≠ 1.0 &amp;&amp; x == 10.0)
true

julia&gt; # `decondition` multiple at once:
       (m, x) = decondition(model, :m, :x)(); (m ≠ 1.0 &amp;&amp; x ≠ 10.0)
true

julia&gt; # `decondition` without any symbols will `decondition` all variables.
       (m, x) = decondition(model)(); (m ≠ 1.0 &amp;&amp; x ≠ 10.0)
true

julia&gt; # Usage of `Val` to perform `decondition` at compile-time if possible
       # is also supported.
       model = decondition(conditioned_model, Val{:m}());

julia&gt; (m, x) = model(); (m ≠ 1.0 &amp;&amp; x == 10.0)
true</code></pre><p>Similarly when using a <code>Dict</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; conditioned_model_dict = condition(demo(), @varname(m) =&gt; 1.0, @varname(x) =&gt; 10.0);

julia&gt; conditioned_model_dict()
(m = 1.0, x = 10.0)

julia&gt; deconditioned_model_dict = decondition(conditioned_model_dict, @varname(m));

julia&gt; (m, x) = deconditioned_model_dict(); m ≠ 1.0 &amp;&amp; x == 10.0
true</code></pre><p>But, as mentioned, <code>decondition</code> is only supported for variables explicitly provided to <code>condition</code> earlier;</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_mv(::Type{TV}=Float64) where {TV}
           m = Vector{TV}(undef, 2)
           m[1] ~ Normal()
           m[2] ~ Normal()
           return m
       end
demo_mv (generic function with 4 methods)

julia&gt; model = demo_mv();

julia&gt; conditioned_model = condition(model, @varname(m) =&gt; [1.0, 2.0]);

julia&gt; conditioned_model()
2-element Vector{Float64}:
 1.0
 2.0

julia&gt; deconditioned_model = decondition(conditioned_model, @varname(m[1]));

julia&gt; deconditioned_model()  # (×) `m[1]` is still conditioned
2-element Vector{Float64}:
 1.0
 2.0

julia&gt; # (✓) this works though
       deconditioned_model_2 = deconditioned_model | (@varname(m[1]) =&gt; missing);

julia&gt; m = deconditioned_model_2(); (m[1] ≠ 1.0 &amp;&amp; m[2] == 2.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L301-L409">source</a></section></details></article><h2 id="Fixing-and-unfixing"><a class="docs-heading-anchor" href="#Fixing-and-unfixing">Fixing and unfixing</a><a id="Fixing-and-unfixing-1"></a><a class="docs-heading-anchor-permalink" href="#Fixing-and-unfixing" title="Permalink"></a></h2><p>We can also <em>fix</em> a collection of variables in a <a href="#Model"><code>Model</code></a> to certain values using <a href="#DynamicPPL.fix"><code>DynamicPPL.fix</code></a>.</p><p>This is quite similar to the aforementioned <a href="#AbstractPPL.condition"><code>condition</code></a> and its siblings, but they are indeed different operations:</p><ul><li><code>condition</code>ed variables are considered to be <em>observations</em>, and are thus included in the computation <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>, but not in <a href="#DynamicPPL.logprior"><code>logprior</code></a>.</li><li><code>fix</code>ed variables are considered to be <em>constant</em>, and are thus not included in any log-probability computations.</li></ul><p>The differences are more clearly spelled out in the docstring of <a href="#DynamicPPL.fix"><code>DynamicPPL.fix</code></a> below.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.fix"><a class="docstring-binding" href="#DynamicPPL.fix"><code>DynamicPPL.fix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fix([context::AbstractContext,] values::NamedTuple)
fix([context::AbstractContext]; values...)</code></pre><p>Return <code>FixedContext</code> with <code>values</code> and <code>context</code> if <code>values</code> is non-empty, otherwise return <code>context</code> which is <a href="#DynamicPPL.DefaultContext"><code>DefaultContext</code></a> by default.</p><p>See also: <a href="#DynamicPPL.unfix"><code>unfix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/conditionfix.jl#L269-L277">source</a></section><section><div><pre><code class="language-julia hljs">fix(model::Model; values...)
fix(model::Model, values::NamedTuple)</code></pre><p>Return a <code>Model</code> which now treats the variables in <code>values</code> as fixed.</p><p>See also: <a href="#DynamicPPL.unfix"><code>unfix</code></a>, <a href="#DynamicPPL.fixed"><code>fixed</code></a></p><p><strong>Examples</strong></p><p><strong>Simple univariate model</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; m, x = model(); (m ≠ 1.0 &amp;&amp; x ≠ 100.0)
true

julia&gt; # Create a new instance which treats `x` as observed
       # with value `100.0`, and similarly for `m=1.0`.
       fixed_model = fix(model, x=100.0, m=1.0);

julia&gt; m, x = fixed_model(); (m == 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # Let&#39;s only fix on `x = 100.0`.
       fixed_model = fix(model, x = 100.0);

julia&gt; m, x = fixed_model(); (m ≠ 1.0 &amp;&amp; x == 100.0)
true</code></pre><p>The above uses a <code>NamedTuple</code> to hold the fixed variables, which allows us to perform some additional optimizations; in many cases, the above has zero runtime-overhead.</p><p>But we can also use a <code>Dict</code>, which offers more flexibility in the fixing (see examples further below) but generally has worse performance than the <code>NamedTuple</code> approach:</p><pre><code class="language-julia-repl hljs">julia&gt; fixed_model_dict = fix(model, Dict(@varname(x) =&gt; 100.0));

julia&gt; m, x = fixed_model_dict(); (m ≠ 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # Alternative: pass `Pair{&lt;:VarName}` as positional argument.
       fixed_model_dict = fix(model, @varname(x) =&gt; 100.0, );

julia&gt; m, x = fixed_model_dict(); (m ≠ 1.0 &amp;&amp; x == 100.0)
true</code></pre><p><strong>Fix only a part of a multivariate variable</strong></p><p>We can not only fix multivariate random variables, but we can also use the standard mechanism of setting something to <code>missing</code> in the call to <code>fix</code> to only fix a part of the variable.</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_mv(::Type{TV}=Float64) where {TV}
           m = Vector{TV}(undef, 2)
           m[1] ~ Normal()
           m[2] ~ Normal()
           return m
       end
demo_mv (generic function with 4 methods)

julia&gt; model = demo_mv();

julia&gt; fixed_model = fix(model, m = [missing, 1.0]);

julia&gt; # (✓) `m[1]` sampled while `m[2]` is fixed
       m = fixed_model(); (m[1] ≠ 1.0 &amp;&amp; m[2] == 1.0)
true</code></pre><p>Intuitively one might also expect to be able to write something like <code>fix(model, var&quot;m[1]&quot; = 1.0, )</code>. Unfortunately this is not supported as it has the potential of increasing compilation times but without offering any benefit with respect to runtime:</p><pre><code class="language-julia-repl hljs">julia&gt; # (×) `m[2]` is not set to 1.0.
       m = fix(model, var&quot;m[2]&quot; = 1.0)(); m[2] == 1.0
false</code></pre><p>But you <em>can</em> do this if you use a <code>Dict</code> as the underlying storage instead:</p><pre><code class="language-julia-repl hljs">julia&gt; # Alternative: `fix(model, Dict(@varname(m[2] =&gt; 1.0)))`
       # (✓) `m[2]` is set to 1.0.
       m = fix(model, @varname(m[2]) =&gt; 1.0)(); (m[1] ≠ 1.0 &amp;&amp; m[2] == 1.0)
true</code></pre><p><strong>Nested models</strong></p><p><code>fix</code> of course also supports the use of nested models through the use of <a href="#DynamicPPL.to_submodel"><code>to_submodel</code></a>, similar to <a href="#AbstractPPL.condition"><code>condition</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; @model demo_inner() = m ~ Normal()
demo_inner (generic function with 2 methods)

julia&gt; @model function demo_outer()
           inner ~ to_submodel(demo_inner())
           return inner
       end
demo_outer (generic function with 2 methods)

julia&gt; model = demo_outer();

julia&gt; model() ≠ 1.0
true

julia&gt; fixed_model = fix(model, (@varname(inner.m) =&gt; 1.0, ));

julia&gt; fixed_model()
1.0</code></pre><p>However, unlike <a href="#AbstractPPL.condition"><code>condition</code></a>, <code>fix</code> can also be used to fix the return-value of the submodel:</p><pre><code class="language-julia hljs">julia&gt; fixed_model = fix(model, inner = 2.0,);

julia&gt; fixed_model()
2.0</code></pre><p><strong>Difference from <code>condition</code></strong></p><p>A very similar functionality is also provided by <a href="#AbstractPPL.condition"><code>condition</code></a>. The only difference between fixing and conditioning is as follows:</p><ul><li><code>condition</code>ed variables are considered to be observations, and are thus included in the computation <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>, but not in <a href="#DynamicPPL.logprior"><code>logprior</code></a>.</li><li><code>fix</code>ed variables are considered to be constant, and are thus not included in any log-probability computations.</li></ul><pre><code class="language-juliadoctest hljs">julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; model_fixed = fix(model, m = 1.0);

julia&gt; model_conditioned = condition(model, m = 1.0);

julia&gt; logjoint(model_fixed, (x=1.0,))
-0.9189385332046728

julia&gt; # Different!
       logjoint(model_conditioned, (x=1.0,))
-2.3378770664093453

julia&gt; # And the difference is the missing log-probability of `m`:
       logjoint(model_fixed, (x=1.0,)) + logpdf(Normal(), 1.0) == logjoint(model_conditioned, (x=1.0,))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L474-L647">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.fixed"><a class="docstring-binding" href="#DynamicPPL.fixed"><code>DynamicPPL.fixed</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fixed(context::AbstractContext)</code></pre><p>Return the values that are fixed under <code>context</code>.</p><p>Note that this will recursively traverse the context stack and return a merged version of the fix values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/conditionfix.jl#L336-L343">source</a></section><section><div><pre><code class="language-julia hljs">fixed(model::Model)</code></pre><p>Return the fixed values in <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; using DynamicPPL: fixed, contextualize

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
       end
demo (generic function with 2 methods)

julia&gt; m = demo();

julia&gt; # Returns all the variables we have fixed on + their values.
       fixed(fix(m, x=100.0, m=1.0))
(x = 100.0, m = 1.0)

julia&gt; # The rest of this is the same as the `condition` example above.
       cm = fix(contextualize(m, PrefixContext(@varname(a), fix(m=1.0))), x=100.0);

julia&gt; Set(keys(fixed(cm))) == Set([@varname(a.m), @varname(x)])
true

julia&gt; keys(VarInfo(cm))
1-element Vector{VarName{:a, Accessors.PropertyLens{:x}}}:
 a.x

julia&gt; # We can also condition on `a.m` _outside_ of the PrefixContext:
       cm = fix(contextualize(m, PrefixContext(@varname(a))), (@varname(a.m) =&gt; 1.0));

julia&gt; fixed(cm)
Dict{VarName{:a, Accessors.PropertyLens{:m}}, Float64} with 1 entry:
  a.m =&gt; 1.0

julia&gt; # Now `a.x` will be sampled.
       keys(VarInfo(cm))
1-element Vector{VarName{:a, Accessors.PropertyLens{:x}}}:
 a.x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L764-L809">source</a></section></details></article><p>The difference between <a href="#DynamicPPL.fix"><code>DynamicPPL.fix</code></a> and <a href="#AbstractPPL.condition"><code>DynamicPPL.condition</code></a> is described in the docstring of <a href="#DynamicPPL.fix"><code>DynamicPPL.fix</code></a> above.</p><p>Similarly, we can revert this with <a href="#DynamicPPL.unfix"><code>DynamicPPL.unfix</code></a>, i.e. return the variables to their original meaning:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.unfix"><a class="docstring-binding" href="#DynamicPPL.unfix"><code>DynamicPPL.unfix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unfix(context::AbstractContext, syms...)</code></pre><p>Return <code>context</code> but with <code>syms</code> no longer fixed.</p><p>Note that this recursively traverses contexts, unfixing all along the way.</p><p>See also: <a href="#DynamicPPL.fix"><code>fix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/conditionfix.jl#L300-L308">source</a></section><section><div><pre><code class="language-julia hljs">unfix(model::Model)
unfix(model::Model, variables...)</code></pre><p>Return a <code>Model</code> for which <code>variables...</code> are <em>not</em> considered fixed. If no <code>variables</code> are provided, then all variables currently considered fixed will no longer be.</p><p>This is essentially the inverse of <a href="#DynamicPPL.fix"><code>fix</code></a>. This also means that it suffers from the same limitiations.</p><p>Note that currently we only support <code>variables</code> to take on explicit values provided to <code>fix</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; fixed_model = fix(demo(), m = 1.0, x = 10.0);

julia&gt; fixed_model()
(m = 1.0, x = 10.0)

julia&gt; # By specifying the `VarName` to `unfix`.
       model = unfix(fixed_model, @varname(m));

julia&gt; (m, x) = model(); (m ≠ 1.0 &amp;&amp; x == 10.0)
true

julia&gt; # When `NamedTuple` is used as the underlying, you can also provide
       # the symbol directly (though the `@varname` approach is preferable if
       # if the variable is known at compile-time).
       model = unfix(fixed_model, :m);

julia&gt; (m, x) = model(); (m ≠ 1.0 &amp;&amp; x == 10.0)
true

julia&gt; # `unfix` multiple at once:
       (m, x) = unfix(model, :m, :x)(); (m ≠ 1.0 &amp;&amp; x ≠ 10.0)
true

julia&gt; # `unfix` without any symbols will `unfix` all variables.
       (m, x) = unfix(model)(); (m ≠ 1.0 &amp;&amp; x ≠ 10.0)
true

julia&gt; # Usage of `Val` to perform `unfix` at compile-time if possible
       # is also supported.
       model = unfix(fixed_model, Val{:m}());

julia&gt; (m, x) = model(); (m ≠ 1.0 &amp;&amp; x == 10.0)
true</code></pre><p>Similarly when using a <code>Dict</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; fixed_model_dict = fix(demo(), @varname(m) =&gt; 1.0, @varname(x) =&gt; 10.0);

julia&gt; fixed_model_dict()
(m = 1.0, x = 10.0)

julia&gt; unfixed_model_dict = unfix(fixed_model_dict, @varname(m));

julia&gt; (m, x) = unfixed_model_dict(); m ≠ 1.0 &amp;&amp; x == 10.0
true</code></pre><p>But, as mentioned, <code>unfix</code> is only supported for variables explicitly provided to <code>fix</code> earlier:</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_mv(::Type{TV}=Float64) where {TV}
           m = Vector{TV}(undef, 2)
           m[1] ~ Normal()
           m[2] ~ Normal()
           return m
       end
demo_mv (generic function with 4 methods)

julia&gt; model = demo_mv();

julia&gt; fixed_model = fix(model, @varname(m) =&gt; [1.0, 2.0]);

julia&gt; fixed_model()
2-element Vector{Float64}:
 1.0
 2.0

julia&gt; unfixed_model = unfix(fixed_model, @varname(m[1]));

julia&gt; unfixed_model()  # (×) `m[1]` is still fixed
2-element Vector{Float64}:
 1.0
 2.0

julia&gt; # (✓) this works though
       unfixed_model_2 = fix(unfixed_model, @varname(m[1]) =&gt; missing);

julia&gt; m = unfixed_model_2(); (m[1] ≠ 1.0 &amp;&amp; m[2] == 2.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L653-L761">source</a></section></details></article><h2 id="Predicting"><a class="docs-heading-anchor" href="#Predicting">Predicting</a><a id="Predicting-1"></a><a class="docs-heading-anchor-permalink" href="#Predicting" title="Permalink"></a></h2><p>DynamicPPL provides functionality for generating samples from the posterior predictive distribution through the <code>predict</code> function. This allows you to use posterior parameter samples to generate predictions for unobserved data points.</p><p>The <code>predict</code> function has two main methods:</p><ol><li>For <code>AbstractVector{&lt;:AbstractVarInfo}</code> - useful when you have a collection of <code>VarInfo</code> objects representing posterior samples.</li><li>For <code>MCMCChains.Chains</code> (only available when <code>MCMCChains.jl</code> is loaded) - useful when you have posterior samples in the form of an <code>MCMCChains.Chains</code> object.</li></ol><article><details class="docstring" open="true"><summary id="StatsAPI.predict"><a class="docstring-binding" href="#StatsAPI.predict"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">predict([rng::AbstractRNG,] model::Model, chain::MCMCChains.Chains; include_all=false)</code></pre><p>Sample from the posterior predictive distribution by executing <code>model</code> with parameters fixed to each sample in <code>chain</code>, and return the resulting <code>Chains</code>.</p><p>The <code>model</code> passed to <code>predict</code> is often different from the one used to generate <code>chain</code>. Typically, the model from which <code>chain</code> originated treats certain variables as observed (i.e., data points), while the model you pass to <code>predict</code> may mark these same variables as missing or unobserved. Calling <code>predict</code> then leverages the previously inferred parameter values to simulate what new, unobserved data might look like, given your posterior beliefs.</p><p>For each parameter configuration in <code>chain</code>:</p><ol><li>All random variables present in <code>chain</code> are fixed to their sampled values.</li><li>Any variables not included in <code>chain</code> are sampled from their prior distributions.</li></ol><p>If <code>include_all</code> is <code>false</code>, the returned <code>Chains</code> will contain only those variables that were not fixed by the samples in <code>chain</code>. This is useful when you want to sample only new variables from the posterior predictive distribution.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using AbstractMCMC, Distributions, DynamicPPL, Random

@model function linear_reg(x, y, σ = 0.1)
    β ~ Normal(0, 1)
    for i in eachindex(y)
        y[i] ~ Normal(β * x[i], σ)
    end
end

# Generate synthetic chain using known ground truth parameter
ground_truth_β = 2.0

# Create chain of samples from a normal distribution centered on ground truth
β_chain = MCMCChains.Chains(
    rand(Normal(ground_truth_β, 0.002), 1000), [:β,]
)

# Generate predictions for two test points
xs_test = [10.1, 10.2]

m_train = linear_reg(xs_test, fill(missing, length(xs_test)))

predictions = DynamicPPL.AbstractPPL.predict(
    Random.default_rng(), m_train, β_chain
)

ys_pred = vec(mean(Array(predictions); dims=1))

# Check if predictions match expected values within tolerance
(
    isapprox(ys_pred[1], ground_truth_β * xs_test[1], atol = 0.01),
    isapprox(ys_pred[2], ground_truth_β * xs_test[2], atol = 0.01)
)

# output

(true, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMCMCChainsExt.jl#L143-L203">source</a></section></details></article><h3 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h3><p>The typical workflow for posterior prediction involves:</p><ol><li>Fitting a model to observed data to obtain posterior samples</li><li>Creating a new model instance with some variables marked as missing (unobserved)</li><li>Using <code>predict</code> to generate samples for these missing variables based on the posterior parameter samples</li></ol><p>When using <code>predict</code> with <code>MCMCChains.Chains</code>, you can control which variables are included in the output with the <code>include_all</code> parameter:</p><ul><li><code>include_all=false</code> (default): Include only newly predicted variables</li><li><code>include_all=true</code>: Include both parameters from the original chain and predicted variables</li></ul><h2 id="Marginalisation"><a class="docs-heading-anchor" href="#Marginalisation">Marginalisation</a><a id="Marginalisation-1"></a><a class="docs-heading-anchor-permalink" href="#Marginalisation" title="Permalink"></a></h2><p>DynamicPPL provides the <code>marginalize</code> function to marginalise out variables from a model. This requires <code>MarginalLogDensities.jl</code> to be loaded in your environment.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.marginalize"><a class="docstring-binding" href="#DynamicPPL.marginalize"><code>DynamicPPL.marginalize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">marginalize(
    model::DynamicPPL.Model,
    marginalized_varnames::AbstractVector{&lt;:VarName};
    varinfo::DynamicPPL.AbstractVarInfo=link(VarInfo(model), model),
    getlogprob=DynamicPPL.getlogjoint,
    method::MarginalLogDensities.AbstractMarginalizer=MarginalLogDensities.LaplaceApprox();
    kwargs...,
)</code></pre><p>Construct a <code>MarginalLogDensities.MarginalLogDensity</code> object that represents the marginal log-density of the given <code>model</code>, after marginalizing out the variables specified in <code>varnames</code>.</p><p>The resulting object can be called with a vector of parameter values to compute the marginal log-density.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>varinfo</code>: The <code>varinfo</code> to use for the model. By default we use a linked <code>VarInfo</code>,  meaning that the resulting log-density function accepts parameters that have been  transformed to unconstrained space.</p></li><li><p><code>getlogprob</code>: A function which specifies which kind of marginal log-density to compute.  Its default value is <code>DynamicPPL.getlogjoint</code> which returns the marginal log-joint  probability.</p></li><li><p><code>method</code>: The marginalization method; defaults to a Laplace approximation. Please see <a href="https://github.com/ElOceanografo/MarginalLogDensities.jl/">the  MarginalLogDensities.jl package</a>  for other options.</p></li><li><p>Other keyword arguments are passed to the <code>MarginalLogDensities.MarginalLogDensity</code> constructor.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions, MarginalLogDensities

julia&gt; @model function demo()
           x ~ Normal(1.0)
           y ~ Normal(2.0)
       end
demo (generic function with 2 methods)

julia&gt; marginalized = marginalize(demo(), [:x]);

julia&gt; # The resulting callable computes the marginal log-density of `y`.
       marginalized([1.0])
-1.4189385332046727

julia&gt; logpdf(Normal(2.0), 1.0)
-1.4189385332046727</code></pre><div class="admonition is-warning" id="Warning-eef18e401c14f89"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-eef18e401c14f89" title="Permalink"></a></header><div class="admonition-body"><p>The default usage of linked VarInfo means that, for example, optimization of the marginal log-density can be performed in unconstrained space. However, care must be taken if the model contains variables where the link transformation depends on a marginalized variable. For example:</p><pre><code class="language-julia hljs">@model function f()
    x ~ Normal()
    y ~ truncated(Normal(); lower=x)
end</code></pre><p>Here, the support of <code>y</code>, and hence the link transformation used, depends on the value of <code>x</code>. If we now marginalize over <code>x</code>, we obtain a function mapping linked values of <code>y</code> to log-probabilities. However, it will not be possible to use DynamicPPL to correctly retrieve <em>unlinked</em> values of <code>y</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMarginalLogDensitiesExt.jl#L16-L90">source</a></section></details></article><p>A <code>MarginalLogDensity</code> object acts as a function which maps non-marginalised parameter values to a marginal log-probability. To retrieve a VarInfo object from it, you can use:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.VarInfo-Tuple{MarginalLogDensities.MarginalLogDensity{&lt;:DynamicPPLMarginalLogDensitiesExt.LogDensityFunctionWrapper}, Union{Nothing, AbstractVector}}"><a class="docstring-binding" href="#DynamicPPL.VarInfo-Tuple{MarginalLogDensities.MarginalLogDensity{&lt;:DynamicPPLMarginalLogDensitiesExt.LogDensityFunctionWrapper}, Union{Nothing, AbstractVector}}"><code>DynamicPPL.VarInfo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VarInfo(
    mld::MarginalLogDensities.MarginalLogDensity{&lt;:LogDensityFunctionWrapper},
    unmarginalized_params::Union{AbstractVector,Nothing}=nothing
)</code></pre><p>Retrieve the <code>VarInfo</code> object used in the marginalisation process.</p><p>If a Laplace approximation was used for the marginalisation, the values of the marginalized parameters are also set to their mode (note that this only happens if the <code>mld</code> object has been used to compute the marginal log-density at least once, so that the mode has been computed).</p><p>If a vector of <code>unmarginalized_params</code> is specified, the values for the corresponding parameters will also be updated in the returned VarInfo. This vector may be obtained e.g. by performing an optimization of the marginal log-density.</p><p>All other aspects of the VarInfo, such as link status, are preserved from the original VarInfo used in the marginalisation.</p><div class="admonition is-info" id="Note-3afbc0041ac1d3d3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3afbc0041ac1d3d3" title="Permalink"></a></header><div class="admonition-body"><p>The other fields of the VarInfo, e.g. accumulated log-probabilities, will not be updated. If you wish to have a fully consistent VarInfo, you should re-evaluate the model with the returned VarInfo (e.g. using <code>vi = last(DynamicPPL.evaluate!!(model, vi))</code>).</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions, MarginalLogDensities

julia&gt; @model function demo()
           x ~ Normal()
           y ~ Beta(2, 2)
       end
demo (generic function with 2 methods)

julia&gt; # Note that by default `marginalize` uses a linked VarInfo.
       mld = marginalize(demo(), [@varname(x)]);

julia&gt; using MarginalLogDensities: Optimization, OptimizationOptimJL

julia&gt; # Find the mode of the marginal log-density of `y`, with an initial point of `y0`.
       y0 = 2.0; opt_problem = Optimization.OptimizationProblem(mld, [y0])
OptimizationProblem. In-place: true
u0: 1-element Vector{Float64}:
 2.0

julia&gt; # This tells us the optimal (linked) value of `y` is around 0.
       opt_solution = Optimization.solve(opt_problem, OptimizationOptimJL.NelderMead())
retcode: Success
u: 1-element Vector{Float64}:
 4.88281250001733e-5

julia&gt; # Get the VarInfo corresponding to the mode of `y`.
       vi = VarInfo(mld, opt_solution.u);

julia&gt; # `x` is set to its mode (which for `Normal()` is zero).
       vi[@varname(x)]
0.0

julia&gt; # `y` is set to the optimal value we found above.
       DynamicPPL.getindex_internal(vi, @varname(y))
1-element Vector{Float64}:
 4.88281250001733e-5

julia&gt; # To obtain values in the original constrained space, we can either
       # use `getindex`:
       vi[@varname(y)]
0.5000122070312476

julia&gt; # Or invlink the entire VarInfo object using the model:
       vi_unlinked = DynamicPPL.invlink(vi, demo()); vi_unlinked[:]
2-element Vector{Float64}:
 0.0
 0.5000122070312476</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMarginalLogDensitiesExt.jl#L109-L187">source</a></section></details></article><h2 id="Models-within-models"><a class="docs-heading-anchor" href="#Models-within-models">Models within models</a><a id="Models-within-models-1"></a><a class="docs-heading-anchor-permalink" href="#Models-within-models" title="Permalink"></a></h2><p>One can include models and call another model inside the model function with <code>left ~ to_submodel(model)</code>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.to_submodel"><a class="docstring-binding" href="#DynamicPPL.to_submodel"><code>DynamicPPL.to_submodel</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_submodel(model::Model[, auto_prefix::Bool])</code></pre><p>Return a model wrapper indicating that it is a sampleable model over the return-values.</p><p>This is mainly meant to be used on the right-hand side of a <code>~</code> operator to indicate that the model can be sampled from but not necessarily evaluated for its log density.</p><div class="admonition is-warning" id="Warning-7e0fea23480ead7d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-7e0fea23480ead7d" title="Permalink"></a></header><div class="admonition-body"><p>Note that some other operations that one typically associate with expressions of the form <code>left ~ right</code> such as <a href="#AbstractPPL.condition"><code>condition</code></a>, will also not work with <code>to_submodel</code>.</p></div></div><div class="admonition is-warning" id="Warning-63d63dd0f95dac06"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-63d63dd0f95dac06" title="Permalink"></a></header><div class="admonition-body"><p>To avoid variable names clashing between models, it is recommended to leave the argument <code>auto_prefix</code> equal to <code>true</code>. If one does not use automatic prefixing, then it&#39;s recommended to use <a href="#DynamicPPL.prefix"><code>prefix(::Model, input)</code></a> explicitly, i.e. <code>to_submodel(prefix(model, @varname(my_prefix)))</code></p></div></div><p><strong>Arguments</strong></p><ul><li><code>model::Model</code>: the model to wrap.</li><li><code>auto_prefix::Bool</code>: whether to automatically prefix the variables in the model using the left-hand   side of the <code>~</code> statement. Default: <code>true</code>.</li></ul><p><strong>Examples</strong></p><p><strong>Simple example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo1(x)
           x ~ Normal()
           return 1 + abs(x)
       end;

julia&gt; @model function demo2(x, y)
            a ~ to_submodel(demo1(x))
            return y ~ Uniform(0, a)
       end;</code></pre><p>When we sample from the model <code>demo2(missing, 0.4)</code> random variable <code>x</code> will be sampled:</p><pre><code class="language-julia-repl hljs">julia&gt; vi = VarInfo(demo2(missing, 0.4));

julia&gt; @varname(a.x) in keys(vi)
true</code></pre><p>The variable <code>a</code> is not tracked. However, it will be assigned the return value of <code>demo1</code>, and can be used in subsequent lines of the model, as shown above.</p><pre><code class="language-julia-repl hljs">julia&gt; @varname(a) in keys(vi)
false</code></pre><p>We can check that the log joint probability of the model accumulated in <code>vi</code> is correct:</p><pre><code class="language-julia-repl hljs">julia&gt; x = vi[@varname(a.x)];

julia&gt; getlogjoint(vi) ≈ logpdf(Normal(), x) + logpdf(Uniform(0, 1 + abs(x)), 0.4)
true</code></pre><p><strong>Without automatic prefixing</strong></p><p>As mentioned earlier, by default, the <code>auto_prefix</code> argument specifies whether to automatically prefix the variables in the submodel. If <code>auto_prefix=false</code>, then the variables in the submodel will not be prefixed.</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo1(x)
           x ~ Normal()
           return 1 + abs(x)
       end;

julia&gt; @model function demo2_no_prefix(x, z)
            a ~ to_submodel(demo1(x), false)
            return z ~ Uniform(-a, 1)
       end;

julia&gt; vi = VarInfo(demo2_no_prefix(missing, 0.4));

julia&gt; @varname(x) in keys(vi)  # here we just use `x` instead of `a.x`
true</code></pre><p>However, not using prefixing is generally not recommended as it can lead to variable name clashes unless one is careful. For example, if we&#39;re re-using the same model twice in a model, not using prefixing will lead to variable name clashes: However, one can manually prefix using the <a href="#DynamicPPL.prefix"><code>prefix(::Model, input)</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo2(x, y, z)
            a ~ to_submodel(prefix(demo1(x), :sub1), false)
            b ~ to_submodel(prefix(demo1(y), :sub2), false)
            return z ~ Uniform(-a, b)
       end;

julia&gt; vi = VarInfo(demo2(missing, missing, 0.4));

julia&gt; @varname(sub1.x) in keys(vi)
true

julia&gt; @varname(sub2.x) in keys(vi)
true</code></pre><p>Variables <code>a</code> and <code>b</code> are not tracked, but are assigned the return values of the respective calls to <code>demo1</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @varname(a) in keys(vi)
false

julia&gt; @varname(b) in keys(vi)
false</code></pre><p>We can check that the log joint probability of the model accumulated in <code>vi</code> is correct:</p><pre><code class="language-julia-repl hljs">julia&gt; sub1_x = vi[@varname(sub1.x)];

julia&gt; sub2_x = vi[@varname(sub2.x)];

julia&gt; logprior = logpdf(Normal(), sub1_x) + logpdf(Normal(), sub2_x);

julia&gt; loglikelihood = logpdf(Uniform(-1 - abs(sub1_x), 1 + abs(sub2_x)), 0.4);

julia&gt; getlogjoint(vi) ≈ logprior + loglikelihood
true</code></pre><p><strong>Usage as likelihood is illegal</strong></p><p>Note that it is illegal to use a <code>to_submodel</code> model as a likelihood in another model:</p><pre><code class="language-julia-repl hljs">julia&gt; @model inner() = x ~ Normal()
inner (generic function with 2 methods)

julia&gt; @model illegal_likelihood() = a ~ to_submodel(inner())
illegal_likelihood (generic function with 2 methods)

julia&gt; model = illegal_likelihood() | (a = 1.0,);

julia&gt; model()
ERROR: ArgumentError: `x ~ to_submodel(...)` is not supported when `x` is observed
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/submodel.jl#L15-L156">source</a></section></details></article><p>Note that a <code>[to_submodel](@ref)</code> is only sampleable; one cannot compute <code>logpdf</code> for its realizations.</p><p>In the context of including models within models, it&#39;s also useful to prefix the variables in sub-models to avoid variable names clashing:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.prefix"><a class="docstring-binding" href="#DynamicPPL.prefix"><code>DynamicPPL.prefix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prefix(ctx::AbstractContext, vn::VarName)</code></pre><p>Apply the prefixes in the context <code>ctx</code> to the variable name <code>vn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/prefix.jl#L32-L36">source</a></section><section><div><pre><code class="language-julia hljs">prefix(model::Model, x::VarName)
prefix(model::Model, x::Val{sym})
prefix(model::Model, x::Any)</code></pre><p>Return <code>model</code> but with all random variables prefixed by <code>x</code>, where <code>x</code> is either:</p><ul><li>a <code>VarName</code> (e.g. <code>@varname(a)</code>),</li><li>a <code>Val{sym}</code> (e.g. <code>Val(:a)</code>), or</li><li>for any other type, <code>x</code> is converted to a Symbol and then to a <code>VarName</code>. Note that this will introduce runtime overheads so is not recommended unless absolutely necessary.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL: prefix

julia&gt; @model demo() = x ~ Dirac(1)
demo (generic function with 2 methods)

julia&gt; rand(prefix(demo(), @varname(my_prefix)))
(var&quot;my_prefix.x&quot; = 1,)

julia&gt; rand(prefix(demo(), Val(:my_prefix)))
(var&quot;my_prefix.x&quot; = 1,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L812-L838">source</a></section></details></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><p>It is possible to manually increase (or decrease) the accumulated log likelihood or prior from within a model function.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.@addlogprob!"><a class="docstring-binding" href="#DynamicPPL.@addlogprob!"><code>DynamicPPL.@addlogprob!</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@addlogprob!(ex)</code></pre><p>Add a term to the log joint.</p><p>If <code>ex</code> evaluates to a <code>NamedTuple</code> with keys <code>:loglikelihood</code> and/or <code>:logprior</code>, the values are added to the log likelihood and log prior respectively.</p><p>If <code>ex</code> evaluates to a number it is added to the log likelihood.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mylogjoint(x, μ) = (; loglikelihood=loglikelihood(Normal(μ, 1), x), logprior=1.0);

julia&gt; @model function demo(x)
           μ ~ Normal()
           @addlogprob! mylogjoint(x, μ)
       end;

julia&gt; x = [1.3, -2.1];

julia&gt; loglikelihood(demo(x), (μ=0.2,)) ≈ mylogjoint(x, 0.2).loglikelihood
true

julia&gt; logprior(demo(x), (μ=0.2,)) ≈ logpdf(Normal(), 0.2) + mylogjoint(x, 0.2).logprior
true</code></pre><p>and to <a href="https://github.com/TuringLang/Turing.jl/issues/1328">reject samples</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ MvNormal(zero(x), I)
           if dot(m, x) &lt; 0
               @addlogprob! (; loglikelihood=-Inf)
               # Exit the model evaluation early
               return
           end
           x ~ MvNormal(m, I)
           return
       end;

julia&gt; logjoint(demo([-2.1]), (m=[0.2],)) == -Inf
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/utils.jl#L18-L64">source</a></section></details></article><p>Return values of the model function can be obtained with <a href="#DynamicPPL.returned-Tuple{Model, Chains}"><code>returned(model, sample)</code></a>, where <code>sample</code> is either a <code>MCMCChains.Chains</code> object (which represents a collection of samples), or a single sample represented as a <code>NamedTuple</code> or a dictionary of VarNames.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.returned-Tuple{Model, Chains}"><a class="docstring-binding" href="#DynamicPPL.returned-Tuple{Model, Chains}"><code>DynamicPPL.returned</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">returned(model::Model, chain::MCMCChains.Chains)</code></pre><p>Execute <code>model</code> for each of the samples in <code>chain</code> and return an array of the values returned by the <code>model</code> for each sample.</p><p><strong>Examples</strong></p><p><strong>General</strong></p><p>Often you might have additional quantities computed inside the model that you want to inspect, e.g.</p><pre><code class="language-julia hljs">@model function demo(x)
    # sample and observe
    θ ~ Prior()
    x ~ Likelihood()
    return interesting_quantity(θ, x)
end
m = demo(data)
chain = sample(m, alg, n)
# To inspect the `interesting_quantity(θ, x)` where `θ` is replaced by samples
# from the posterior/`chain`:
returned(m, chain) # &lt;= results in a `Vector` of returned values
                               #    from `interesting_quantity(θ, x)`</code></pre><p><strong>Concrete (and simple)</strong></p><pre><code class="language-julia hljs">julia&gt; using Turing

julia&gt; @model function demo(xs)
           s ~ InverseGamma(2, 3)
           m_shifted ~ Normal(10, √s)
           m = m_shifted - 10

           for i in eachindex(xs)
               xs[i] ~ Normal(m, √s)
           end

           return (m, )
       end
demo (generic function with 1 method)

julia&gt; model = demo(randn(10));

julia&gt; chain = sample(model, MH(), 10);

julia&gt; returned(model, chain)
10×1 Array{Tuple{Float64},2}:
 (2.1964758025119338,)
 (2.1964758025119338,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.043088571494005024,)
 (-0.16489786710222099,)
 (-0.16489786710222099,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMCMCChainsExt.jl#L256-L314">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.returned-Tuple{Model, Union{AbstractDict{&lt;:VarName}, NamedTuple}}"><a class="docstring-binding" href="#DynamicPPL.returned-Tuple{Model, Union{AbstractDict{&lt;:VarName}, NamedTuple}}"><code>DynamicPPL.returned</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">returned(model::Model, parameters::NamedTuple)
returned(model::Model, parameters::AbstractDict{&lt;:VarName})</code></pre><p>Execute <code>model</code> with variables <code>keys</code> set to <code>values</code> and return the values returned by the <code>model</code>.</p><pre><code class="language-julia hljs">returned(model::Model, values, keys)</code></pre><p>Execute <code>model</code> with variables <code>keys</code> set to <code>values</code> and return the values returned by the <code>model</code>. This method is deprecated; use the NamedTuple or AbstractDict version instead.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions

julia&gt; @model function demo()
           m ~ Normal()
           return (mp1 = m + 1,)
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; returned(model, (; m = 1.0))
(mp1 = 2.0,)

julia&gt; returned(model, Dict{VarName,Float64}(@varname(m) =&gt; 2.0))
(mp1 = 3.0,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L1104-L1133">source</a></section></details></article><p>For a chain of samples, one can compute the pointwise log-likelihoods of each observed random variable with <a href="#DynamicPPL.pointwise_loglikelihoods"><code>pointwise_loglikelihoods</code></a>. Similarly, the log-densities of the priors using <a href="#DynamicPPL.pointwise_prior_logdensities"><code>pointwise_prior_logdensities</code></a> or both, i.e. all variables, using <a href="#DynamicPPL.pointwise_logdensities"><code>pointwise_logdensities</code></a>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.pointwise_logdensities"><a class="docstring-binding" href="#DynamicPPL.pointwise_logdensities"><code>DynamicPPL.pointwise_logdensities</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.pointwise_logdensities(
    model::DynamicPPL.Model,
    chain::MCMCChains.Chains,
    ::Type{Tout}=MCMCChains.Chains
    ::Val{whichlogprob}=Val(:both),
)</code></pre><p>Runs <code>model</code> on each sample in <code>chain</code>, returning a new <code>MCMCChains.Chains</code> object where the log-density of each variable at each sample is stored (rather than its value).</p><p><code>whichlogprob</code> specifies which log-probabilities to compute. It can be <code>:both</code>, <code>:prior</code>, or <code>:likelihood</code>.</p><p>You can pass <code>Tout=OrderedDict</code> to get the result as an <code>OrderedDict{VarName, Matrix{Float64}}</code> instead.</p><p>See also: <a href="#DynamicPPL.pointwise_loglikelihoods"><code>DynamicPPL.pointwise_loglikelihoods</code></a>, <a href="#DynamicPPL.pointwise_prior_logdensities"><code>DynamicPPL.pointwise_prior_logdensities</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using MCMCChains

julia&gt; @model function demo(xs, y)
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, √s)
           for i in eachindex(xs)
               xs[i] ~ Normal(m, √s)
           end
           y ~ Normal(m, √s)
       end
demo (generic function with 2 methods)

julia&gt; # Example observations.
       model = demo([1.0, 2.0, 3.0], [4.0]);

julia&gt; # A chain with 3 iterations.
       chain = Chains(
           reshape(1.:6., 3, 2),
           [:s, :m];
           info=(varname_to_symbol=Dict(
               @varname(s) =&gt; :s,
               @varname(m) =&gt; :m,
           ),),
       );

julia&gt; plds = pointwise_logdensities(model, chain)
Chains MCMC chain (3×6×1 Array{Float64, 3}):

Iterations        = 1:1:3
Number of chains  = 1
Samples per chain = 3
parameters        = s, m, xs[1], xs[2], xs[3], y
[...]

julia&gt; plds[:s]
2-dimensional AxisArray{Float64,2,...} with axes:
    :iter, 1:1:3
    :chain, 1:1
And data, a 3×1 Matrix{Float64}:
 -0.8027754226637804
 -1.3822169643436162
 -2.0986122886681096

julia&gt; # The above is the same as:
       logpdf.(InverseGamma(2, 3), chain[:s])
3×1 Matrix{Float64}:
 -0.8027754226637804
 -1.3822169643436162
 -2.0986122886681096</code></pre><p>julia&gt; # Alternatively:        plds<em>dict = pointwise</em>logdensities(model, chain, OrderedDict) OrderedDict{VarName, Matrix{Float64}} with 6 entries:   s     =&gt; [-0.802775; -1.38222; -2.09861;;]   m     =&gt; [-8.91894; -7.51551; -7.46824;;]   xs[1] =&gt; [-5.41894; -5.26551; -5.63491;;]   xs[2] =&gt; [-2.91894; -3.51551; -4.13491;;]   xs[3] =&gt; [-1.41894; -2.26551; -2.96824;;]   y     =&gt; [-0.918939; -1.51551; -2.13491;;]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMCMCChainsExt.jl#L327-L410">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.pointwise_loglikelihoods"><a class="docstring-binding" href="#DynamicPPL.pointwise_loglikelihoods"><code>DynamicPPL.pointwise_loglikelihoods</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.pointwise_loglikelihoods(
    model::DynamicPPL.Model,
    chain::MCMCChains.Chains,
    ::Type{Tout}=MCMCChains.Chains
)</code></pre><p>Compute the pointwise log-likelihoods of the model given the chain. This is the same as <code>pointwise_logdensities(model, chain)</code>, but only including the likelihood terms.</p><p>See also: <a href="#DynamicPPL.pointwise_logdensities"><code>DynamicPPL.pointwise_logdensities</code></a>, <a href="#DynamicPPL.pointwise_prior_logdensities"><code>DynamicPPL.pointwise_prior_logdensities</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMCMCChainsExt.jl#L454-L465">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.pointwise_prior_logdensities"><a class="docstring-binding" href="#DynamicPPL.pointwise_prior_logdensities"><code>DynamicPPL.pointwise_prior_logdensities</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.pointwise_prior_logdensities(
    model::DynamicPPL.Model,
    chain::MCMCChains.Chains
)</code></pre><p>Compute the pointwise log-prior-densities of the model given the chain. This is the same as <code>pointwise_logdensities(model, chain)</code>, but only including the prior terms.</p><p>See also: <a href="#DynamicPPL.pointwise_logdensities"><code>DynamicPPL.pointwise_logdensities</code></a>, <a href="#DynamicPPL.pointwise_loglikelihoods"><code>DynamicPPL.pointwise_loglikelihoods</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMCMCChainsExt.jl#L472-L482">source</a></section></details></article><p>For converting a chain into a format that can more easily be fed into a <code>Model</code> again, for example using <code>condition</code>, you can use <a href="#DynamicPPL.value_iterator_from_chain"><code>value_iterator_from_chain</code></a>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.value_iterator_from_chain"><a class="docstring-binding" href="#DynamicPPL.value_iterator_from_chain"><code>DynamicPPL.value_iterator_from_chain</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">value_iterator_from_chain(model::Model, chain)
value_iterator_from_chain(varinfo::AbstractVarInfo, chain)</code></pre><p>Return an iterator over the values in <code>chain</code> for each variable in <code>model</code>/<code>varinfo</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using MCMCChains, DynamicPPL, Distributions, StableRNGs

julia&gt; rng = StableRNG(42);

julia&gt; @model function demo_model(x)
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, sqrt(s))
           for i in eachindex(x)
               x[i] ~ Normal(m, sqrt(s))
           end

           return s, m
       end
demo_model (generic function with 2 methods)

julia&gt; model = demo_model([1.0, 2.0]);

julia&gt; chain = Chains(rand(rng, 10, 2, 3), [:s, :m]);

julia&gt; iter = value_iterator_from_chain(model, chain);

julia&gt; first(iter)
OrderedDict{VarName, Any} with 2 entries:
  s =&gt; 0.580515
  m =&gt; 0.739328

julia&gt; collect(iter)
10×3 Matrix{OrderedDict{VarName, Any}}:
 OrderedDict(s=&gt;0.580515, m=&gt;0.739328)  …  OrderedDict(s=&gt;0.186047, m=&gt;0.402423)
 OrderedDict(s=&gt;0.191241, m=&gt;0.627342)     OrderedDict(s=&gt;0.776277, m=&gt;0.166342)
 OrderedDict(s=&gt;0.971133, m=&gt;0.637584)     OrderedDict(s=&gt;0.651655, m=&gt;0.712044)
 OrderedDict(s=&gt;0.74345, m=&gt;0.110359)      OrderedDict(s=&gt;0.469214, m=&gt;0.104502)
 OrderedDict(s=&gt;0.170969, m=&gt;0.598514)     OrderedDict(s=&gt;0.853546, m=&gt;0.185399)
 OrderedDict(s=&gt;0.704776, m=&gt;0.322111)  …  OrderedDict(s=&gt;0.638301, m=&gt;0.853802)
 OrderedDict(s=&gt;0.441044, m=&gt;0.162285)     OrderedDict(s=&gt;0.852959, m=&gt;0.0956922)
 OrderedDict(s=&gt;0.803972, m=&gt;0.643369)     OrderedDict(s=&gt;0.245049, m=&gt;0.871985)
 OrderedDict(s=&gt;0.772384, m=&gt;0.646323)     OrderedDict(s=&gt;0.906603, m=&gt;0.385502)
 OrderedDict(s=&gt;0.70882, m=&gt;0.253105)      OrderedDict(s=&gt;0.413222, m=&gt;0.953288)

julia&gt; # This can be used to `condition` a `Model`.
       conditioned_model = model | first(iter);

julia&gt; conditioned_model()  # &lt;= results in same values as the `first(iter)` above
(0.5805148626851955, 0.7393275279160691)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model_utils.jl#L145-L198">source</a></section></details></article><p>Sometimes it can be useful to extract the priors of a model. This is the possible using <a href="#DynamicPPL.extract_priors"><code>extract_priors</code></a>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.extract_priors"><a class="docstring-binding" href="#DynamicPPL.extract_priors"><code>DynamicPPL.extract_priors</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extract_priors([rng::Random.AbstractRNG, ]model::Model)</code></pre><p>Extract the priors from a model.</p><p>This is done by sampling from the model and recording the distributions that are used to generate the samples.</p><div class="admonition is-warning" id="Warning-8c4e54d04961b4e"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-8c4e54d04961b4e" title="Permalink"></a></header><div class="admonition-body"><p>Because the extraction is done by execution of the model, there are several caveats:</p><ol><li>If one variable, say, <code>y ~ Normal(0, x)</code>, where <code>x ~ Normal()</code> is also a random variable, then the extracted prior will have different parameters in every extraction!</li><li>If the model does <em>not</em> have static support, say, <code>n ~ Categorical(1:10); x ~ MvNormmal(zeros(n), I)</code>, then the extracted priors themselves will be different between extractions, not just their parameters.</li></ol><p>Both of these caveats are demonstrated below.</p></div></div><p><strong>Examples</strong></p><p><strong>Changing parameters</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions, StableRNGs

julia&gt; rng = StableRNG(42);

julia&gt; @model function model_dynamic_parameters()
           x ~ Normal(0, 1)
           y ~ Normal(x, 1)
       end;

julia&gt; model = model_dynamic_parameters();

julia&gt; extract_priors(rng, model)[@varname(y)]
Normal{Float64}(μ=-0.6702516921145671, σ=1.0)

julia&gt; extract_priors(rng, model)[@varname(y)]
Normal{Float64}(μ=1.3736306979834252, σ=1.0)</code></pre><p><strong>Changing support</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra, Distributions, StableRNGs

julia&gt; rng = StableRNG(42);

julia&gt; @model function model_dynamic_support()
           n ~ Categorical(ones(10) ./ 10)
           x ~ MvNormal(zeros(n), I)
       end;

julia&gt; model = model_dynamic_support();

julia&gt; length(extract_priors(rng, model)[@varname(x)])
6

julia&gt; length(extract_priors(rng, model)[@varname(x)])
9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/extract_priors.jl#L55-L120">source</a></section><section><div><pre><code class="language-julia hljs">extract_priors(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Extract the priors from a model.</p><p>This is done by evaluating the model at the values present in <code>varinfo</code> and recording the distributions that are present at each tilde statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/extract_priors.jl#L130-L137">source</a></section></details></article><p>Safe extraction of values from a given <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a> as they are seen in the model can be done using <a href="#DynamicPPL.values_as_in_model"><code>values_as_in_model</code></a>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.values_as_in_model"><a class="docstring-binding" href="#DynamicPPL.values_as_in_model"><code>DynamicPPL.values_as_in_model</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">values_as_in_model(model::Model, include_colon_eq::Bool, varinfo::AbstractVarInfo)</code></pre><p>Get the values of <code>varinfo</code> as they would be seen in the model.</p><p>More specifically, this method attempts to extract the realization <em>as seen in the model</em>. For example, <code>x[1] ~ truncated(Normal(); lower=0)</code> will result in a realization that is compatible with <code>truncated(Normal(); lower=0)</code> – i.e. one where the value of <code>x[1]</code> is positive – regardless of whether <code>varinfo</code> is working in unconstrained space.</p><p>Hence this method is a &quot;safe&quot; way of obtaining realizations in constrained space at the cost of additional model evaluations.</p><p><strong>Arguments</strong></p><ul><li><code>model::Model</code>: model to extract realizations from.</li><li><code>include_colon_eq::Bool</code>: whether to also include variables on the LHS of <code>:=</code>.</li><li><code>varinfo::AbstractVarInfo</code>: variable information to use for the extraction.</li></ul><p><strong>Examples</strong></p><p><strong>When <code>VarInfo</code> fails</strong></p><p>The following demonstrates a common pitfall when working with <a href="#VarInfo"><code>VarInfo</code></a> and constrained variables.</p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions, StableRNGs

julia&gt; rng = StableRNG(42);

julia&gt; @model function model_changing_support()
           x ~ Bernoulli(0.5)
           y ~ x == 1 ? Uniform(0, 1) : Uniform(11, 12)
       end;

julia&gt; model = model_changing_support();

julia&gt; # Construct initial type-stable `VarInfo`.
       varinfo = VarInfo(rng, model);

julia&gt; # Link it so it works in unconstrained space.
       varinfo_linked = DynamicPPL.link(varinfo, model);

julia&gt; # Perform computations in unconstrained space, e.g. changing the values of `θ`.
       # Flip `x` so we hit the other support of `y`.
       θ = [!varinfo[@varname(x)], rand(rng)];

julia&gt; # Update the `VarInfo` with the new values.
       varinfo_linked = DynamicPPL.unflatten(varinfo_linked, θ);

julia&gt; # Determine the expected support of `y`.
       lb, ub = θ[1] == 1 ? (0, 1) : (11, 12)
(0, 1)

julia&gt; # Approach 1: Convert back to constrained space using `invlink` and extract.
       varinfo_invlinked = DynamicPPL.invlink(varinfo_linked, model);

julia&gt; # (×) Fails! Because `VarInfo` _saves_ the original distributions
       # used in the very first model evaluation, hence the support of `y`
       # is not updated even though `x` has changed.
       lb ≤ first(varinfo_invlinked[@varname(y)]) ≤ ub
false

julia&gt; # Approach 2: Extract realizations using `values_as_in_model`.
       # (✓) `values_as_in_model` will re-run the model and extract
       # the correct realization of `y` given the new values of `x`.
       lb ≤ values_as_in_model(model, true, varinfo_linked)[@varname(y)] ≤ ub
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/values_as_in_model.jl#L64-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.NamedDist"><a class="docstring-binding" href="#DynamicPPL.NamedDist"><code>DynamicPPL.NamedDist</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A named distribution that carries the name of the random variable with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/distribution_wrappers.jl#L5-L7">source</a></section></details></article><h2 id="AD-testing-and-benchmarking-utilities"><a class="docs-heading-anchor" href="#AD-testing-and-benchmarking-utilities">AD testing and benchmarking utilities</a><a id="AD-testing-and-benchmarking-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#AD-testing-and-benchmarking-utilities" title="Permalink"></a></h2><p>To test and/or benchmark the performance of an AD backend on a model, DynamicPPL provides the following utilities:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.run_ad"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.run_ad"><code>DynamicPPL.TestUtils.AD.run_ad</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">run_ad(
    model::Model,
    adtype::ADTypes.AbstractADType;
    test::Union{AbstractADCorrectnessTestSetting,Bool}=WithBackend(),
    benchmark=false,
    atol::AbstractFloat=1e-8,
    rtol::AbstractFloat=sqrt(eps()),
    getlogdensity::Function=getlogjoint_internal,
    rng::Random.AbstractRNG=Random.default_rng(),
    varinfo::AbstractVarInfo=link(VarInfo(model), model),
    params::Union{Nothing,Vector{&lt;:AbstractFloat}}=nothing,
    verbose=true,
)::ADResult</code></pre><p><strong>Description</strong></p><p>Test the correctness and/or benchmark the AD backend <code>adtype</code> for the model <code>model</code>.</p><p>Whether to test and benchmark is controlled by the <code>test</code> and <code>benchmark</code> keyword arguments. By default, <code>test</code> is <code>true</code> and <code>benchmark</code> is <code>false</code>.</p><p>Note that to run AD successfully you will need to import the AD backend itself. For example, to test with <code>AutoReverseDiff()</code> you will need to run <code>import ReverseDiff</code>.</p><p><strong>Arguments</strong></p><p>There are two positional arguments, which absolutely must be provided:</p><ol><li><code>model</code> - The model being tested.</li><li><code>adtype</code> - The AD backend being tested.</li></ol><p>Everything else is optional, and can be categorised into several groups:</p><ol><li><p><em>How to specify the VarInfo.</em></p><p>DynamicPPL contains several different types of VarInfo objects which change the way model evaluation occurs. If you want to use a specific type of VarInfo, pass it as the <code>varinfo</code> argument. Otherwise, it will default to using a linked <code>TypedVarInfo</code> generated from the model. Here, <em>linked</em> means that the parameters in the VarInfo have been transformed to unconstrained Euclidean space if they aren&#39;t already in that space.</p></li><li><p><em>How to specify the parameters.</em></p><p>For maximum control over this, generate a vector of parameters yourself and pass this as the <code>params</code> argument. If you don&#39;t specify this, it will be taken from the contents of the VarInfo.</p><p>Note that if the VarInfo is not specified (and thus automatically generated) the parameters in it will have been sampled from the prior of the model. If you want to seed the parameter generation for the VarInfo, you can pass the <code>rng</code> keyword argument, which will then be used to create the VarInfo.</p><p>Finally, note that these only reflect the parameters used for <em>evaluating</em> the gradient. If you also want to control the parameters used for <em>preparing</em> the gradient, then you need to manually set these parameters in the VarInfo object, for example using <code>vi = DynamicPPL.unflatten(vi, prep_params)</code>. You could then evaluate the gradient at a different set of parameters using the <code>params</code> keyword argument.</p></li><li><p><em>Which type of logp is being calculated.</em></p><p>By default, <code>run_ad</code> evaluates the &#39;internal log joint density&#39; of the model, i.e., the log joint density in the unconstrained space. Thus, for example, in</p><pre><code class="nohighlight hljs">@model f() = x ~ LogNormal()</code></pre><p>the internal log joint density is <code>logpdf(Normal(), log(x))</code>. This is the relevant log density for e.g. Hamiltonian Monte Carlo samplers and is therefore the most useful to test.</p><p>If you want the log joint density in the original model parameterisation, you can use <code>getlogjoint</code>. Likewise, if you want only the prior or likelihood, you can use <code>getlogprior</code> or <code>getloglikelihood</code>, respectively.</p></li><li><p><em>How to specify the results to compare against.</em></p><p>Once logp and its gradient has been calculated with the specified <code>adtype</code>, it can optionally be tested for correctness. The exact way this is tested is specified in the <code>test</code> parameter.</p><p>There are several options for this:</p><ul><li>You can explicitly specify the correct value using <a href="#DynamicPPL.TestUtils.AD.WithExpectedResult"><code>WithExpectedResult()</code></a>.</li><li>You can compare against the result obtained with a different AD backend using <a href="#DynamicPPL.TestUtils.AD.WithBackend"><code>WithBackend(adtype)</code></a>.</li><li>You can disable testing by passing <a href="#DynamicPPL.TestUtils.AD.NoTest"><code>NoTest()</code></a>.</li><li>The default is to compare against the result obtained with ForwardDiff, i.e. <code>WithBackend(AutoForwardDiff())</code>.</li><li><code>test=false</code> and <code>test=true</code> are synonyms for <code>NoTest()</code> and <code>WithBackend(AutoForwardDiff())</code>, respectively.</li></ul></li><li><p><em>How to specify the tolerances.</em> (Only if testing is enabled.)</p><p>Both absolute and relative tolerances can be specified using the <code>atol</code> and <code>rtol</code> keyword arguments respectively. The behaviour of these is similar to <code>isapprox()</code>, i.e. the value and gradient are considered correct if either atol or rtol is satisfied. The default values are <code>100*eps()</code> for <code>atol</code> and <code>sqrt(eps())</code> for <code>rtol</code>.</p><p>For the most part, it is the <code>rtol</code> check that is more meaningful, because we cannot know the magnitude of logp and its gradient a priori. The <code>atol</code> value is supplied to handle the case where gradients are equal to zero.</p></li><li><p><em>Whether to output extra logging information.</em></p><p>By default, this function prints messages when it runs. To silence it, set <code>verbose=false</code>.</p></li></ol><p><strong>Returns / Throws</strong></p><p>Returns an <a href="#DynamicPPL.TestUtils.AD.ADResult"><code>ADResult</code></a> object, which contains the results of the test and/or benchmark.</p><p>If <code>test</code> is <code>true</code> and the AD backend returns an incorrect value or gradient, an <code>ADIncorrectException</code> is thrown. If a different error occurs, it will be thrown as-is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/ad.jl#L119-L240">source</a></section></details></article><p>The default test setting is to compare against ForwardDiff. You can have more fine-grained control over how to test the AD backend using the following types:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.AbstractADCorrectnessTestSetting"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.AbstractADCorrectnessTestSetting"><code>DynamicPPL.TestUtils.AD.AbstractADCorrectnessTestSetting</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractADCorrectnessTestSetting</code></pre><p>Different ways of testing the correctness of an AD backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/ad.jl#L16-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.WithBackend"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.WithBackend"><code>DynamicPPL.TestUtils.AD.WithBackend</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WithBackend(adtype::AbstractADType=AutoForwardDiff()) &lt;: AbstractADCorrectnessTestSetting</code></pre><p>Test correctness by comparing it against the result obtained with <code>adtype</code>.</p><p><code>adtype</code> defaults to ForwardDiff.jl, since it&#39;s the default AD backend used in Turing.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/ad.jl#L23-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.WithExpectedResult"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.WithExpectedResult"><code>DynamicPPL.TestUtils.AD.WithExpectedResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WithExpectedResult(
    value::T,
    grad::AbstractVector{T}
) where {T &lt;: AbstractFloat}
&lt;: AbstractADCorrectnessTestSetting</code></pre><p>Test correctness by comparing it against a known result (e.g. one obtained analytically, or one obtained with a different backend previously). Both the value of the primal (i.e. the log-density) as well as its gradient must be supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/ad.jl#L36-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.NoTest"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.NoTest"><code>DynamicPPL.TestUtils.AD.NoTest</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoTest() &lt;: AbstractADCorrectnessTestSetting</code></pre><p>Disable correctness testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/ad.jl#L53-L57">source</a></section></details></article><p>These are returned / thrown by the <code>run_ad</code> function:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.ADResult"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.ADResult"><code>DynamicPPL.TestUtils.AD.ADResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ADResult{Tparams&lt;:AbstractFloat,Tresult&lt;:AbstractFloat,Ttol&lt;:AbstractFloat}</code></pre><p>Data structure to store the results of the AD correctness test.</p><p>The type parameter <code>Tparams</code> is the numeric type of the parameters passed in; <code>Tresult</code> is the type of the value and the gradient; and <code>Ttol</code> is the type of the absolute and relative tolerances used for correctness testing.</p><p><strong>Fields</strong></p><ul><li><p><code>model::Model</code>: The DynamicPPL model that was tested</p></li><li><p><code>getlogdensity::Function</code>: The function used to extract the log density from the model</p></li><li><p><code>varinfo::AbstractVarInfo</code>: The VarInfo that was used</p></li><li><p><code>params::Vector{Tparams} where Tparams&lt;:AbstractFloat</code>: The values at which the model was evaluated</p></li><li><p><code>adtype::ADTypes.AbstractADType</code>: The AD backend that was tested</p></li><li><p><code>atol::AbstractFloat</code>: Absolute tolerance used for correctness test</p></li><li><p><code>rtol::AbstractFloat</code>: Relative tolerance used for correctness test</p></li><li><p><code>value_expected::Union{Nothing, Tresult} where Tresult&lt;:AbstractFloat</code>: The expected value of logp</p></li><li><p><code>grad_expected::Union{Nothing, Vector{Tresult}} where Tresult&lt;:AbstractFloat</code>: The expected gradient of logp</p></li><li><p><code>value_actual::AbstractFloat</code>: The value of logp (calculated using <code>adtype</code>)</p></li><li><p><code>grad_actual::Vector{Tresult} where Tresult&lt;:AbstractFloat</code>: The gradient of logp (calculated using <code>adtype</code>)</p></li><li><p><code>grad_time::Union{Nothing, Tresult} where Tresult&lt;:AbstractFloat</code>: If benchmarking was requested, the time taken by the AD backend to evaluate the gradient      of logp</p></li><li><p><code>primal_time::Union{Nothing, Tresult} where Tresult&lt;:AbstractFloat</code>: If benchmarking was requested, the time taken by the AD backend to evaluate logp</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/ad.jl#L77-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.AD.ADIncorrectException"><a class="docstring-binding" href="#DynamicPPL.TestUtils.AD.ADIncorrectException"><code>DynamicPPL.TestUtils.AD.ADIncorrectException</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ADIncorrectException{T&lt;:AbstractFloat}</code></pre><p>Exception thrown when an AD backend returns an incorrect value or gradient.</p><p>The type parameter <code>T</code> is the numeric type of the value and gradient.</p><p><strong>Fields</strong></p><ul><li><p><code>value_expected::AbstractFloat</code></p></li><li><p><code>value_actual::AbstractFloat</code></p></li><li><p><code>grad_expected::Vector{T} where T&lt;:AbstractFloat</code></p></li><li><p><code>grad_actual::Vector{T} where T&lt;:AbstractFloat</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/ad.jl#L60-L69">source</a></section></details></article><h2 id="Demo-models"><a class="docs-heading-anchor" href="#Demo-models">Demo models</a><a id="Demo-models-1"></a><a class="docs-heading-anchor-permalink" href="#Demo-models" title="Permalink"></a></h2><p>DynamicPPL provides several demo models in the <code>DynamicPPL.TestUtils</code> submodule.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.DEMO_MODELS"><a class="docstring-binding" href="#DynamicPPL.TestUtils.DEMO_MODELS"><code>DynamicPPL.TestUtils.DEMO_MODELS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>A collection of models corresponding to the posterior distribution defined by the generative process</p><pre><code class="language-julia hljs">s ~ InverseGamma(2, 3)
m ~ Normal(0, √s)
1.5 ~ Normal(m, √s)
2.0 ~ Normal(m, √s)</code></pre><p>or by</p><pre><code class="language-julia hljs">s[1] ~ InverseGamma(2, 3)
s[2] ~ InverseGamma(2, 3)
m[1] ~ Normal(0, √s)
m[2] ~ Normal(0, √s)
1.5 ~ Normal(m[1], √s[1])
2.0 ~ Normal(m[2], √s[2])</code></pre><p>These are examples of a Normal-InverseGamma conjugate prior with Normal likelihood, for which the posterior is known in closed form.</p><p>In particular, for the univariate model (the former one):</p><pre><code class="language-julia hljs">mean(s) == 49 / 24
mean(m) == 7 / 6</code></pre><p>And for the multivariate one (the latter one):</p><pre><code class="language-julia hljs">mean(s[1]) == 19 / 8
mean(m[1]) == 3 / 4
mean(s[2]) == 8 / 3
mean(m[2]) == 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/models.jl#L712-L745">source</a></section></details></article><p>For every demo model, one can define the true log prior, log likelihood, and log joint probabilities.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.logprior_true"><a class="docstring-binding" href="#DynamicPPL.TestUtils.logprior_true"><code>DynamicPPL.TestUtils.logprior_true</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logprior_true(model, args...)</code></pre><p>Return the <code>logprior</code> of <code>model</code> for <code>args</code>.</p><p>This should generally be implemented by hand for every specific <code>model</code>.</p><p>See also: <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, <a href="#DynamicPPL.TestUtils.loglikelihood_true"><code>loglikelihood_true</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/model_interface.jl#L7-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.loglikelihood_true"><a class="docstring-binding" href="#DynamicPPL.TestUtils.loglikelihood_true"><code>DynamicPPL.TestUtils.loglikelihood_true</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">loglikelihood_true(model, args...)</code></pre><p>Return the <code>loglikelihood</code> of <code>model</code> for <code>args</code>.</p><p>This should generally be implemented by hand for every specific <code>model</code>.</p><p>See also: <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/model_interface.jl#L18-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.logjoint_true"><a class="docstring-binding" href="#DynamicPPL.TestUtils.logjoint_true"><code>DynamicPPL.TestUtils.logjoint_true</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logjoint_true(model, args...)</code></pre><p>Return the <code>logjoint</code> of <code>model</code> for <code>args</code>.</p><p>Defaults to <code>logprior_true(model, args...) + loglikelihood_true(model, args..)</code>.</p><p>This should generally be implemented by hand for every specific <code>model</code> so that the returned value can be used as a ground-truth for testing things like:</p><ol><li>Validity of evaluation of <code>model</code> using a particular implementation of <code>AbstractVarInfo</code>.</li><li>Validity of a sampler when combined with DynamicPPL by running the sampler twice: once targeting ground-truth functions, e.g. <code>logjoint_true</code>, and once targeting <code>model</code>.</li></ol><p>And more.</p><p>See also: <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>, <a href="#DynamicPPL.TestUtils.loglikelihood_true"><code>loglikelihood_true</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/model_interface.jl#L29-L45">source</a></section></details></article><p>And in the case where the model includes constrained variables, it can also be useful to define</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian"><a class="docstring-binding" href="#DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian"><code>DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logprior_true_with_logabsdet_jacobian(model::Model, args...)</code></pre><p>Return a tuple <code>(args_unconstrained, logprior_unconstrained)</code> of <code>model</code> for <code>args...</code>.</p><p>Unlike <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>, the returned logprior computation includes the log-absdet-jacobian adjustment, thus computing logprior for the unconstrained variables.</p><p>Note that <code>args</code> are assumed be in the support of <code>model</code>, while <code>args_unconstrained</code> will be unconstrained.</p><p>See also: <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/model_interface.jl#L71-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian"><a class="docstring-binding" href="#DynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian"><code>DynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">logjoint_true_with_logabsdet_jacobian(model::Model, args...)</code></pre><p>Return a tuple <code>(args_unconstrained, logjoint)</code> of <code>model</code> for <code>args</code>.</p><p>Unlike <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, the returned logjoint computation includes the log-absdet-jacobian adjustment, thus computing logjoint for the unconstrained variables.</p><p>Note that <code>args</code> are assumed be in the support of <code>model</code>, while <code>args_unconstrained</code> will be unconstrained.</p><p>This should generally not be implemented directly, instead one should implement <a href="#DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian"><code>logprior_true_with_logabsdet_jacobian</code></a> for a given <code>model</code>.</p><p>See also: <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, <a href="#DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian"><code>logprior_true_with_logabsdet_jacobian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/model_interface.jl#L50-L65">source</a></section></details></article><p>Finally, the following methods can also be of use:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.varnames"><a class="docstring-binding" href="#DynamicPPL.TestUtils.varnames"><code>DynamicPPL.TestUtils.varnames</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">varnames(model::Model)</code></pre><p>Return a collection of <code>VarName</code> as they are expected to appear in the model.</p><p>Even though it is recommended to implement this by hand for a particular <code>Model</code>, a default implementation using <a href="#DynamicPPL.SimpleVarInfo"><code>SimpleVarInfo{&lt;:Dict}</code></a> is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/model_interface.jl#L86-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.posterior_mean"><a class="docstring-binding" href="#DynamicPPL.TestUtils.posterior_mean"><code>DynamicPPL.TestUtils.posterior_mean</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">posterior_mean(model::Model)</code></pre><p>Return a <code>NamedTuple</code> compatible with <code>varnames(model)</code> where the values represent the posterior mean under <code>model</code>.</p><p>&quot;Compatible&quot; means that a <code>varname</code> from <code>varnames(model)</code> can be used to extract the corresponding value using <code>get</code>, e.g. <code>get(posterior_mean(model), varname)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/model_interface.jl#L98-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.setup_varinfos"><a class="docstring-binding" href="#DynamicPPL.TestUtils.setup_varinfos"><code>DynamicPPL.TestUtils.setup_varinfos</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setup_varinfos(model::Model, example_values::NamedTuple, varnames; include_threadsafe::Bool=false)</code></pre><p>Return a tuple of instances for different implementations of <code>AbstractVarInfo</code> with each <code>vi</code>, supposedly, satisfying <code>vi[vn] == get(example_values, vn)</code> for <code>vn</code> in <code>varnames</code>.</p><p>If <code>include_threadsafe</code> is <code>true</code>, then the returned tuple will also include thread-safe versions of the varinfo instances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/varinfo.jl#L17-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.update_values!!"><a class="docstring-binding" href="#DynamicPPL.update_values!!"><code>DynamicPPL.update_values!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update_values!!(vi::AbstractVarInfo, vals::NamedTuple, vns)</code></pre><p>Return instance similar to <code>vi</code> but with <code>vns</code> set to values from <code>vals</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/utils.jl#L765-L769">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.TestUtils.test_values"><a class="docstring-binding" href="#DynamicPPL.TestUtils.test_values"><code>DynamicPPL.TestUtils.test_values</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_values(vi::AbstractVarInfo, vals::NamedTuple, vns)</code></pre><p>Test that <code>vi[vn]</code> corresponds to the correct value in <code>vals</code> for every <code>vn</code> in <code>vns</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/test_utils/varinfo.jl#L6-L10">source</a></section></details></article><h2 id="Debugging-Utilities"><a class="docs-heading-anchor" href="#Debugging-Utilities">Debugging Utilities</a><a id="Debugging-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging-Utilities" title="Permalink"></a></h2><p>DynamicPPL provides a few methods for checking validity of a model-definition.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.DebugUtils.check_model"><a class="docstring-binding" href="#DynamicPPL.DebugUtils.check_model"><code>DynamicPPL.DebugUtils.check_model</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">check_model(model::Model, varinfo::AbstractVarInfo; error_on_failure=false)</code></pre><p>Check that <code>model</code> is valid, warning about any potential issues (or erroring if <code>error_on_failure</code> is <code>true</code>).</p><p><strong>Returns</strong></p><ul><li><code>issuccess::Bool</code>: Whether the model check succeeded.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/debug_utils.jl#L442-L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.DebugUtils.check_model_and_trace"><a class="docstring-binding" href="#DynamicPPL.DebugUtils.check_model_and_trace"><code>DynamicPPL.DebugUtils.check_model_and_trace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">check_model_and_trace(model::Model, varinfo::AbstractVarInfo; error_on_failure=false)</code></pre><p>Check that evaluating <code>model</code> with the given <code>varinfo</code> is valid, warning about any potential issues.</p><p>This will check the model for the following issues:</p><ol><li>Repeated usage of the same varname in a model.</li><li><code>NaN</code> on the left-hand side of observe statements.</li></ol><p><strong>Arguments</strong></p><ul><li><code>model::Model</code>: The model to check.</li><li><code>varinfo::AbstractVarInfo</code>: The varinfo to use when evaluating the model.</li></ul><p><strong>Keyword Argument</strong></p><ul><li><code>error_on_failure::Bool</code>: Whether to throw an error if the model check fails. Default: <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>issuccess::Bool</code>: Whether the model check succeeded.</li><li><code>trace::Vector{Stmt}</code>: The trace of statements executed during the model check.</li></ul><p><strong>Examples</strong></p><p><strong>Correct model</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using StableRNGs

julia&gt; rng = StableRNG(42);

julia&gt; @model demo_correct() = x ~ Normal()
demo_correct (generic function with 2 methods)

julia&gt; model = demo_correct(); varinfo = VarInfo(rng, model);

julia&gt; issuccess, trace = check_model_and_trace(model, varinfo);

julia&gt; issuccess
true

julia&gt; print(trace)
 assume: x ~ Normal{Float64}(μ=0.0, σ=1.0) ⟼ -0.670252

julia&gt; cond_model = model | (x = 1.0,);

julia&gt; issuccess, trace = check_model_and_trace(cond_model, VarInfo(cond_model));
┌ Warning: The model does not contain any parameters.
└ @ DynamicPPL.DebugUtils DynamicPPL.jl/src/debug_utils.jl:342

julia&gt; issuccess
true

julia&gt; print(trace)
 observe: x (= 1.0) ~ Normal{Float64}(μ=0.0, σ=1.0)</code></pre><p><strong>Incorrect model</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_incorrect()
           # (×) Sampling `x` twice will lead to incorrect log-probabilities!
           x ~ Normal()
           x ~ Exponential()
       end
demo_incorrect (generic function with 2 methods)

julia&gt; # Notice that VarInfo(model_incorrect) evaluates the model, but doesn&#39;t actually
       # alert us to the issue of `x` being sampled twice.
       model = demo_incorrect(); varinfo = VarInfo(model);

julia&gt; issuccess, trace = check_model_and_trace(model, varinfo; error_on_failure=true);
ERROR: varname x used multiple times in model</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/debug_utils.jl#L344-L417">source</a></section></details></article><p>And some which might be useful to determine certain properties of the model based on the debug trace.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.DebugUtils.has_static_constraints"><a class="docstring-binding" href="#DynamicPPL.DebugUtils.has_static_constraints"><code>DynamicPPL.DebugUtils.has_static_constraints</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_static_constraints([rng, ]model::Model; num_evals=5, error_on_failure=false)</code></pre><p>Return <code>true</code> if the model has static constraints, <code>false</code> otherwise.</p><p>Note that this is a heuristic check based on sampling from the model multiple times and checking if the model is consistent across runs.</p><p><strong>Arguments</strong></p><ul><li><code>rng::Random.AbstractRNG</code>: The random number generator to use when evaluating the model.</li><li><code>model::Model</code>: The model to check.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>num_evals::Int</code>: The number of evaluations to perform. Default: <code>5</code>.</li><li><code>error_on_failure::Bool</code>: Whether to throw an error if any of the <code>num_evals</code> model checks fail. Default: <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/debug_utils.jl#L467-L483">source</a></section></details></article><p>For determining whether one might have type instabilities in the model, the following can be useful</p><article><details class="docstring" open="true"><summary id="DynamicPPL.DebugUtils.model_warntype"><a class="docstring-binding" href="#DynamicPPL.DebugUtils.model_warntype"><code>DynamicPPL.DebugUtils.model_warntype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">model_warntype(model[, varinfo]; optimize=true)</code></pre><p>Check the type stability of the model&#39;s evaluator, warning about any potential issues.</p><p>This simply calls <code>@code_warntype</code> on the model&#39;s evaluator, filling in internal arguments where needed.</p><p><strong>Arguments</strong></p><ul><li><code>model::Model</code>: The model to check.</li><li><code>varinfo::AbstractVarInfo</code>: The varinfo to use when evaluating the model. Default: <code>VarInfo(model)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>optimize::Bool</code>: Whether to generate optimized code. Default: <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/debug_utils.jl#L536-L549">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.DebugUtils.model_typed"><a class="docstring-binding" href="#DynamicPPL.DebugUtils.model_typed"><code>DynamicPPL.DebugUtils.model_typed</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">model_typed(model[, varinfo]; optimize=true)</code></pre><p>Return the type inference for the model&#39;s evaluator.</p><p>This simply calls <code>@code_typed</code> on the model&#39;s evaluator, filling in internal arguments where needed.</p><p><strong>Arguments</strong></p><ul><li><code>model::Model</code>: The model to check.</li><li><code>varinfo::AbstractVarInfo</code>: The varinfo to use when evaluating the model. Default: <code>VarInfo(model)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>optimize::Bool</code>: Whether to generate optimized code. Default: <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/debug_utils.jl#L557-L570">source</a></section></details></article><p>Interally, the type-checking methods make use of the following method for construction of the call with the argument types:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.DebugUtils.gen_evaluator_call_with_types"><a class="docstring-binding" href="#DynamicPPL.DebugUtils.gen_evaluator_call_with_types"><code>DynamicPPL.DebugUtils.gen_evaluator_call_with_types</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gen_evaluator_call_with_types(model[, varinfo])</code></pre><p>Generate the evaluator call and the types of the arguments.</p><p><strong>Arguments</strong></p><ul><li><code>model::Model</code>: The model whose evaluator is of interest.</li><li><code>varinfo::AbstractVarInfo</code>: The varinfo to use when evaluating the model. Default: <code>VarInfo(model)</code>.</li></ul><p><strong>Returns</strong></p><p>A 2-tuple with the following elements:</p><ul><li><code>f</code>: This is either <code>model.f</code> or <code>Core.kwcall</code>, depending on whether   the model has keyword arguments.</li><li><code>argtypes::Type{&lt;:Tuple}</code>: The types of the arguments for the evaluator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/debug_utils.jl#L510-L524">source</a></section></details></article><h2 id="Advanced"><a class="docs-heading-anchor" href="#Advanced">Advanced</a><a id="Advanced-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced" title="Permalink"></a></h2><h3 id="Variable-names"><a class="docs-heading-anchor" href="#Variable-names">Variable names</a><a id="Variable-names-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-names" title="Permalink"></a></h3><p>Names and possibly nested indices of variables are described with <code>AbstractPPL.VarName</code>. They can be defined with <code>AbstractPPL.@varname</code>. Please see the documentation of <a href="https://github.com/TuringLang/AbstractPPL.jl">AbstractPPL.jl</a> for further information.</p><h3 id="Data-Structures-of-Variables"><a class="docs-heading-anchor" href="#Data-Structures-of-Variables">Data Structures of Variables</a><a id="Data-Structures-of-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures-of-Variables" title="Permalink"></a></h3><p>DynamicPPL provides different data structures used in for storing samples and accumulation of the log-probabilities, all of which are subtypes of <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractVarInfo"><a class="docstring-binding" href="#DynamicPPL.AbstractVarInfo"><code>DynamicPPL.AbstractVarInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractVarInfo</code></pre><p>Abstract supertype for data structures that capture random variables when executing a probabilistic model and accumulate log densities such as the log likelihood or the log joint probability of the model.</p><p>See also: <a href="#VarInfo"><code>VarInfo</code></a>, <a href="#SimpleVarInfo"><code>SimpleVarInfo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/DynamicPPL.jl#L161-L169">source</a></section></details></article><p>But exactly how a <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a> stores this information can vary.</p><h4 id="VarInfo"><a class="docs-heading-anchor" href="#VarInfo"><code>VarInfo</code></a><a id="VarInfo-1"></a><a class="docs-heading-anchor-permalink" href="#VarInfo" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="DynamicPPL.VarInfo"><a class="docstring-binding" href="#DynamicPPL.VarInfo"><code>DynamicPPL.VarInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VarInfo{Tmeta,Accs&lt;:AccumulatorTuple} &lt;: AbstractVarInfo
    metadata::Tmeta
    accs::Accs
end</code></pre><p>A light wrapper over some kind of metadata.</p><p>The type of the metadata can be one of a number of options. It may either be a <code>Metadata</code> or a <code>VarNamedVector</code>, <em>or</em>, it may be a <code>NamedTuple</code> which maps symbols to <code>Metadata</code> or <code>VarNamedVector</code> instances. Here, a <em>symbol</em> refers to a Julia variable and may consist of one or more <code>VarName</code>s which appear on the left-hand side of tilde statements. For example, <code>x[1]</code> and <code>x[2]</code> both have the same symbol <code>x</code>.</p><p>Several type aliases are provided for these forms of VarInfos:</p><ul><li><code>VarInfo{&lt;:Metadata}</code> is <code>UntypedVarInfo</code></li><li><code>VarInfo{&lt;:VarNamedVector}</code> is <code>UntypedVectorVarInfo</code></li><li><code>VarInfo{&lt;:NamedTuple}</code> is <code>NTVarInfo</code></li></ul><p>The NamedTuple form, i.e. <code>NTVarInfo</code>, is useful for maintaining type stability of model evaluation. However, the element type of NamedTuples are not contained in its type itself: thus, there is no way to use the type system to determine whether the elements of the NamedTuple are <code>Metadata</code> or <code>VarNamedVector</code>.</p><p>Note that for NTVarInfo, it is the user&#39;s responsibility to ensure that each symbol is visited at least once during model evaluation, regardless of any stochastic branching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varinfo.jl#L77-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.untyped_varinfo"><a class="docstring-binding" href="#DynamicPPL.untyped_varinfo"><code>DynamicPPL.untyped_varinfo</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">untyped_varinfo([rng, ]model[, init_strategy])</code></pre><p>Construct a VarInfo object for the given <code>model</code>, which has just a single <code>Metadata</code> as its metadata field.</p><p><strong>Arguments</strong></p><ul><li><code>rng::Random.AbstractRNG</code>: The random number generator to use during model evaluation</li><li><code>model::Model</code>: The model for which to create the varinfo object</li><li><code>init_strategy::AbstractInitStrategy</code>: How the values are to be initialised. Defaults to <code>InitFromPrior()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varinfo.jl#L197-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.typed_varinfo"><a class="docstring-binding" href="#DynamicPPL.typed_varinfo"><code>DynamicPPL.typed_varinfo</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">typed_varinfo(vi::UntypedVarInfo)</code></pre><p>This function finds all the unique <code>sym</code>s from the instances of <code>VarName{sym}</code> found in <code>vi.metadata.vns</code>. It then extracts the metadata associated with each symbol from the global <code>vi.metadata</code> field. Finally, a new <code>VarInfo</code> is created with a new <code>metadata</code> as a <code>NamedTuple</code> mapping from symbols to type-stable <code>Metadata</code> instances, one for each symbol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varinfo.jl#L219-L227">source</a></section><section><div><pre><code class="language-julia hljs">typed_varinfo([rng, ]model[, init_strategy])</code></pre><p>Return a VarInfo object for the given <code>model</code>, which has a NamedTuple of <code>Metadata</code> structs as its metadata field.</p><p><strong>Arguments</strong></p><ul><li><code>rng::Random.AbstractRNG</code>: The random number generator to use during model evaluation</li><li><code>model::Model</code>: The model for which to create the varinfo object</li><li><code>init_strategy::AbstractInitStrategy</code>: How the values are to be initialised. Defaults to <code>InitFromPrior()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varinfo.jl#L276-L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.untyped_vector_varinfo"><a class="docstring-binding" href="#DynamicPPL.untyped_vector_varinfo"><code>DynamicPPL.untyped_vector_varinfo</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">untyped_vector_varinfo([rng, ]model[, init_strategy])</code></pre><p>Return a VarInfo object for the given <code>model</code>, which has just a single <code>VarNamedVector</code> as its metadata field.</p><p><strong>Arguments</strong></p><ul><li><code>rng::Random.AbstractRNG</code>: The random number generator to use during model evaluation</li><li><code>model::Model</code>: The model for which to create the varinfo object</li><li><code>init_strategy::AbstractInitStrategy</code>: How the values are to be initialised. Defaults to <code>InitFromPrior()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varinfo.jl#L298-L308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.typed_vector_varinfo"><a class="docstring-binding" href="#DynamicPPL.typed_vector_varinfo"><code>DynamicPPL.typed_vector_varinfo</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">typed_vector_varinfo([rng, ]model[, init_strategy])</code></pre><p>Return a VarInfo object for the given <code>model</code>, which has a NamedTuple of <code>VarNamedVector</code>s as its metadata field.</p><p><strong>Arguments</strong></p><ul><li><code>rng::Random.AbstractRNG</code>: The random number generator to use during model evaluation</li><li><code>model::Model</code>: The model for which to create the varinfo object</li><li><code>init_strategy::AbstractInitStrategy</code>: How the values are to be initialised. Defaults to <code>InitFromPrior()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varinfo.jl#L326-L336">source</a></section></details></article><p>One main characteristic of <a href="#VarInfo"><code>VarInfo</code></a> is that samples are transformed to unconstrained Euclidean space and stored in a linearized form, as described in the <a href="https://turinglang.org/docs/developers/transforms/dynamicppl/">main Turing documentation</a>. The <a href="#Transformations">Transformations section below</a> describes the methods used for this. In the specific case of <code>VarInfo</code>, it keeps track of whether samples have been transformed by setting flags on them, using the following functions.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.is_transformed"><a class="docstring-binding" href="#DynamicPPL.is_transformed"><code>DynamicPPL.is_transformed</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_transformed(vnv::VarNamedVector, vn::VarName)</code></pre><p>Return a boolean for whether <code>vn</code> is guaranteed to have been transformed so that its domain is all of Euclidean space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varnamedvector.jl#L363-L368">source</a></section><section><div><pre><code class="language-julia hljs">is_transformed(vi::AbstractVarInfo[, vns::Union{VarName, AbstractVector{&lt;:Varname}}])</code></pre><p>Return <code>true</code> if <code>vi</code> is working in unconstrained space, and <code>false</code> if <code>vi</code> is assuming realizations to be in support of the corresponding distributions.</p><p>If <code>vns</code> is provided, then only check if this/these varname(s) are transformed.</p><div class="admonition is-warning" id="Warning-3a921ac8441c589"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-3a921ac8441c589" title="Permalink"></a></header><div class="admonition-body"><p>Not all implementations of <code>AbstractVarInfo</code> support transforming only a subset of the variables.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L771-L782">source</a></section><section><div><pre><code class="language-julia hljs">is_transformed(vi::VarInfo)</code></pre><p>Check whether <code>vi</code> is in the transformed space.</p><p>Turing&#39;s Hamiltonian samplers use the <code>link</code> and <code>invlink</code> functions from <a href="https://github.com/TuringLang/Bijectors.jl">Bijectors.jl</a> to map a constrained variable (for example, one bounded to the space <code>[0, 1]</code>) from its constrained space to the set of real numbers. <code>is_transformed</code> checks if the number is in the constrained space or the real space.</p><p>If some but only some of the variables in <code>vi</code> are transformed, this function will return <code>true</code>. This behavior will likely change in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varinfo.jl#L1484-L1497">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.set_transformed!!"><a class="docstring-binding" href="#DynamicPPL.set_transformed!!"><code>DynamicPPL.set_transformed!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_transformed!!(vi::AbstractVarInfo, trans::Bool[, vn::VarName])</code></pre><p>Return <code>vi</code> with <code>is_transformed(vi, vn)</code> evaluating to <code>true</code>.</p><p>If <code>vn</code> is not specified, then <code>is_transformed(vi)</code> evaluates to <code>true</code> for all variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L796-L802">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.empty!"><a class="docstring-binding" href="#Base.empty!"><code>Base.empty!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">empty!(meta::Metadata)</code></pre><p>Empty the fields of <code>meta</code>.</p><p>This is useful when using a sampling algorithm that assumes an empty <code>meta</code>, e.g. <code>SMC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varinfo.jl#L433-L439">source</a></section></details></article><h4 id="SimpleVarInfo"><a class="docs-heading-anchor" href="#SimpleVarInfo"><code>SimpleVarInfo</code></a><a id="SimpleVarInfo-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleVarInfo" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="DynamicPPL.SimpleVarInfo"><a class="docstring-binding" href="#DynamicPPL.SimpleVarInfo"><code>DynamicPPL.SimpleVarInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SimpleVarInfo{NT, Accs&lt;:DynamicPPL.AccumulatorTuple, C&lt;:DynamicPPL.AbstractTransformation} &lt;: AbstractVarInfo</code></pre><p>A simple wrapper of the parameters with a <code>logp</code> field for accumulation of the logdensity.</p><p>Currently only implemented for <code>NT&lt;:NamedTuple</code> and <code>NT&lt;:AbstractDict</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>values</code>: underlying representation of the realization represented</p></li><li><p><code>accs</code>: tuple of accumulators for things like log prior and log likelihood</p></li><li><p><code>transformation</code>: represents whether it assumes variables to be transformed</p></li></ul><p><strong>Notes</strong></p><p>The major differences between this and <code>NTVarInfo</code> are:</p><ol><li><code>SimpleVarInfo</code> does not require linearization.</li><li><code>SimpleVarInfo</code> can use more efficient bijectors.</li><li><code>SimpleVarInfo</code> is only type-stable if <code>NT&lt;:NamedTuple</code> and either a) no indexing is used in tilde-statements, or b) the values have been specified with the correct shapes.</li></ol><p><strong>Examples</strong></p><p><strong>General usage</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using StableRNGs

julia&gt; @model function demo()
           m ~ Normal()
           x = Vector{Float64}(undef, 2)
           for i in eachindex(x)
               x[i] ~ Normal()
           end
           return x
       end
demo (generic function with 2 methods)

julia&gt; m = demo();

julia&gt; rng = StableRNG(42);

julia&gt; # In the `NamedTuple` version we need to provide the place-holder values for
       # the variables which are using &quot;containers&quot;, e.g. `Array`.
       # In this case, this means that we need to specify `x` but not `m`.
       _, vi = DynamicPPL.init!!(rng, m, SimpleVarInfo((x = ones(2), )));

julia&gt; # (✓) Vroom, vroom! FAST!!!
       vi[@varname(x[1])]
0.4471218424633827

julia&gt; # We can also access arbitrary varnames pointing to `x`, e.g.
       vi[@varname(x)]
2-element Vector{Float64}:
 0.4471218424633827
 1.3736306979834252

julia&gt; vi[@varname(x[1:2])]
2-element Vector{Float64}:
 0.4471218424633827
 1.3736306979834252

julia&gt; # (×) If we don&#39;t provide the container...
       _, vi = DynamicPPL.init!!(rng, m, SimpleVarInfo());
ERROR: FieldError: type NamedTuple has no field `x`, available fields: `m`
[...]

julia&gt; # If one does not know the varnames, we can use a `OrderedDict` instead.
       _, vi = DynamicPPL.init!!(rng, m, SimpleVarInfo{Float64}(OrderedDict{VarName,Any}()));

julia&gt; # (✓) Sort of fast, but only possible at runtime.
       vi[@varname(x[1])]
-1.019202452456547

julia&gt; # In addtion, we can only access varnames as they appear in the model!
       vi[@varname(x)]
ERROR: x was not found in the dictionary provided
[...]

julia&gt; vi[@varname(x[1:2])]
ERROR: x[1:2] was not found in the dictionary provided
[...]</code></pre><p><em>Technically</em>, it&#39;s possible to use any implementation of <code>AbstractDict</code> in place of <code>OrderedDict</code>, but <code>OrderedDict</code> ensures that certain operations, e.g. linearization/flattening of the values in the varinfo, are consistent between evaluations. Hence <code>OrderedDict</code> is the preferred implementation of <code>AbstractDict</code> to use here.</p><p>You can also sample in <em>transformed</em> space:</p><pre><code class="language-julia-repl hljs">julia&gt; @model demo_constrained() = x ~ Exponential()
demo_constrained (generic function with 2 methods)

julia&gt; m = demo_constrained();

julia&gt; _, vi = DynamicPPL.init!!(rng, m, SimpleVarInfo());

julia&gt; vi[@varname(x)] # (✓) 0 ≤ x &lt; ∞
1.8632965762164932

julia&gt; _, vi = DynamicPPL.init!!(rng, m, DynamicPPL.set_transformed!!(SimpleVarInfo(), true));

julia&gt; vi[@varname(x)] # (✓) -∞ &lt; x &lt; ∞
-0.21080155351918753

julia&gt; xs = [last(DynamicPPL.init!!(rng, m, DynamicPPL.set_transformed!!(SimpleVarInfo(), true)))[@varname(x)] for i = 1:10];

julia&gt; any(xs .&lt; 0)  # (✓) Positive probability mass on negative numbers!
true

julia&gt; # And with `OrderedDict` of course!
       _, vi = DynamicPPL.init!!(rng, m, DynamicPPL.set_transformed!!(SimpleVarInfo(OrderedDict{VarName,Any}()), true));

julia&gt; vi[@varname(x)] # (✓) -∞ &lt; x &lt; ∞
0.6225185067787314

julia&gt; xs = [last(DynamicPPL.init!!(rng, m, DynamicPPL.set_transformed!!(SimpleVarInfo(), true)))[@varname(x)] for i = 1:10];

julia&gt; any(xs .&lt; 0) # (✓) Positive probability mass on negative numbers!
true</code></pre><p>Evaluation in transformed space of course also works:</p><pre><code class="language-julia-repl hljs">julia&gt; vi = DynamicPPL.set_transformed!!(SimpleVarInfo((x = -1.0,)), true)
Transformed SimpleVarInfo((x = -1.0,), (LogPrior = LogPriorAccumulator(0.0), LogJacobian = LogJacobianAccumulator(0.0), LogLikelihood = LogLikelihoodAccumulator(0.0)))

julia&gt; # (✓) Positive probability mass on negative numbers!
       getlogjoint_internal(last(DynamicPPL.evaluate!!(m, vi)))
-1.3678794411714423

julia&gt; # While if we forget to indicate that it&#39;s transformed:
       vi = DynamicPPL.set_transformed!!(SimpleVarInfo((x = -1.0,)), false)
SimpleVarInfo((x = -1.0,), (LogPrior = LogPriorAccumulator(0.0), LogJacobian = LogJacobianAccumulator(0.0), LogLikelihood = LogLikelihoodAccumulator(0.0)))

julia&gt; # (✓) No probability mass on negative numbers!
       getlogjoint_internal(last(DynamicPPL.evaluate!!(m, vi)))
-Inf</code></pre><p><strong>Indexing</strong></p><p>Using <code>NamedTuple</code> as underlying storage.</p><pre><code class="language-julia-repl hljs">julia&gt; svi_nt = SimpleVarInfo((m = (a = [1.0], ), ));

julia&gt; svi_nt[@varname(m)]
(a = [1.0],)

julia&gt; svi_nt[@varname(m.a)]
1-element Vector{Float64}:
 1.0

julia&gt; svi_nt[@varname(m.a[1])]
1.0

julia&gt; svi_nt[@varname(m.a[2])]
ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]
[...]

julia&gt; svi_nt[@varname(m.b)]
ERROR: FieldError: type NamedTuple has no field `b`, available fields: `a`
[...]</code></pre><p>Using <code>OrderedDict</code> as underlying storage.</p><pre><code class="language-julia-repl hljs">julia&gt; svi_dict = SimpleVarInfo(OrderedDict(@varname(m) =&gt; (a = [1.0], )));

julia&gt; svi_dict[@varname(m)]
(a = [1.0],)

julia&gt; svi_dict[@varname(m.a)]
1-element Vector{Float64}:
 1.0

julia&gt; svi_dict[@varname(m.a[1])]
1.0

julia&gt; svi_dict[@varname(m.a[2])]
ERROR: m.a[2] was not found in the dictionary provided
[...]

julia&gt; svi_dict[@varname(m.b)]
ERROR: m.b was not found in the dictionary provided
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/simple_varinfo.jl#L1-L187">source</a></section></details></article><h3 id="Tilde-pipeline"><a class="docs-heading-anchor" href="#Tilde-pipeline">Tilde-pipeline</a><a id="Tilde-pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Tilde-pipeline" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DynamicPPL.tilde_assume!!"><a class="docstring-binding" href="#DynamicPPL.tilde_assume!!"><code>DynamicPPL.tilde_assume!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.tilde_assume!!(
    context::AbstractContext,
    right::Distribution,
    vn::VarName,
    vi::AbstractVarInfo
)</code></pre><p>Handle assumed variables, i.e. anything which is not observed (see <a href="#DynamicPPL.tilde_observe!!"><code>tilde_observe!!</code></a>). Accumulate the associated log probability, and return the sampled value and updated <code>vi</code>.</p><p><code>vn</code> is the VarName on the left-hand side of the tilde statement.</p><p>This function should return a tuple <code>(x, vi)</code>, where <code>x</code> is the sampled value (which must be in unlinked space!) and <code>vi</code> is the updated VarInfo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts.jl#L123-L139">source</a></section><section><div><pre><code class="language-julia hljs">DynamicPPL.tilde_assume!!(
    ::DefaultContext, right::Distribution, vn::VarName, vi::AbstractVarInfo
)</code></pre><p>Handle assumed variables. For <code>DefaultContext</code>, this function extracts the value associated with <code>vn</code> from <code>vi</code>, If <code>vi</code> does not contain an appropriate value then this will error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/default.jl#L22-L29">source</a></section><section><div><pre><code class="language-julia hljs">DynamicPPL.tilde_assume!!(
    context::AbstractContext,
    right::DynamicPPL.Submodel,
    vn::VarName,
    vi::AbstractVarInfo
)</code></pre><p>Evaluate the submodel with the given context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/submodel.jl#L163-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.tilde_observe!!"><a class="docstring-binding" href="#DynamicPPL.tilde_observe!!"><code>DynamicPPL.tilde_observe!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">DynamicPPL.tilde_observe!!(
    context::AbstractContext,
    right::Distribution,
    left,
    vn::Union{VarName, Nothing},
    vi::AbstractVarInfo
)</code></pre><p>This function handles observed variables, which may be:</p><ul><li>literals on the left-hand side, e.g., <code>3.0 ~ Normal()</code></li><li>a model input, e.g. <code>x ~ Normal()</code> in a model <code>@model f(x) ... end</code></li><li>a conditioned or fixed variable, e.g. <code>x ~ Normal()</code> in a model <code>model | (; x = 3.0)</code>.</li></ul><p>The relevant log-probability associated with the observation is computed and accumulated in the VarInfo object <code>vi</code> (except for fixed variables, which do not contribute to the log-probability).</p><p><code>left</code> is the actual value that the left-hand side evaluates to. <code>vn</code> is the VarName on the left-hand side, or <code>nothing</code> if the left-hand side is a literal value.</p><p>Observations of submodels are not yet supported in DynamicPPL.</p><p>This function should return a tuple <code>(left, vi)</code>, where <code>left</code> is the same as the input, and <code>vi</code> is the updated VarInfo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts.jl#L146-L172">source</a></section><section><div><pre><code class="language-julia hljs">DynamicPPL.tilde_observe!!(
    ::DefaultContext,
    right::Distribution,
    left,
    vn::Union{VarName,Nothing},
    vi::AbstractVarInfo,
)</code></pre><p>Handle observed variables. This just accumulates the log-likelihood for <code>left</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/default.jl#L40-L50">source</a></section></details></article><h3 id="Accumulators"><a class="docs-heading-anchor" href="#Accumulators">Accumulators</a><a id="Accumulators-1"></a><a class="docs-heading-anchor-permalink" href="#Accumulators" title="Permalink"></a></h3><p>The subtypes of <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a> store the cumulative log prior and log likelihood, and sometimes other variables that change during executing, in what are called accumulators.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractAccumulator"><a class="docstring-binding" href="#DynamicPPL.AbstractAccumulator"><code>DynamicPPL.AbstractAccumulator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractAccumulator</code></pre><p>An abstract type for accumulators.</p><p>An accumulator is an object that may change its value at every tilde<em>assume!! or tilde</em>observe!! call based on the random variable in question. The obvious examples of accumulators are the log prior and log likelihood. Other examples might be a variable that counts the number of observations in a trace, or a list of the names of random variables seen so far.</p><p>An accumulator type <code>T &lt;: AbstractAccumulator</code> must implement the following methods:</p><ul><li><code>accumulator_name(acc::T)</code> or <code>accumulator_name(::Type{T})</code></li><li><code>accumulate_observe!!(acc::T, dist, val, vn)</code></li><li><code>accumulate_assume!!(acc::T, val, logjac, vn, dist)</code></li><li><code>reset(acc::T)</code></li><li><code>Base.copy(acc::T)</code></li></ul><p>In these functions:</p><ul><li><code>val</code> is the new value of the random variable sampled from a distribution (always in the original unlinked space), or the value on the left-hand side of an observe statement.</li><li><code>dist</code> is the distribution on the RHS of the tilde statement.</li><li><code>vn</code> is the <code>VarName</code> that is on the left-hand side of the tilde-statement. If the tilde-statement is a literal observation like <code>0.0 ~ Normal()</code>, then <code>vn</code> is <code>nothing</code>.</li><li><code>logjac</code> is the log determinant of the Jacobian of the link transformation, <em>if</em> the variable is stored as a linked value in the VarInfo. If the variable is stored in its original, unlinked form, then <code>logjac</code> is zero.</li></ul><p>To be able to work with multi-threading, it should also implement:</p><ul><li><code>split(acc::T)</code></li><li><code>combine(acc::T, acc2::T)</code></li></ul><p>See the documentation for each of these functions for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/accumulators.jl#L1-L35">source</a></section></details></article><p>DynamicPPL provides the following default accumulators.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.LogPriorAccumulator"><a class="docstring-binding" href="#DynamicPPL.LogPriorAccumulator"><code>DynamicPPL.LogPriorAccumulator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LogPriorAccumulator{T&lt;:Real} &lt;: LogProbAccumulator{T}</code></pre><p>An accumulator that tracks the cumulative log prior during model execution.</p><p>Note that the log prior stored in here is always calculated based on unlinked parameters, i.e., the value of <code>logp</code> is independent of whether tha VarInfo is linked or not.</p><p><strong>Fields</strong></p><ul><li><code>logp::Real</code>: the scalar log prior value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/default_accumulators.jl#L73-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.LogJacobianAccumulator"><a class="docstring-binding" href="#DynamicPPL.LogJacobianAccumulator"><code>DynamicPPL.LogJacobianAccumulator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LogJacobianAccumulator{T&lt;:Real} &lt;: LogProbAccumulator{T}</code></pre><p>An accumulator that tracks the cumulative log Jacobian (technically, log(abs(det(J)))) during model execution. Specifically, J refers to the Jacobian of the <em>link transform</em>, i.e., from the space of the original distribution to unconstrained space.</p><div class="admonition is-info" id="Note-2bf5d73f790a3225"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2bf5d73f790a3225" title="Permalink"></a></header><div class="admonition-body"><p>This accumulator is only incremented if the variable is transformed by a link function, i.e., if the VarInfo is linked (for the particular variable that is currently being accumulated). If the variable is not linked, the log Jacobian term will be 0.</p><p>In general, for the forward Jacobian <span>$\mathbf{J}$</span> corresponding to the function <span>$\mathbf{y} = f(\mathbf{x})$</span>,</p><p class="math-container">\[\log(q(\mathbf{y})) = \log(p(\mathbf{x})) - \log (|\mathbf{J}|)\]</p><p>and correspondingly:</p><pre><code class="language-julia hljs">getlogjoint_internal(vi) = getlogjoint(vi) - getlogjac(vi)</code></pre></div></div><p><strong>Fields</strong></p><ul><li><code>logjac::Real</code>: the logabsdet of the link transform Jacobian</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/default_accumulators.jl#L99-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.LogLikelihoodAccumulator"><a class="docstring-binding" href="#DynamicPPL.LogLikelihoodAccumulator"><code>DynamicPPL.LogLikelihoodAccumulator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LogLikelihoodAccumulator{T&lt;:Real} &lt;: LogProbAccumulator{T}</code></pre><p>An accumulator that tracks the cumulative log likelihood during model execution.</p><p><strong>Fields</strong></p><ul><li><code>logp::Real</code>: the scalar log likelihood value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/default_accumulators.jl#L143-L150">source</a></section></details></article><h3 id="Common-API"><a class="docs-heading-anchor" href="#Common-API">Common API</a><a id="Common-API-1"></a><a class="docs-heading-anchor-permalink" href="#Common-API" title="Permalink"></a></h3><h4 id="Accumulation-of-log-probabilities"><a class="docs-heading-anchor" href="#Accumulation-of-log-probabilities">Accumulation of log-probabilities</a><a id="Accumulation-of-log-probabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Accumulation-of-log-probabilities" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogp"><a class="docstring-binding" href="#DynamicPPL.getlogp"><code>DynamicPPL.getlogp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogp(vi::AbstractVarInfo)</code></pre><p>Return a NamedTuple of the log prior, log Jacobian, and log likelihood probabilities.</p><p>The keys are called <code>logprior</code>, <code>logjac</code>, and <code>loglikelihood</code>. If any of them are not present in <code>vi</code> an error will be thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L118-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setlogp!!"><a class="docstring-binding" href="#DynamicPPL.setlogp!!"><code>DynamicPPL.setlogp!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setlogp!!(vi::AbstractVarInfo, logp::NamedTuple)</code></pre><p>Set both the log prior and the log likelihood probabilities in <code>vi</code>.</p><p><code>logp</code> should have fields <code>logprior</code> and <code>loglikelihood</code> and no other fields.</p><p>See also: <a href="#DynamicPPL.setlogprior!!"><code>setlogprior!!</code></a>, <a href="#DynamicPPL.setloglikelihood!!"><code>setloglikelihood!!</code></a>, <a href="#DynamicPPL.getlogp"><code>getlogp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L260-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.acclogp!!"><a class="docstring-binding" href="#DynamicPPL.acclogp!!"><code>DynamicPPL.acclogp!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">acclogp!!(vi::AbstractVarInfo, logp::NamedTuple; ignore_missing_accumulator::Bool=false)</code></pre><p>Add to both the log prior and the log likelihood probabilities in <code>vi</code>.</p><p><code>logp</code> should have fields <code>logprior</code> and/or <code>loglikelihood</code>, and no other fields.</p><p>By default if the necessary accumulators are not in <code>vi</code> an error is thrown. If <code>ignore_missing_accumulator</code> is set to <code>true</code> then this is silently ignored instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L395-L404">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogjoint"><a class="docstring-binding" href="#DynamicPPL.getlogjoint"><code>DynamicPPL.getlogjoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogjoint(vi::AbstractVarInfo)</code></pre><p>Return the log of the joint probability of the observed data and parameters in <code>vi</code>.</p><p>See also: <a href="#DynamicPPL.getlogprior"><code>getlogprior</code></a>, <a href="#DynamicPPL.getloglikelihood"><code>getloglikelihood</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L93-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogjoint_internal"><a class="docstring-binding" href="#DynamicPPL.getlogjoint_internal"><code>DynamicPPL.getlogjoint_internal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogjoint_internal(vi::AbstractVarInfo)</code></pre><p>Return the log of the joint probability of the observed data and parameters as they are stored internally in <code>vi</code>, including the log-Jacobian for any linked parameters.</p><p>In general, we have that:</p><pre><code class="language-julia hljs">getlogjoint_internal(vi) == getlogjoint(vi) - getlogjac(vi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L102-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogjac"><a class="docstring-binding" href="#DynamicPPL.getlogjac"><code>DynamicPPL.getlogjac</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogjac(vi::AbstractVarInfo)</code></pre><p>Return the accumulated log-Jacobian term for any linked parameters in <code>vi</code>. The Jacobian here is taken with respect to the forward (link) transform.</p><p>See also: <a href="#DynamicPPL.setlogjac!!"><code>setlogjac!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L199-L206">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setlogjac!!"><a class="docstring-binding" href="#DynamicPPL.setlogjac!!"><code>DynamicPPL.setlogjac!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setlogjac!!(vi::AbstractVarInfo, logjac)</code></pre><p>Set the accumulated log-Jacobian term for any linked parameters in <code>vi</code>. The Jacobian here is taken with respect to the forward (link) transform.</p><p>See also: <a href="#DynamicPPL.getlogjac"><code>getlogjac</code></a>, <a href="#DynamicPPL.acclogjac!!"><code>acclogjac!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L241-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.acclogjac!!"><a class="docstring-binding" href="#DynamicPPL.acclogjac!!"><code>DynamicPPL.acclogjac!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">acclogjac!!(vi::AbstractVarInfo, logjac)</code></pre><p>Add <code>logjac</code> to the value of the log Jacobian in <code>vi</code>.</p><p>See also: <a href="#DynamicPPL.getlogjac"><code>getlogjac</code></a>, <a href="#DynamicPPL.setlogjac!!"><code>setlogjac!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L373-L379">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogprior"><a class="docstring-binding" href="#DynamicPPL.getlogprior"><code>DynamicPPL.getlogprior</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogprior(vi::AbstractVarInfo)</code></pre><p>Return the log of the prior probability of the parameters in <code>vi</code>.</p><p>See also: <a href="#DynamicPPL.getlogjoint"><code>getlogjoint</code></a>, <a href="#DynamicPPL.getloglikelihood"><code>getloglikelihood</code></a>, <a href="#DynamicPPL.setlogprior!!"><code>setlogprior!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L176-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getlogprior_internal"><a class="docstring-binding" href="#DynamicPPL.getlogprior_internal"><code>DynamicPPL.getlogprior_internal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getlogprior_internal(vi::AbstractVarInfo)</code></pre><p>Return the log of the prior probability of the parameters as stored internally in <code>vi</code>. This includes the log-Jacobian for any linked parameters.</p><p>In general, we have that:</p><pre><code class="language-julia hljs">getlogprior_internal(vi) == getlogprior(vi) - getlogjac(vi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L185-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setlogprior!!"><a class="docstring-binding" href="#DynamicPPL.setlogprior!!"><code>DynamicPPL.setlogprior!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setlogprior!!(vi::AbstractVarInfo, logp)</code></pre><p>Set the log of the prior probability of the parameters sampled in <code>vi</code> to <code>logp</code>.</p><p>See also: <a href="#DynamicPPL.setloglikelihood!!"><code>setloglikelihood!!</code></a>, <a href="#DynamicPPL.setlogp!!"><code>setlogp!!</code></a>, <a href="#DynamicPPL.getlogprior"><code>getlogprior</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L232-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.acclogprior!!"><a class="docstring-binding" href="#DynamicPPL.acclogprior!!"><code>DynamicPPL.acclogprior!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">acclogprior!!(vi::AbstractVarInfo, logp)</code></pre><p>Add <code>logp</code> to the value of the log of the prior probability in <code>vi</code>.</p><p>See also: <a href="#DynamicPPL.accloglikelihood!!"><code>accloglikelihood!!</code></a>, <a href="#DynamicPPL.acclogp!!"><code>acclogp!!</code></a>, <a href="#DynamicPPL.getlogprior"><code>getlogprior</code></a>, <a href="#DynamicPPL.setlogprior!!"><code>setlogprior!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L362-L368">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getloglikelihood"><a class="docstring-binding" href="#DynamicPPL.getloglikelihood"><code>DynamicPPL.getloglikelihood</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getloglikelihood(vi::AbstractVarInfo)</code></pre><p>Return the log of the likelihood probability of the observed data in <code>vi</code>.</p><p>See also: <a href="#DynamicPPL.getlogjoint"><code>getlogjoint</code></a>, <a href="#DynamicPPL.getlogprior"><code>getlogprior</code></a>, <a href="#DynamicPPL.setloglikelihood!!"><code>setloglikelihood!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L209-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setloglikelihood!!"><a class="docstring-binding" href="#DynamicPPL.setloglikelihood!!"><code>DynamicPPL.setloglikelihood!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setloglikelihood!!(vi::AbstractVarInfo, logp)</code></pre><p>Set the log of the likelihood probability of the observed data sampled in <code>vi</code> to <code>logp</code>.</p><p>See also: <a href="#DynamicPPL.setlogprior!!"><code>setlogprior!!</code></a>, <a href="#DynamicPPL.setlogp!!"><code>setlogp!!</code></a>, <a href="#DynamicPPL.getloglikelihood"><code>getloglikelihood</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L251-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.accloglikelihood!!"><a class="docstring-binding" href="#DynamicPPL.accloglikelihood!!"><code>DynamicPPL.accloglikelihood!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">accloglikelihood!!(vi::AbstractVarInfo, logp)</code></pre><p>Add <code>logp</code> to the value of the log of the likelihood in <code>vi</code>.</p><p>See also: <a href="#DynamicPPL.accloglikelihood!!"><code>accloglikelihood!!</code></a>, <a href="#DynamicPPL.acclogp!!"><code>acclogp!!</code></a>, <a href="#DynamicPPL.getloglikelihood"><code>getloglikelihood</code></a>, <a href="#DynamicPPL.setloglikelihood!!"><code>setloglikelihood!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L384-L390">source</a></section></details></article><h4 id="Variables-and-their-realizations"><a class="docs-heading-anchor" href="#Variables-and-their-realizations">Variables and their realizations</a><a id="Variables-and-their-realizations-1"></a><a class="docs-heading-anchor-permalink" href="#Variables-and-their-realizations" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="Base.keys"><a class="docstring-binding" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">keys(vi::AbstractVarInfo)</code></pre><p>Return an iterator over all <code>vns</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L436-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex"><a class="docstring-binding" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getindex(vi::AbstractVarInfo, vn::VarName[, dist::Distribution])
getindex(vi::AbstractVarInfo, vns::Vector{&lt;:VarName}[, dist::Distribution])</code></pre><p>Return the current value(s) of <code>vn</code> (<code>vns</code>) in <code>vi</code> in the support of its (their) distribution(s).</p><p>If <code>dist</code> is specified, the value(s) will be massaged into the representation expected by <code>dist</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L442-L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BangBang.push!!"><a class="docstring-binding" href="#BangBang.push!!"><code>BangBang.push!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">push!!(vi::VarInfo, vn::VarName, r, dist::Distribution)</code></pre><p>Push a new random variable <code>vn</code> with a sampled value <code>r</code> from a distribution <code>dist</code> to the <code>VarInfo</code> <code>vi</code>, mutating if it makes sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varinfo.jl#L1663-L1668">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BangBang.empty!!"><a class="docstring-binding" href="#BangBang.empty!!"><code>BangBang.empty!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">empty!!(vi::AbstractVarInfo)</code></pre><p>Empty <code>vi</code> of variables and reset all accumulators.</p><p>This is useful when using a sampling algorithm that assumes an empty <code>vi</code>, e.g. <code>SMC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L482-L488">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isempty"><a class="docstring-binding" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isempty(vi::AbstractVarInfo)</code></pre><p>Return true if <code>vi</code> is empty and false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L490-L494">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.getindex_internal"><a class="docstring-binding" href="#DynamicPPL.getindex_internal"><code>DynamicPPL.getindex_internal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getindex_internal(vi::AbstractVarInfo, vn::VarName)
getindex_internal(vi::AbstractVarInfo, vns::Vector{&lt;:VarName})
getindex_internal(vi::AbstractVarInfo, ::Colon)</code></pre><p>Return the internal value of the varname <code>vn</code>, varnames <code>vns</code>, or all varnames in <code>vi</code> respectively. The internal value is the value of the variables that is stored in the varinfo object; this may be the actual realisation of the random variable (i.e. the value sampled from the distribution), or it may have been transformed to Euclidean space, depending on whether the varinfo was linked.</p><p>See https://turinglang.org/docs/developers/transforms/dynamicppl/ for more information on how transformed variables are stored in DynamicPPL.</p><p>See also: <a href="#Base.getindex"><code>getindex(vi::AbstractVarInfo, vn::VarName, dist::Distribution)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L464-L479">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.setindex_internal!"><a class="docstring-binding" href="#DynamicPPL.setindex_internal!"><code>DynamicPPL.setindex_internal!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setindex_internal!(vnv::VarNamedVector, val, i::Int)</code></pre><p>Sets the <code>i</code>th element of the internal storage vector, ignoring inactive entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varnamedvector.jl#L641-L645">source</a></section><section><div><pre><code class="language-julia hljs">setindex_internal!(vnv::VarNamedVector, val, vn::VarName[, transform])</code></pre><p>Like <code>setindex!</code>, but sets the values as they are stored internally in <code>vnv</code>.</p><p>Optionally can set the transformation, such that <code>transform(val)</code> is the original value of the variable. By default, the transform is the identity if creating a new entry in <code>vnv</code>, or the existing transform if updating an existing entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varnamedvector.jl#L650-L658">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.update_internal!"><a class="docstring-binding" href="#DynamicPPL.update_internal!"><code>DynamicPPL.update_internal!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update_internal!(vnv::VarNamedVector, vn::VarName, val::AbstractVector[, transform])</code></pre><p>Update an existing entry for <code>vn</code> in <code>vnv</code> with the value <code>val</code>.</p><p>Like <code>setindex_internal!</code>, but errors if the key <code>vn</code> doesn&#39;t exist.</p><p><code>transform</code> should be a function that converts <code>val</code> to the original representation. By default it&#39;s the same as the old transform for <code>vn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varnamedvector.jl#L698-L707">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.insert_internal!"><a class="docstring-binding" href="#DynamicPPL.insert_internal!"><code>DynamicPPL.insert_internal!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">insert_internal!(vnv::VarNamedVector, val::AbstractVector, vn::VarName[, transform])</code></pre><p>Add a variable with given value to <code>vnv</code>.</p><p>Like <code>setindex_internal!</code>, but errors if the key <code>vn</code> already exists.</p><p><code>transform</code> should be a function that converts <code>val</code> to the original representation. By default it&#39;s <code>identity</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varnamedvector.jl#L669-L678">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.length_internal"><a class="docstring-binding" href="#DynamicPPL.length_internal"><code>DynamicPPL.length_internal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">length_internal(vnv::VarNamedVector)</code></pre><p>Return the length of the internal storage vector of <code>vnv</code>, ignoring inactive entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varnamedvector.jl#L443-L447">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.reset!"><a class="docstring-binding" href="#DynamicPPL.reset!"><code>DynamicPPL.reset!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reset!(vnv::VarNamedVector, val, vn::VarName)</code></pre><p>Reset the value of <code>vn</code> in <code>vnv</code> to <code>val</code>.</p><p>This differs from <code>setindex!</code> in that it will always change the transform of the variable to be the default vectorisation transform. This undoes any possible linking.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL: VarNamedVector, @varname, reset!

julia&gt; vnv = VarNamedVector{VarName,Any,Any}();

julia&gt; vnv[@varname(x)] = reshape(1:9, (3, 3));

julia&gt; setindex!(vnv, 2.0, @varname(x))
ERROR: An error occurred while assigning the value 2.0 to variable x. If you are changing the type or size of a variable you&#39;ll need to call reset!
[...]

julia&gt; reset!(vnv, 2.0, @varname(x));

julia&gt; vnv[@varname(x)]
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varnamedvector.jl#L557-L583">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.update!"><a class="docstring-binding" href="#DynamicPPL.update!"><code>DynamicPPL.update!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update!(vnv::VarNamedVector, val, vn::VarName)</code></pre><p>Update the value of <code>vn</code> in <code>vnv</code> to <code>val</code>.</p><p>Like <code>setindex!</code>, but errors if the key <code>vn</code> doesn&#39;t exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varnamedvector.jl#L591-L597">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.insert!"><a class="docstring-binding" href="#Base.insert!"><code>Base.insert!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">insert!(vnv::VarNamedVector, val, vn::VarName)</code></pre><p>Add a variable with given value to <code>vnv</code>.</p><p>Like <code>setindex!</code>, but errors if the key <code>vn</code> already exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varnamedvector.jl#L615-L621">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.loosen_types!!"><a class="docstring-binding" href="#DynamicPPL.loosen_types!!"><code>DynamicPPL.loosen_types!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">loosen_types!!(vnv::VarNamedVector, ::Type{KNew}, ::Type{VNew}, ::Type{TNew})</code></pre><p>Loosen the types of <code>vnv</code> to allow varname type <code>KNew</code> and transformation type <code>TransNew</code>.</p><p>If <code>KNew</code> is a subtype of <code>K</code> and <code>TransNew</code> is a subtype of the element type of the <code>TTrans</code> then this is a no-op and <code>vnv</code> is returned as is. Otherwise a new <code>VarNamedVector</code> is returned with the same data but more abstract types, so that variables of type <code>KNew</code> and transformations of type <code>TransNew</code> can be pushed to it. Some of the underlying storage is shared between <code>vnv</code> and the return value, and thus mutating one may affect the other.</p><p><strong>See also</strong></p><p><a href="#DynamicPPL.tighten_types!!"><code>tighten_types!!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL: VarNamedVector, @varname, loosen_types!!, setindex_internal!

julia&gt; vnv = VarNamedVector(@varname(x) =&gt; [1.0]);

julia&gt; y_trans(x) = reshape(x, (2, 2));

julia&gt; setindex_internal!(vnv, collect(1:4), @varname(y), y_trans)
ERROR: MethodError: Cannot `convert` an object of type
[...]

julia&gt; vnv_loose = DynamicPPL.loosen_types!!(
           vnv, typeof(@varname(y)), Float64, typeof(y_trans)
       );

julia&gt; setindex_internal!(vnv_loose, collect(1:4), @varname(y), y_trans)

julia&gt; vnv_loose[@varname(y)]
2×2 Matrix{Float64}:
 1.0  3.0
 2.0  4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varnamedvector.jl#L822-L860">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.tighten_types!!"><a class="docstring-binding" href="#DynamicPPL.tighten_types!!"><code>DynamicPPL.tighten_types!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tighten_types!!(vnv::VarNamedVector)</code></pre><p>Return a <code>VarNamedVector</code> like <code>vnv</code> with the most concrete types possible.</p><p>This function either returns <code>vnv</code> itself or new <code>VarNamedVector</code> with the same values in it, but with the element types of various containers made as concrete as possible.</p><p>For instance, if <code>vnv</code> has its vector of transforms have eltype <code>Any</code>, but all the transforms are actually identity transformations, this function will return a new <code>VarNamedVector</code> with the transforms vector having eltype <code>typeof(identity)</code>.</p><p>This is a lot like the reverse of <a href="#DynamicPPL.loosen_types!!"><code>loosen_types!!</code></a>. Like with <code>loosen_types!!</code>, the return value may share some of its underlying storage with <code>vnv</code>, and thus mutating one may affect the other.</p><p><strong>See also</strong></p><p><a href="#DynamicPPL.loosen_types!!"><code>loosen_types!!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL: VarNamedVector, @varname, loosen_types!!, setindex_internal!

julia&gt; vnv = VarNamedVector(@varname(x) =&gt; Real[23], @varname(y) =&gt; randn(2,2));

julia&gt; vnv = delete!(vnv, @varname(y));

julia&gt; eltype(vnv)
Real

julia&gt; vnv.transforms
1-element Vector{Any}:
 identity (generic function with 1 method)

julia&gt; vnv_tight = DynamicPPL.tighten_types!!(vnv);

julia&gt; eltype(vnv_tight) == Int
true

julia&gt; vnv_tight.transforms
1-element Vector{typeof(identity)}:
 identity (generic function with 1 method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/varnamedvector.jl#L913-L957">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.values_as"><a class="docstring-binding" href="#DynamicPPL.values_as"><code>DynamicPPL.values_as</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">values_as(varinfo[, Type])</code></pre><p>Return the values/realizations in <code>varinfo</code> as <code>Type</code>, if implemented.</p><p>If no <code>Type</code> is provided, return values as stored in <code>varinfo</code>.</p><p><strong>Examples</strong></p><p><code>SimpleVarInfo</code> with <code>NamedTuple</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; data = (x = 1.0, m = [2.0]);

julia&gt; values_as(SimpleVarInfo(data))
(x = 1.0, m = [2.0])

julia&gt; values_as(SimpleVarInfo(data), NamedTuple)
(x = 1.0, m = [2.0])

julia&gt; values_as(SimpleVarInfo(data), OrderedDict)
OrderedDict{VarName{sym, typeof(identity)} where sym, Any} with 2 entries:
  x =&gt; 1.0
  m =&gt; [2.0]

julia&gt; values_as(SimpleVarInfo(data), Vector)
2-element Vector{Float64}:
 1.0
 2.0</code></pre><p><code>SimpleVarInfo</code> with <code>OrderedDict</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; data = OrderedDict{Any,Any}(@varname(x) =&gt; 1.0, @varname(m) =&gt; [2.0]);

julia&gt; values_as(SimpleVarInfo(data))
OrderedDict{Any, Any} with 2 entries:
  x =&gt; 1.0
  m =&gt; [2.0]

julia&gt; values_as(SimpleVarInfo(data), NamedTuple)
(x = 1.0, m = [2.0])

julia&gt; values_as(SimpleVarInfo(data), OrderedDict)
OrderedDict{Any, Any} with 2 entries:
  x =&gt; 1.0
  m =&gt; [2.0]

julia&gt; values_as(SimpleVarInfo(data), Vector)
2-element Vector{Float64}:
 1.0
 2.0</code></pre><p><code>VarInfo</code> with <code>NamedTuple</code> of <code>Metadata</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; # Just use an example model to construct the `VarInfo` because we&#39;re lazy.
       vi = DynamicPPL.typed_varinfo(DynamicPPL.TestUtils.demo_assume_dot_observe());

julia&gt; vi[@varname(s)] = 1.0; vi[@varname(m)] = 2.0;

julia&gt; # For the sake of brevity, let&#39;s just check the type.
       md = values_as(vi); md.s isa Union{DynamicPPL.Metadata, DynamicPPL.VarNamedVector}
true

julia&gt; values_as(vi, NamedTuple)
(s = 1.0, m = 2.0)

julia&gt; values_as(vi, OrderedDict)
OrderedDict{VarName{sym, typeof(identity)} where sym, Float64} with 2 entries:
  s =&gt; 1.0
  m =&gt; 2.0

julia&gt; values_as(vi, Vector)
2-element Vector{Float64}:
 1.0
 2.0</code></pre><p><code>VarInfo</code> with <code>Metadata</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; # Just use an example model to construct the `VarInfo` because we&#39;re lazy.
       vi = DynamicPPL.untyped_varinfo(DynamicPPL.TestUtils.demo_assume_dot_observe());

julia&gt; vi[@varname(s)] = 1.0; vi[@varname(m)] = 2.0;

julia&gt; # For the sake of brevity, let&#39;s just check the type.
       values_as(vi) isa Union{DynamicPPL.Metadata, Vector}
true

julia&gt; values_as(vi, NamedTuple)
(s = 1.0, m = 2.0)

julia&gt; values_as(vi, OrderedDict)
OrderedDict{VarName{sym, typeof(identity)} where sym, Float64} with 2 entries:
  s =&gt; 1.0
  m =&gt; 2.0

julia&gt; values_as(vi, Vector)
2-element Vector{Real}:
 1.0
 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L496-L602">source</a></section></details></article><h4 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractTransformation"><a class="docstring-binding" href="#DynamicPPL.AbstractTransformation"><code>DynamicPPL.AbstractTransformation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractTransformation</code></pre><p>Represents a transformation to be used in <code>link!!</code> and <code>invlink!!</code>, amongst others.</p><p>A concrete implementation of this should implement the following methods:</p><ul><li><a href="#DynamicPPL.link!!"><code>link!!</code></a>: transforms the <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a> to the unconstrained space.</li><li><a href="#DynamicPPL.invlink!!"><code>invlink!!</code></a>: transforms the <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a> to the constrained space.</li></ul><p>And potentially:</p><ul><li><a href="#DynamicPPL.maybe_invlink_before_eval!!"><code>maybe_invlink_before_eval!!</code></a>: hook to decide whether to transform <em>before</em> evaluating the model.</li></ul><p>See also: <a href="#DynamicPPL.link!!"><code>link!!</code></a>, <a href="#DynamicPPL.invlink!!"><code>invlink!!</code></a>, <a href="#DynamicPPL.maybe_invlink_before_eval!!"><code>maybe_invlink_before_eval!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L2-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.NoTransformation"><a class="docstring-binding" href="#DynamicPPL.NoTransformation"><code>DynamicPPL.NoTransformation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NoTransformation &lt;: DynamicPPL.AbstractTransformation</code></pre><p>Transformation which applies the identity function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L19-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.DynamicTransformation"><a class="docstring-binding" href="#DynamicPPL.DynamicTransformation"><code>DynamicPPL.DynamicTransformation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DynamicTransformation &lt;: DynamicPPL.AbstractTransformation</code></pre><p>Transformation which transforms the variables on a per-need-basis in the execution of a given <code>Model</code>.</p><p>This is in constrast to <code>StaticTransformation</code> which transforms all variables <em>before</em> the execution of a given <code>Model</code>.</p><p>See also: <a href="#DynamicPPL.StaticTransformation"><code>StaticTransformation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L26-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.StaticTransformation"><a class="docstring-binding" href="#DynamicPPL.StaticTransformation"><code>DynamicPPL.StaticTransformation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct StaticTransformation{F} &lt;: DynamicPPL.AbstractTransformation</code></pre><p>Transformation which transforms all variables <em>before</em> the execution of a given <code>Model</code>.</p><p>This is done through the <code>maybe_invlink_before_eval!!</code> method.</p><p>See also: <a href="#DynamicPPL.DynamicTransformation"><code>DynamicTransformation</code></a>, <a href="#DynamicPPL.maybe_invlink_before_eval!!"><code>maybe_invlink_before_eval!!</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>bijector::Any</code>: The function, assumed to implement the <code>Bijectors</code> interface, to be applied to the variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L39-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.transformation"><a class="docstring-binding" href="#DynamicPPL.transformation"><code>DynamicPPL.transformation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transformation(vi::AbstractVarInfo)</code></pre><p>Return the <code>AbstractTransformation</code> related to <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L85-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bijectors.link"><a class="docstring-binding" href="#Bijectors.link"><code>Bijectors.link</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">link([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)
link([t::AbstractTransformation, ]vi::AbstractVarInfo, vns::NTuple{N,VarName}, model::Model)</code></pre><p>Transform variables in <code>vi</code> to their linked space without mutating <code>vi</code>.</p><p>Either transform all variables, or only ones specified in <code>vns</code>.</p><p>Use the  transformation <code>t</code>, or <code>default_transformation(model, vi)</code> if one is not provided.</p><p>See also: <a href="#DynamicPPL.default_transformation"><code>default_transformation</code></a>, <a href="#Bijectors.invlink"><code>invlink</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L851-L862">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bijectors.invlink"><a class="docstring-binding" href="#Bijectors.invlink"><code>Bijectors.invlink</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">invlink([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)
invlink([t::AbstractTransformation, ]vi::AbstractVarInfo, vns::NTuple{N,VarName}, model::Model)</code></pre><p>Transform variables in <code>vi</code> to their constrained space without mutating <code>vi</code>.</p><p>Either transform all variables, or only ones specified in <code>vns</code>.</p><p>Use the (inverse of) transformation <code>t</code>, or <code>default_transformation(model, vi)</code> if one is not provided.</p><p>See also: <a href="#DynamicPPL.default_transformation"><code>default_transformation</code></a>, <a href="#Bijectors.link"><code>link</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L916-L928">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.link!!"><a class="docstring-binding" href="#DynamicPPL.link!!"><code>DynamicPPL.link!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">link!!([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)
link!!([t::AbstractTransformation, ]vi::AbstractVarInfo, vns::NTuple{N,VarName}, model::Model)</code></pre><p>Transform variables in <code>vi</code> to their linked space, mutating <code>vi</code> if possible.</p><p>Either transform all variables, or only ones specified in <code>vns</code>.</p><p>Use the  transformation <code>t</code>, or <code>default_transformation(model, vi)</code> if one is not provided.</p><p>See also: <a href="#DynamicPPL.default_transformation"><code>default_transformation</code></a>, <a href="#DynamicPPL.invlink!!"><code>invlink!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L812-L823">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.invlink!!"><a class="docstring-binding" href="#DynamicPPL.invlink!!"><code>DynamicPPL.invlink!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">invlink!!([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)
invlink!!([t::AbstractTransformation, ]vi::AbstractVarInfo, vns::NTuple{N,VarName}, model::Model)</code></pre><p>Transform variables in <code>vi</code> to their constrained space, mutating <code>vi</code> if possible.</p><p>Either transform all variables, or only ones specified in <code>vns</code>.</p><p>Use the (inverse of) transformation <code>t</code>, or <code>default_transformation(model, vi)</code> if one is not provided.</p><p>See also: <a href="#DynamicPPL.default_transformation"><code>default_transformation</code></a>, <a href="#DynamicPPL.link!!"><code>link!!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L873-L885">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.default_transformation"><a class="docstring-binding" href="#DynamicPPL.default_transformation"><code>DynamicPPL.default_transformation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_transformation(model::Model[, vi::AbstractVarInfo])</code></pre><p>Return the <code>AbstractTransformation</code> currently related to <code>model</code> and, potentially, <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L77-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.link_transform"><a class="docstring-binding" href="#DynamicPPL.link_transform"><code>DynamicPPL.link_transform</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">link_transform(dist)</code></pre><p>Return the constrained-to-unconstrained bijector for distribution <code>dist</code>.</p><p>By default, this is just <code>Bijectors.bijector(dist)</code>.</p><div class="admonition is-warning" id="Warning-b0fadc157c223fc0"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-b0fadc157c223fc0" title="Permalink"></a></header><div class="admonition-body"><p>Note that currently this is not used by <code>Bijectors.logpdf_with_trans</code>, hence that needs to be overloaded separately if the intention is to change behavior of an existing distribution.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/utils.jl#L200-L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.invlink_transform"><a class="docstring-binding" href="#DynamicPPL.invlink_transform"><code>DynamicPPL.invlink_transform</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">invlink_transform(dist)</code></pre><p>Return the unconstrained-to-constrained bijector for distribution <code>dist</code>.</p><p>By default, this is just <code>inverse(link_transform(dist))</code>.</p><div class="admonition is-warning" id="Warning-b0fadc157c223fc0"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-b0fadc157c223fc0" title="Permalink"></a></header><div class="admonition-body"><p>Note that currently this is not used by <code>Bijectors.logpdf_with_trans</code>, hence that needs to be overloaded separately if the intention is to change behavior of an existing distribution.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/utils.jl#L214-L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.maybe_invlink_before_eval!!"><a class="docstring-binding" href="#DynamicPPL.maybe_invlink_before_eval!!"><code>DynamicPPL.maybe_invlink_before_eval!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">maybe_invlink_before_eval!!([t::Transformation,] vi, model)</code></pre><p>Return a possibly invlinked version of <code>vi</code>.</p><p>This will be called prior to <code>model</code> evaluation, allowing one to perform a single <code>invlink!!</code> <em>before</em> evaluation rather than lazyily evaluating the transforms on as-we-need basis as is done with <a href="#DynamicPPL.DynamicTransformation"><code>DynamicTransformation</code></a>.</p><p>See also: <a href="#DynamicPPL.StaticTransformation"><code>StaticTransformation</code></a>, <a href="#DynamicPPL.DynamicTransformation"><code>DynamicTransformation</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions, Bijectors

julia&gt; @model demo() = x ~ Normal()
demo (generic function with 2 methods)

julia&gt; # By subtyping `Transform`, we inherit the `(inv)link!!`.
       struct MyBijector &lt;: Bijectors.Transform end

julia&gt; # Define some dummy `inverse` which will be used in the `link!!` call.
       Bijectors.inverse(f::MyBijector) = identity

julia&gt; # We need to define `with_logabsdet_jacobian` for `MyBijector`
       # (`identity` already has `with_logabsdet_jacobian` defined)
       function Bijectors.with_logabsdet_jacobian(::MyBijector, x)
           # Just using a large number of the logabsdet-jacobian term
           # for demonstration purposes.
           return (x, 1000)
       end

julia&gt; # Change the `default_transformation` for our model to be a
       # `StaticTransformation` using `MyBijector`.
       function DynamicPPL.default_transformation(::Model{typeof(demo)})
           return DynamicPPL.StaticTransformation(MyBijector())
       end

julia&gt; model = demo();

julia&gt; vi = SimpleVarInfo(x=1.0)
SimpleVarInfo((x = 1.0,), 0.0)

julia&gt; # Uses the `inverse` of `MyBijector`, which we have defined as `identity`
       vi_linked = link!!(vi, model)
Transformed SimpleVarInfo((x = 1.0,), 0.0)

julia&gt; # Now performs a single `invlink!!` before model evaluation.
       logjoint(model, vi_linked)
-1001.4189385332047</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L939-L990">source</a></section></details></article><h4 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="Base.merge-Tuple{AbstractVarInfo}"><a class="docstring-binding" href="#Base.merge-Tuple{AbstractVarInfo}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">merge(varinfo, other_varinfos...)</code></pre><p>Merge varinfos into one, giving precedence to the right-most varinfo when sensible.</p><p>This is particularly useful when combined with <a href="#DynamicPPL.subset"><code>subset(varinfo, vns)</code></a>.</p><p>See docstring of <a href="#DynamicPPL.subset"><code>subset(varinfo, vns)</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L750-L758">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.subset"><a class="docstring-binding" href="#DynamicPPL.subset"><code>DynamicPPL.subset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">subset(varinfo::AbstractVarInfo, vns::AbstractVector{&lt;:VarName})</code></pre><p>Subset a <code>varinfo</code> to only contain the variables <code>vns</code>.</p><p>The ordering of variables in the return value will be the same as in <code>varinfo</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo()
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, sqrt(s))
           x = Vector{Float64}(undef, 2)
           x[1] ~ Normal(m, sqrt(s))
           x[2] ~ Normal(m, sqrt(s))
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; varinfo = VarInfo(model);

julia&gt; keys(varinfo)
4-element Vector{VarName}:
 s
 m
 x[1]
 x[2]

julia&gt; for (i, vn) in enumerate(keys(varinfo))
           varinfo[vn] = i
       end

julia&gt; varinfo[[@varname(s), @varname(m), @varname(x[1]), @varname(x[2])]]
4-element Vector{Float64}:
 1.0
 2.0
 3.0
 4.0

julia&gt; # Extract one with only `m`.
       varinfo_subset1 = subset(varinfo, [@varname(m),]);


julia&gt; keys(varinfo_subset1)
1-element Vector{VarName{:m, typeof(identity)}}:
 m

julia&gt; varinfo_subset1[@varname(m)]
2.0

julia&gt; # Extract one with both `s` and `x[2]`.
       varinfo_subset2 = subset(varinfo, [@varname(s), @varname(x[2])]);

julia&gt; keys(varinfo_subset2)
2-element Vector{VarName}:
 s
 x[2]

julia&gt; varinfo_subset2[[@varname(s), @varname(x[2])]]
2-element Vector{Float64}:
 1.0
 4.0</code></pre><p><code>subset</code> is particularly useful when combined with <a href="#Base.merge-Tuple{AbstractVarInfo}"><code>merge(varinfo::AbstractVarInfo)</code></a></p><pre><code class="language-julia-repl hljs">julia&gt; # Merge the two.
       varinfo_subset_merged = merge(varinfo_subset1, varinfo_subset2);

julia&gt; keys(varinfo_subset_merged)
3-element Vector{VarName}:
 m
 s
 x[2]

julia&gt; varinfo_subset_merged[[@varname(s), @varname(m), @varname(x[2])]]
3-element Vector{Float64}:
 1.0
 2.0
 4.0

julia&gt; # Merge the two with the original.
       varinfo_merged = merge(varinfo, varinfo_subset_merged);

julia&gt; keys(varinfo_merged)
4-element Vector{VarName}:
 s
 m
 x[1]
 x[2]

julia&gt; varinfo_merged[[@varname(s), @varname(m), @varname(x[1]), @varname(x[2])]]
4-element Vector{Float64}:
 1.0
 2.0
 3.0
 4.0</code></pre><p><strong>Notes</strong></p><p><strong>Type-stability</strong></p><div class="admonition is-warning" id="Warning-e04926b4e982050c"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-e04926b4e982050c" title="Permalink"></a></header><div class="admonition-body"><p>This function is only type-stable when <code>vns</code> contains only varnames with the same symbol. For exmaple, <code>[@varname(m[1]), @varname(m[2])]</code> will be type-stable, but <code>[@varname(m[1]), @varname(x)]</code> will not be.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L638-L747">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.unflatten"><a class="docstring-binding" href="#DynamicPPL.unflatten"><code>DynamicPPL.unflatten</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unflatten(vi::AbstractVarInfo, x::AbstractVector)</code></pre><p>Return a new instance of <code>vi</code> with the values of <code>x</code> assigned to the variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/abstract_varinfo.jl#L1011-L1015">source</a></section></details></article><h3 id="Evaluation-Contexts"><a class="docs-heading-anchor" href="#Evaluation-Contexts">Evaluation Contexts</a><a id="Evaluation-Contexts-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Contexts" title="Permalink"></a></h3><p>Internally, model evaluation is performed with <a href="#AbstractPPL.evaluate!!"><code>AbstractPPL.evaluate!!</code></a>.</p><article><details class="docstring" open="true"><summary id="AbstractPPL.evaluate!!"><a class="docstring-binding" href="#AbstractPPL.evaluate!!"><code>AbstractPPL.evaluate!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">evaluate!!(model::Model, varinfo)</code></pre><p>Evaluate the <code>model</code> with the given <code>varinfo</code>.</p><p>If multiple threads are available, the varinfo provided will be wrapped in a <code>ThreadSafeVarInfo</code> before evaluation.</p><p>Returns a tuple of the model&#39;s return value, plus the updated <code>varinfo</code> (unwrapped if necessary).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L910-L920">source</a></section></details></article><p>This method mutates the <code>varinfo</code> used for execution. By default, it does not perform any actual sampling: it only evaluates the model using the values of the variables that are already in the <code>varinfo</code>. If you wish to sample new values, see the section on <a href="#VarInfo-initialisation">VarInfo initialisation</a> just below this.</p><p>The behaviour of a model execution can be changed with evaluation contexts, which are a field of the model. Contexts are subtypes of <code>AbstractPPL.AbstractContext</code>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.DefaultContext"><a class="docstring-binding" href="#DynamicPPL.DefaultContext"><code>DynamicPPL.DefaultContext</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DefaultContext &lt;: AbstractContext end</code></pre><p><code>DefaultContext</code>, as the name suggests, is the default context used when instantiating a model.</p><pre><code class="language-julia-repl hljs">julia&gt; @model f() = x ~ Normal();

julia&gt; model = f(); model.context
DefaultContext()</code></pre><p>As an evaluation context, the behaviour of <code>DefaultContext</code> is to require all variables to be present in the <code>AbstractVarInfo</code> used for evaluation. Thus, semantically, evaluating a model with <code>DefaultContext</code> means &#39;calculating the log-probability associated with the variables in the <code>AbstractVarInfo</code>&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/default.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.PrefixContext"><a class="docstring-binding" href="#DynamicPPL.PrefixContext"><code>DynamicPPL.PrefixContext</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PrefixContext(vn::VarName[, context::AbstractContext])
PrefixContext(vn::Val{sym}[, context::AbstractContext]) where {sym}</code></pre><p>Create a context that allows you to use the wrapped <code>context</code> when running the model and prefixes all parameters with the VarName <code>vn</code>.</p><p><code>PrefixContext(Val(:a), context)</code> is equivalent to <code>PrefixContext(@varname(a), context)</code>. If <code>context</code> is not provided, it defaults to <code>DefaultContext()</code>.</p><p>This context is useful in nested models to ensure that the names of the parameters are unique.</p><p>See also: <a href="#DynamicPPL.to_submodel"><code>to_submodel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/prefix.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.ConditionContext"><a class="docstring-binding" href="#DynamicPPL.ConditionContext"><code>DynamicPPL.ConditionContext</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConditionContext{Values&lt;:Union{NamedTuple,AbstractDict},Ctx&lt;:AbstractContext}</code></pre><p>Model context that contains values that are to be conditioned on. The values can either be a NamedTuple mapping symbols to values, such as <code>(a=1, b=2)</code>, or an AbstractDict mapping varnames to values (e.g. <code>Dict(@varname(a) =&gt; 1, @varname(b) =&gt; 2)</code>). The former is more performant, but the latter must be used when there are varnames that cannot be represented as symbols, e.g. <code>@varname(x[1])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/conditionfix.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.InitContext"><a class="docstring-binding" href="#DynamicPPL.InitContext"><code>DynamicPPL.InitContext</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InitContext(
        [rng::Random.AbstractRNG=Random.default_rng()],
        [strategy::AbstractInitStrategy=InitFromPrior()],
)</code></pre><p>A leaf context that indicates that new values for random variables are currently being obtained through sampling. Used e.g. when initialising a fresh VarInfo. Note that, if <code>leafcontext(model.context) isa InitContext</code>, then <code>evaluate!!(model, varinfo)</code> will override all values in the VarInfo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/init.jl#L130-L140">source</a></section></details></article><h3 id="VarInfo-initialisation"><a class="docs-heading-anchor" href="#VarInfo-initialisation">VarInfo initialisation</a><a id="VarInfo-initialisation-1"></a><a class="docs-heading-anchor-permalink" href="#VarInfo-initialisation" title="Permalink"></a></h3><p>The function <code>init!!</code> is used to initialise, or overwrite, values in a VarInfo. It is really a thin wrapper around using <code>evaluate!!</code> with an <code>InitContext</code>.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.init!!"><a class="docstring-binding" href="#DynamicPPL.init!!"><code>DynamicPPL.init!!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">init!!(
    [rng::Random.AbstractRNG,]
    model::Model,
    varinfo::AbstractVarInfo,
    [init_strategy::AbstractInitStrategy=InitFromPrior()]
)</code></pre><p>Evaluate the <code>model</code> and replace the values of the model&#39;s random variables in the given <code>varinfo</code> with new values, using a specified initialisation strategy. If the values in <code>varinfo</code> are not set, they will be added using a specified initialisation strategy.</p><p>If <code>init_strategy</code> is not provided, defaults to <code>InitFromPrior()</code>.</p><p>Returns a tuple of the model&#39;s return value, plus the updated <code>varinfo</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/model.jl#L876-L892">source</a></section></details></article><p>To accomplish this, an initialisation <em>strategy</em> is required, which defines how new values are to be obtained. There are three concrete strategies provided in DynamicPPL:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.InitFromPrior"><a class="docstring-binding" href="#DynamicPPL.InitFromPrior"><code>DynamicPPL.InitFromPrior</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InitFromPrior()</code></pre><p>Obtain new values by sampling from the prior distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/init.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.InitFromUniform"><a class="docstring-binding" href="#DynamicPPL.InitFromUniform"><code>DynamicPPL.InitFromUniform</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InitFromUniform()
InitFromUniform(lower, upper)</code></pre><p>Obtain new values by first transforming the distribution of the random variable to unconstrained space, then sampling a value uniformly between <code>lower</code> and <code>upper</code>, and transforming that value back to the original space.</p><p>If <code>lower</code> and <code>upper</code> are unspecified, they default to <code>(-2, 2)</code>, which mimics Stan&#39;s default initialisation strategy.</p><p>Requires that <code>lower &lt;= upper</code>.</p><p><strong>References</strong></p><p><a href="https://mc-stan.org/docs/reference-manual/execution.html#initialization">Stan reference manual page on initialization</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/init.jl#L35-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.InitFromParams"><a class="docstring-binding" href="#DynamicPPL.InitFromParams"><code>DynamicPPL.InitFromParams</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InitFromParams(
    params::Union{AbstractDict{&lt;:VarName},NamedTuple},
    fallback::Union{AbstractInitStrategy,Nothing}=InitFromPrior()
)</code></pre><p>Obtain new values by extracting them from the given dictionary or NamedTuple.</p><p>The parameter <code>fallback</code> specifies how new values are to be obtained if they cannot be found in <code>params</code>, or they are specified as <code>missing</code>. <code>fallback</code> can either be an initialisation strategy itself, in which case it will be used to obtain new values, or it can be <code>nothing</code>, in which case an error will be thrown. The default for <code>fallback</code> is <code>InitFromPrior()</code>.</p><div class="admonition is-info" id="Note-f5a766101b1755be"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f5a766101b1755be" title="Permalink"></a></header><div class="admonition-body"><p>The values in <code>params</code> must be provided in the space of the untransformed distribution.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/init.jl#L75-L92">source</a></section></details></article><p>If you wish to write your own, you have to subtype <a href="#DynamicPPL.AbstractInitStrategy"><code>DynamicPPL.AbstractInitStrategy</code></a> and implement the <code>init</code> method.</p><article><details class="docstring" open="true"><summary id="DynamicPPL.AbstractInitStrategy"><a class="docstring-binding" href="#DynamicPPL.AbstractInitStrategy"><code>DynamicPPL.AbstractInitStrategy</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractInitStrategy</code></pre><p>Abstract type representing the possible ways of initialising new values for the random variables in a model (e.g., when creating a new VarInfo).</p><p>Any subtype of <code>AbstractInitStrategy</code> must implement the <a href="#DynamicPPL.init"><code>DynamicPPL.init</code></a> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/init.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.init"><a class="docstring-binding" href="#DynamicPPL.init"><code>DynamicPPL.init</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">init(rng::Random.AbstractRNG, vn::VarName, dist::Distribution, strategy::AbstractInitStrategy)</code></pre><p>Generate a new value for a random variable with the given distribution.</p><div class="admonition is-warning" id="Return-values-must-be-unlinked-8fd2ca658570f59e"><header class="admonition-header">Return values must be unlinked<a class="admonition-anchor" href="#Return-values-must-be-unlinked-8fd2ca658570f59e" title="Permalink"></a></header><div class="admonition-body"><p>The values returned by <code>init</code> must always be in the untransformed space, i.e., they must be within the support of the original distribution. That means that, for example, <code>init(rng, dist, u::InitFromUniform)</code> will in general return values that are outside the range [u.lower, u.upper].</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/contexts/init.jl#L12-L22">source</a></section></details></article><h3 id="Choosing-a-suitable-VarInfo"><a class="docs-heading-anchor" href="#Choosing-a-suitable-VarInfo">Choosing a suitable VarInfo</a><a id="Choosing-a-suitable-VarInfo-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-a-suitable-VarInfo" title="Permalink"></a></h3><p>There is also the <em>experimental</em> <a href="#DynamicPPL.Experimental.determine_suitable_varinfo"><code>DynamicPPL.Experimental.determine_suitable_varinfo</code></a>, which uses static checking via <a href="https://github.com/aviatesk/JET.jl">JET.jl</a> to determine whether one should use <a href="#DynamicPPL.typed_varinfo"><code>DynamicPPL.typed_varinfo</code></a> or <a href="#DynamicPPL.untyped_varinfo"><code>DynamicPPL.untyped_varinfo</code></a>, depending on which supports the model:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.Experimental.determine_suitable_varinfo"><a class="docstring-binding" href="#DynamicPPL.Experimental.determine_suitable_varinfo"><code>DynamicPPL.Experimental.determine_suitable_varinfo</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">determine_suitable_varinfo(model; only_dppl::Bool=true)</code></pre><p>Return a suitable varinfo for the given <code>model</code>.</p><p>See also: <a href="#DynamicPPL.Experimental.is_suitable_varinfo"><code>DynamicPPL.Experimental.is_suitable_varinfo</code></a>.</p><div class="admonition is-warning" id="Warning-fbe199b3a1ed3e3a"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-fbe199b3a1ed3e3a" title="Permalink"></a></header><div class="admonition-body"><p>For full functionality, this requires JET.jl to be loaded. If JET.jl is not loaded, this function will assume the model is compatible with typed varinfo.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>model</code>: The model for which to determine the varinfo.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>only_dppl</code>: If <code>true</code>, only consider error reports within DynamicPPL.jl.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL.Experimental: determine_suitable_varinfo

julia&gt; using JET: JET  # needs to be loaded for full functionality

julia&gt; @model function model_with_random_support()
           x ~ Bernoulli()
           if x
               y ~ Normal()
           else
               z ~ Normal()
           end
       end
model_with_random_support (generic function with 2 methods)

julia&gt; model = model_with_random_support();

julia&gt; # Typed varinfo cannot handle this random support model properly
       # as using a single execution of the model will not see all random variables.
       # Hence, this this model requires untyped varinfo.
       vi = determine_suitable_varinfo(model);
┌ Warning: Model seems incompatible with typed varinfo. Falling back to untyped varinfo.
└ @ DynamicPPLJETExt ~/.julia/dev/DynamicPPL.jl/ext/DynamicPPLJETExt.jl:48

julia&gt; vi isa typeof(DynamicPPL.untyped_varinfo(model))
true

julia&gt; # In contrast, a simple model with no random support can be handled by typed varinfo.
       @model model_with_static_support() = x ~ Normal()
model_with_static_support (generic function with 2 methods)

julia&gt; vi = determine_suitable_varinfo(model_with_static_support());

julia&gt; vi isa typeof(DynamicPPL.typed_varinfo(model_with_static_support()))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/experimental.jl#L30-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DynamicPPL.Experimental.is_suitable_varinfo"><a class="docstring-binding" href="#DynamicPPL.Experimental.is_suitable_varinfo"><code>DynamicPPL.Experimental.is_suitable_varinfo</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_suitable_varinfo(model::Model, varinfo::AbstractVarInfo; kwargs...)</code></pre><p>Check if the <code>model</code> supports evaluation using the provided <code>varinfo</code>.</p><div class="admonition is-warning" id="Warning-8ac7c31290310076"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-8ac7c31290310076" title="Permalink"></a></header><div class="admonition-body"><p>Loading JET.jl is required before calling this function.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>model</code>: The model to verify the support for.</li><li><code>varinfo</code>: The varinfo to verify the support for.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>only_dppl</code>: If <code>true</code>, only consider error reports occuring in the tilde pipeline. Default: <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>issuccess</code>: <code>true</code> if the model supports the varinfo, otherwise <code>false</code>.</li><li><code>report</code>: The result of <code>report_call</code> from JET.jl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/experimental.jl#L6-L24">source</a></section></details></article><h3 id="Converting-VarInfos-to/from-chains"><a class="docs-heading-anchor" href="#Converting-VarInfos-to/from-chains">Converting VarInfos to/from chains</a><a id="Converting-VarInfos-to/from-chains-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-VarInfos-to/from-chains" title="Permalink"></a></h3><p>It is a fairly common operation to want to convert a collection of <code>VarInfo</code> objects into a chains object for downstream analysis.</p><p>This can be accomplished by first converting each <code>VarInfo</code> into a <code>ParamsWithStats</code> object:</p><article><details class="docstring" open="true"><summary id="DynamicPPL.ParamsWithStats"><a class="docstring-binding" href="#DynamicPPL.ParamsWithStats"><code>DynamicPPL.ParamsWithStats</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ParamsWithStats</code></pre><p>A struct which contains parameter values extracted from a <code>VarInfo</code>, along with any statistics associated with the VarInfo. The statistics are provided as a NamedTuple and are optional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/src/chains.jl#L27-L33">source</a></section></details></article><p>Once you have a <strong>matrix</strong> of these, you can convert them into a chains object using:</p><article><details class="docstring" open="true"><summary id="AbstractMCMC.from_samples-Tuple{Type{Chains}, AbstractMatrix{&lt;:ParamsWithStats}}"><a class="docstring-binding" href="#AbstractMCMC.from_samples-Tuple{Type{Chains}, AbstractMatrix{&lt;:ParamsWithStats}}"><code>AbstractMCMC.from_samples</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AbstractMCMC.from_samples(
    ::Type{MCMCChains.Chains},
    params_and_stats::AbstractMatrix{&lt;:ParamsWithStats}
)</code></pre><p>Convert an array of <code>DynamicPPL.ParamsWithStats</code> to an <code>MCMCChains.Chains</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMCMCChainsExt.jl#L39-L46">source</a></section></details></article><p>If you only have a vector you can use <code>hcat</code> to convert it into an <code>N×1</code> matrix first.</p><p>Furthermore, one can convert chains back into a collection of parameter dictionaries and/or stats with:</p><article><details class="docstring" open="true"><summary id="AbstractMCMC.to_samples-Tuple{Type{ParamsWithStats}, Chains}"><a class="docstring-binding" href="#AbstractMCMC.to_samples-Tuple{Type{ParamsWithStats}, Chains}"><code>AbstractMCMC.to_samples</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AbstractMCMC.to_samples(
    ::Type{DynamicPPL.ParamsWithStats},
    chain::MCMCChains.Chains
)</code></pre><p>Convert an <code>MCMCChains.Chains</code> object to an array of <code>DynamicPPL.ParamsWithStats</code>.</p><p>For this to work, <code>chain</code> must contain the <code>varname_to_symbol</code> mapping in its <code>info</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/bd6bb8cba55e826f8e5f9b5f42ad8a974c4ad7cb/ext/DynamicPPLMCMCChainsExt.jl#L104-L113">source</a></section></details></article><p>With these, you can (for example) extract the parameter dictionaries and use <code>InitFromParams</code> to re-evaluate a model at each point in the chain.</p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 1 December 2025 13:28">Monday 1 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
