var documenterSearchIndex = {"docs":
[{"location":"test_utils/#DynamicPPL.TestUtils","page":"TestUtils","title":"DynamicPPL.TestUtils","text":"","category":"section"},{"location":"test_utils/","page":"TestUtils","title":"TestUtils","text":"Modules = [DynamicPPL.TestUtils]","category":"page"},{"location":"test_utils/#DynamicPPL.TestUtils.logjoint_true-Tuple{Model, Vararg{Any}}","page":"TestUtils","title":"DynamicPPL.TestUtils.logjoint_true","text":"logjoint_true(model, θ)\n\nReturn the logjoint of model for θ.\n\nDefaults to logprior_true(model, θ) + loglikelihood_true(model, θ).\n\nThis should generally be implemented by hand for every specific model so that the returned value can be used as a ground-truth for testing things like:\n\nValidity of evaluation of model using a particular implementation of AbstractVarInfo.\nValidity of a sampler when combined with DynamicPPL by running the sampler twice: once targeting ground-truth functions, e.g. logjoint_true, and once targeting model.\n\nAnd more.\n\nSee also: logprior_true, loglikelihood_true.\n\n\n\n\n\n","category":"method"},{"location":"test_utils/#DynamicPPL.TestUtils.loglikelihood_true","page":"TestUtils","title":"DynamicPPL.TestUtils.loglikelihood_true","text":"loglikelihood_true(model, θ)\n\nReturn the loglikelihood of model for θ.\n\nThis should generally be implemented by hand for every specific model.\n\nSee also: logjoint_true, logprior_true.\n\n\n\n\n\n","category":"function"},{"location":"test_utils/#DynamicPPL.TestUtils.logprior_true","page":"TestUtils","title":"DynamicPPL.TestUtils.logprior_true","text":"logprior_true(model, θ)\n\nReturn the logprior of model for θ.\n\nThis should generally be implemented by hand for every specific model.\n\nSee also: logjoint_true, loglikelihood_true.\n\n\n\n\n\n","category":"function"},{"location":"test_utils/#DynamicPPL.TestUtils.test_sampler_continuous-Tuple{Any, AbstractMCMC.AbstractSampler, Vararg{Any}}","page":"TestUtils","title":"DynamicPPL.TestUtils.test_sampler_continuous","text":"test_sampler_continuous([meanfunction, ]sampler, args...; kwargs...)\n\nTest that sampler produces the correct marginal posterior means on all models in demo_models.\n\nAs of right now, this is just an alias for test_sampler_demo_models.\n\n\n\n\n\n","category":"method"},{"location":"test_utils/#DynamicPPL.TestUtils.test_sampler_demo_models-Tuple{Any, AbstractMCMC.AbstractSampler, Vararg{Any}}","page":"TestUtils","title":"DynamicPPL.TestUtils.test_sampler_demo_models","text":"test_sampler_demo_models(meanfunction, sampler, args...; kwargs...)\n\nTest that sampler produces the correct marginal posterior means on all models in demo_models.\n\nIn short, this method iterators through demo_models, calls AbstractMCMC.sample on the model and sampler to produce a chain, and then checks meanfunction(chain) against target provided in kwargs....\n\nArguments\n\nmeanfunction: A callable which computes the mean of the marginal means from the chain resulting from the sample call.\nsampler: The AbstractMCMC.AbstractSampler to test.\nargs...: Arguments forwarded to sample.\n\nKeyword arguments\n\ntarget: Value to compare result of meanfunction(chain) to.\natol=1e-1: Absolute tolerance used in @test.\nrtol=1e-3: Relative tolerance used in @test.\nkwargs...: Keyword arguments forwarded to sample.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL","page":"Home","title":"DynamicPPL","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [DynamicPPL]","category":"page"},{"location":"#DynamicPPL.AbstractVarInfo","page":"Home","title":"DynamicPPL.AbstractVarInfo","text":"AbstractVarInfo\n\nAbstract supertype for data structures that capture random variables when executing a probabilistic model and accumulate log densities such as the log likelihood or the log joint probability of the model.\n\nSee also: VarInfo\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.DefaultContext","page":"Home","title":"DynamicPPL.DefaultContext","text":"struct DefaultContext <: AbstractContext end\n\nThe DefaultContext is used by default to compute log the joint probability of the data  and parameters when running the model.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.IsLeaf","page":"Home","title":"DynamicPPL.IsLeaf","text":"IsLeaf\n\nSpecifies that the context is a leaf in the context-tree.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.IsParent","page":"Home","title":"DynamicPPL.IsParent","text":"IsParent\n\nSpecifies that the context is a parent in the context-tree.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.LikelihoodContext","page":"Home","title":"DynamicPPL.LikelihoodContext","text":"struct LikelihoodContext{Tvars} <: AbstractContext\n    vars::Tvars\nend\n\nThe LikelihoodContext enables the computation of the log likelihood of the parameters when  running the model. vars can be used to evaluate the log likelihood for specific values  of the model's parameters. If vars is nothing, the parameter values inside the VarInfo will be used by default.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.Metadata","page":"Home","title":"DynamicPPL.Metadata","text":"The Metadata struct stores some metadata about the parameters of the model. This helps query certain information about a variable, such as its distribution, which samplers sample this variable, its value and whether this value is transformed to real space or not.\n\nLet md be an instance of Metadata:\n\nmd.vns is the vector of all VarName instances.\nmd.idcs is the dictionary that maps each VarName instance to its index in\n\nmd.vns, md.ranges md.dists, md.orders and md.flags.\n\nmd.vns[md.idcs[vn]] == vn.\nmd.dists[md.idcs[vn]] is the distribution of vn.\nmd.gids[md.idcs[vn]] is the set of algorithms used to sample vn. This is used in\n\nthe Gibbs sampling process.\n\nmd.orders[md.idcs[vn]] is the number of observe statements before vn is sampled.\nmd.ranges[md.idcs[vn]] is the index range of vn in md.vals.\nmd.vals[md.ranges[md.idcs[vn]]] is the vector of values of corresponding to vn.\nmd.flags is a dictionary of true/false flags. md.flags[flag][md.idcs[vn]] is the\n\nvalue of flag corresponding to vn.\n\nTo make md::Metadata type stable, all the md.vns must have the same symbol and distribution type. However, one can have a Julia variable, say x, that is a matrix or a hierarchical array sampled in partitions, e.g. x[1][:] ~ MvNormal(zeros(2), I); x[2][:] ~ MvNormal(ones(2), I), and is managed by a single md::Metadata so long as all the distributions on the RHS of ~ are of the same type. Type unstable Metadata will still work but will have inferior performance. When sampling, the first iteration uses a type unstable Metadata for all the variables then a specialized Metadata is used for each symbol along with a function barrier to make the rest of the sampling type stable.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.Metadata-Tuple{}","page":"Home","title":"DynamicPPL.Metadata","text":"Metadata()\n\nConstruct an empty type unstable instance of Metadata.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.MiniBatchContext","page":"Home","title":"DynamicPPL.MiniBatchContext","text":"struct MiniBatchContext{Tctx, T} <: AbstractContext\n    context::Tctx\n    loglike_scalar::T\nend\n\nThe MiniBatchContext enables the computation of  log(prior) + s * log(likelihood of a batch) when running the model, where s is the  loglike_scalar field, typically equal to the number of data points / batch size.  This is useful in batch-based stochastic gradient descent algorithms to be optimizing  log(prior) + log(likelihood of all the data points) in the expectation.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.Model","page":"Home","title":"DynamicPPL.Model","text":"struct Model{F,argnames,defaultnames,missings,Targs,Tdefaults}\n    name::Symbol\n    f::F\n    args::NamedTuple{argnames,Targs}\n    defaults::NamedTuple{defaultnames,Tdefaults}\nend\n\nA Model struct with model evaluation function of type F, arguments of names argnames types Targs, default arguments of names defaultnames with types Tdefaults, and missing arguments missings.\n\nHere argnames, defaultargnames, and missings are tuples of symbols, e.g. (:a, :b).\n\nAn argument with a type of Missing will be in missings by default. However, in non-traditional use-cases missings can be defined differently. All variables in missings are treated as random variables rather than observations.\n\nThe default arguments are used internally when constructing instances of the same model with different arguments.\n\nExamples\n\njulia> Model(f, (x = 1.0, y = 2.0))\nModel{typeof(f),(:x, :y),(),(),Tuple{Float64,Float64},Tuple{}}(f, (x = 1.0, y = 2.0), NamedTuple())\n\njulia> Model(f, (x = 1.0, y = 2.0), (x = 42,))\nModel{typeof(f),(:x, :y),(:x,),(),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))\n\njulia> Model{(:y,)}(f, (x = 1.0, y = 2.0), (x = 42,)) # with special definition of missings\nModel{typeof(f),(:x, :y),(:x,),(:y,),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.Model-Tuple","page":"Home","title":"DynamicPPL.Model","text":"(model::Model)([rng, varinfo, sampler, context])\n\nSample from the model using the sampler with random number generator rng and the context, and store the sample and log joint probability in varinfo.\n\nThe method resets the log joint probability of varinfo and increases the evaluation number of sampler.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.Model-Union{Tuple{Ctx}, Tuple{Tdefaults}, Tuple{defaultnames}, Tuple{Targs}, Tuple{argnames}, Tuple{F}, Tuple{missings}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple{defaultnames, Tdefaults}}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple{defaultnames, Tdefaults}, Ctx}} where {missings, F, argnames, Targs, defaultnames, Tdefaults, Ctx}","page":"Home","title":"DynamicPPL.Model","text":"Model{missings}(name::Symbol, f, args::NamedTuple, defaults::NamedTuple)\n\nCreate a model of name name with evaluation function f and missing arguments overwritten by missings.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.Model-Union{Tuple{Targs}, Tuple{argnames}, Tuple{F}, Tuple{Symbol, F, NamedTuple{argnames, Targs}}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple, DynamicPPL.AbstractContext}} where {F, argnames, Targs}","page":"Home","title":"DynamicPPL.Model","text":"Model(name::Symbol, f, args::NamedTuple[, defaults::NamedTuple = ()])\n\nCreate a model of name name with evaluation function f and missing arguments deduced from args.\n\nDefault arguments defaults are used internally when constructing instances of the same model with different arguments.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.NamedDist","page":"Home","title":"DynamicPPL.NamedDist","text":"A named distribution that carries the name of the random variable with it.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.NodeTrait","page":"Home","title":"DynamicPPL.NodeTrait","text":"NodeTrait(context)\nNodeTrait(f, context)\n\nSpecifies the role of context in the context-tree.\n\nThe officially supported traits are:\n\nIsLeaf: context does not have any decendants.\nIsParent: context has a child context to which we often defer. Expects the following methods to be implemented:\nchildcontext\nsetchildcontext\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.PrefixContext","page":"Home","title":"DynamicPPL.PrefixContext","text":"PrefixContext{Prefix}(context)\n\nCreate a context that allows you to use the wrapped context when running the model and adds the Prefix to all parameters.\n\nThis context is useful in nested models to ensure that the names of the parameters are unique.\n\nSee also: @submodel\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.PriorContext","page":"Home","title":"DynamicPPL.PriorContext","text":"struct PriorContext{Tvars} <: AbstractContext\n    vars::Tvars\nend\n\nThe PriorContext enables the computation of the log prior of the parameters vars when  running the model.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.SampleFromPrior","page":"Home","title":"DynamicPPL.SampleFromPrior","text":"SampleFromPrior\n\nSampling algorithm that samples unobserved random variables from their prior distribution.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.SampleFromUniform","page":"Home","title":"DynamicPPL.SampleFromUniform","text":"SampleFromUniform\n\nSampling algorithm that samples unobserved random variables from a uniform distribution.\n\nReferences\n\nStan reference manual\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.Sampler","page":"Home","title":"DynamicPPL.Sampler","text":"Sampler{T}\n\nGeneric sampler type for inference algorithms of type T in DynamicPPL.\n\nSampler should implement the AbstractMCMC interface, and in particular AbstractMCMC.step. A default implementation of the initial sampling step is provided that supports resuming sampling from a previous state and setting initial parameter values. It requires to overload loadstate and initialstep for loading previous states and actually performing the initial sampling step, respectively. Additionally, sometimes one might want to implement initialsampler that specifies how the initial parameter values are sampled if they are not provided. By default, values are sampled from the prior.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.SamplingContext","page":"Home","title":"DynamicPPL.SamplingContext","text":"SamplingContext(rng, sampler, context)\n\nCreate a context that allows you to sample parameters with the sampler when running the model. The context determines how the returned log density is computed when running the model.\n\nSee also: DefaultContext, LikelihoodContext, PriorContext\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.SimpleVarInfo","page":"Home","title":"DynamicPPL.SimpleVarInfo","text":"SimpleVarInfo{NT,T} <: AbstractVarInfo\n\nA simple wrapper of the parameters with a logp field for accumulation of the logdensity.\n\nCurrently only implemented for NT<:NamedTuple and NT<:Dict.\n\nNotes\n\nThe major differences between this and TypedVarInfo are:\n\nSimpleVarInfo does not require linearization.\nSimpleVarInfo can use more efficient bijectors.\nSimpleVarInfo is only type-stable if NT<:NamedTuple and either a) no indexing is used in tilde-statements, or b) the values have been specified with the correct shapes.\n\nExamples\n\nGeneral usage\n\njulia> using StableRNGs\n\njulia> @model function demo()\n           m ~ Normal()\n           x = Vector{Float64}(undef, 2)\n           for i in eachindex(x)\n               x[i] ~ Normal()\n           end\n           return x\n       end\ndemo (generic function with 2 methods)\n\njulia> m = demo();\n\njulia> rng = StableRNG(42);\n\njulia> ### Sampling ###\n       ctx = SamplingContext(rng, SampleFromPrior(), DefaultContext());\n\njulia> # In the `NamedTuple` version we need to provide the place-holder values for\n       # the variables which are using \"containers\", e.g. `Array`.\n       # In this case, this means that we need to specify `x` but not `m`.\n       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo((x = ones(2), )), ctx);\n\njulia> # (✓) Vroom, vroom! FAST!!!\n       vi[@varname(x[1])]\n0.4471218424633827\n\njulia> # We can also access arbitrary varnames pointing to `x`, e.g.\n       vi[@varname(x)]\n2-element Vector{Float64}:\n 0.4471218424633827\n 1.3736306979834252\n\njulia> vi[@varname(x[1:2])]\n2-element Vector{Float64}:\n 0.4471218424633827\n 1.3736306979834252\n\njulia> # (×) If we don't provide the container...\n       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo(), ctx); vi\nERROR: type NamedTuple has no field x\n[...]\n\njulia> # If one does not know the varnames, we can use a `Dict` instead.\n       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo{Float64}(Dict()), ctx);\n\njulia> # (✓) Sort of fast, but only possible at runtime.\n       vi[@varname(x[1])]\n-1.019202452456547\n\njulia> # In addtion, we can only access varnames as they appear in the model!\n       vi[@varname(x)]\nERROR: KeyError: key x not found\n[...]\n\njulia> vi[@varname(x[1:2])]\nERROR: KeyError: key x[1:2] not found\n[...]\n\nIndexing\n\nUsing NamedTuple as underlying storage.\n\njulia> svi_nt = SimpleVarInfo((m = (a = [1.0], ), ));\n\njulia> svi_nt[@varname(m)]\n(a = [1.0],)\n\njulia> svi_nt[@varname(m.a)]\n1-element Vector{Float64}:\n 1.0\n\njulia> svi_nt[@varname(m.a[1])]\n1.0\n\njulia> svi_nt[@varname(m.a[2])]\nERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]\n[...]\n\njulia> svi_nt[@varname(m.b)]\nERROR: type NamedTuple has no field b\n[...]\n\nUsing Dict as underlying storage.\n\njulia> svi_dict = SimpleVarInfo(Dict(@varname(m) => (a = [1.0], )));\n\njulia> svi_dict[@varname(m)]\n(a = [1.0],)\n\njulia> svi_dict[@varname(m.a)]\n1-element Vector{Float64}:\n 1.0\n\njulia> svi_dict[@varname(m.a[1])]\n1.0\n\njulia> svi_dict[@varname(m.a[2])]\nERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]\n[...]\n\njulia> svi_dict[@varname(m.b)]\nERROR: type NamedTuple has no field b\n[...]\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.ThreadSafeVarInfo","page":"Home","title":"DynamicPPL.ThreadSafeVarInfo","text":"ThreadSafeVarInfo\n\nA ThreadSafeVarInfo object wraps an AbstractVarInfo object and an array of log probabilities for thread-safe execution of a probabilistic model.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicPPL.TypedVarInfo-Tuple{UntypedVarInfo}","page":"Home","title":"DynamicPPL.TypedVarInfo","text":"TypedVarInfo(vi::UntypedVarInfo)\n\nThis function finds all the unique syms from the instances of VarName{sym} found in vi.metadata.vns. It then extracts the metadata associated with each symbol from the global vi.metadata field. Finally, a new VarInfo is created with a new metadata as a NamedTuple mapping from symbols to type-stable Metadata instances, one for each symbol.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.VarInfo","page":"Home","title":"DynamicPPL.VarInfo","text":"struct VarInfo{Tmeta, Tlogp} <: AbstractVarInfo\n    metadata::Tmeta\n    logp::Base.RefValue{Tlogp}\n    num_produce::Base.RefValue{Int}\nend\n\nA light wrapper over one or more instances of Metadata. Let vi be an instance of VarInfo. If vi isa VarInfo{<:Metadata}, then only one Metadata instance is used for all the sybmols. VarInfo{<:Metadata} is aliased UntypedVarInfo. If vi isa VarInfo{<:NamedTuple}, then vi.metadata is a NamedTuple that maps each symbol used on the LHS of ~ in the model to its Metadata instance. The latter allows for the type specialization of vi after the first sampling iteration when all the symbols have been observed. VarInfo{<:NamedTuple} is aliased TypedVarInfo.\n\nNote: It is the user's responsibility to ensure that each \"symbol\" is visited at least once whenever the model is called, regardless of any stochastic branching. Each symbol refers to a Julia variable and can be a hierarchical array of many random variables, e.g. x[1] ~ ... and x[2] ~ ... both have the same symbol x.\n\n\n\n\n\n","category":"type"},{"location":"#AbstractPPL.condition-Tuple{Model}","page":"Home","title":"AbstractPPL.condition","text":"condition(model::Model; values...)\ncondition(model::Model, values::NamedTuple)\n\nReturn a Model which now treats the variables in values as observations.\n\nSee also: decondition, conditioned\n\nLimitations\n\nThis does currently not work with variables that are provided to the model as arguments, e.g. @model function demo(x) ... end means that condition will not affect the variable x.\n\nTherefore if one wants to make use of condition and decondition one should not be specifying any random variables as arguments.\n\nThis is done for the sake of backwards compatibility.\n\nExamples\n\nSimple univariate model\n\njulia> using Distributions; using StableRNGs; rng = StableRNG(42); # For reproducibility.\n\njulia> @model function demo()\n           m ~ Normal()\n           x ~ Normal(m, 1)\n           return (; m=m, x=x)\n       end\ndemo (generic function with 2 methods)\n\njulia> model = demo();\n\njulia> model(rng)\n(m = -0.6702516921145671, x = -0.22312984965118443)\n\njulia> # Create a new instance which treats `x` as observed\n       # with value `100.0`, and similarly for `m=1.0`.\n       conditioned_model = condition(model, x=100.0, m=1.0);\n\njulia> conditioned_model(rng)\n(m = 1.0, x = 100.0)\n\njulia> # Let's only condition on `x = 100.0`.\n       conditioned_model = condition(model, x = 100.0);\n\njulia> conditioned_model(rng)\n(m = 1.3736306979834252, x = 100.0)\n\njulia> # We can also use the nicer `|` syntax.\n       conditioned_model = model | (x = 100.0, );\n\njulia> conditioned_model(rng)\n(m = 1.3095394956381083, x = 100.0)\n\nCondition only a part of a multivariate variable\n\nNot only can be condition on multivariate random variables, but we can also use the standard mechanism of setting something to missing in the call to condition to only condition on a part of the variable.\n\njulia> @model function demo_mv(::Type{TV}=Float64) where {TV}\n           m = Vector{TV}(undef, 2)\n           m[1] ~ Normal()\n           m[2] ~ Normal()\n           return m\n       end\ndemo_mv (generic function with 3 methods)\n\njulia> model = demo_mv();\n\njulia> conditioned_model = condition(model, m = [missing, 1.0]);\n\njulia> conditioned_model(rng) # (✓) `m[1]` sampled, `m[2]` is fixed\n2-element Vector{Float64}:\n 0.12607002180931043\n 1.0\n\nIntuitively one might also expect to be able to write model | (x[1] = 1.0, ). Unfortunately this is not supported due to performance.\n\njulia> condition(model, var\"x[2]\" = 1.0)(rng) # (×) `x[2]` is not set to 1.0.\n2-element Vector{Float64}:\n  0.683947930996541\n -1.019202452456547\n\nWe will likely provide some syntactic sugar for this in the future.\n\nNested models\n\ncondition of course also supports the use of nested models through the use of @submodel.\n\njulia> @model demo_inner() = m ~ Normal()\ndemo_inner (generic function with 2 methods)\n\njulia> @model function demo_outer()\n           @submodel m = demo_inner()\n           return m\n       end\ndemo_outer (generic function with 2 methods)\n\njulia> model = demo_outer();\n\njulia> model(rng)\n-0.7935128416361353\n\njulia> conditioned_model = model | (m = 1.0, );\n\njulia> conditioned_model(rng)\n1.0\n\nBut one needs to be careful when prefixing variables in the nested models:\n\njulia> @model function demo_outer_prefix()\n           @submodel prefix=\"inner\" m = demo_inner()\n           return m\n       end\ndemo_outer_prefix (generic function with 2 methods)\n\njulia> # This doesn't work now!\n       conditioned_model = demo_outer_prefix() | (m = 1.0, );\n\njulia> conditioned_model(rng)\n1.7747246334368165\n\njulia> # `m` in `demo_inner` is referred to as `inner.m` internally, so we do:\n       conditioned_model = demo_outer_prefix() | (var\"inner.m\" = 1.0, );\n\njulia> conditioned_model(rng)\n1.0\n\njulia> # Note that the above `var\"...\"` is just standard Julia syntax:\n       keys((var\"inner.m\" = 1.0, ))\n(Symbol(\"inner.m\"),)\n\nThe difference is maybe more obvious once we look at how these different in their trace/VarInfo:\n\njulia> keys(VarInfo(demo_outer()))\n1-element Vector{VarName{:m, Tuple{}}}:\n m\n\njulia> keys(VarInfo(demo_outer_prefix()))\n1-element Vector{VarName{Symbol(\"inner.m\"), Tuple{}}}:\n inner.m\n\nFrom this we can tell what the correct way to condition m within demo_inner is in the two different models.\n\n\n\n\n\n","category":"method"},{"location":"#AbstractPPL.condition-Tuple{}","page":"Home","title":"AbstractPPL.condition","text":"condition([context::AbstractContext,] values::NamedTuple)\ncondition([context::AbstractContext]; values...)\n\nReturn ConditionContext with values and context if values is non-empty, otherwise return context which is DefaultContext by default.\n\nSee also: decondition\n\n\n\n\n\n","category":"method"},{"location":"#AbstractPPL.decondition-Tuple{DynamicPPL.IsLeaf, Any, Vararg{Any}}","page":"Home","title":"AbstractPPL.decondition","text":"decondition(context::AbstractContext, syms...)\n\nReturn context but with syms no longer conditioned on.\n\nNote that this recursively traverses contexts, deconditioning all along the way.\n\nSee also: condition\n\n\n\n\n\n","category":"method"},{"location":"#AbstractPPL.decondition-Tuple{Model, Vararg{Any}}","page":"Home","title":"AbstractPPL.decondition","text":"decondition(model::Model)\ndecondition(model::Model, syms...)\n\nReturn a Model for which syms... are not considered observations. If no syms are provided, then all variables currently considered observations will no longer be.\n\nThis is essentially the inverse of condition. This also means that it suffers from the same limitiations.\n\nExamples\n\njulia> using Distributions; using StableRNGs; rng = StableRNG(42); # For reproducibility.\n\njulia> @model function demo()\n           m ~ Normal()\n           x ~ Normal(m, 1)\n           return (; m=m, x=x)\n       end\ndemo (generic function with 2 methods)\n\njulia> conditioned_model = condition(demo(), m = 1.0, x = 10.0);\n\njulia> conditioned_model(rng)\n(m = 1.0, x = 10.0)\n\njulia> model = decondition(conditioned_model, :m);\n\njulia> model(rng)\n(m = -0.6702516921145671, x = 10.0)\n\njulia> # `decondition` multiple at once:\n       decondition(model, :m, :x)(rng)\n(m = 0.4471218424633827, x = 1.820752540446808)\n\njulia> # `decondition` without any symbols will `decondition` all variables.\n       decondition(model)(rng)\n(m = 1.3095394956381083, x = 1.4356095174474188)\n\njulia> # Usage of `Val` to perform `decondition` at compile-time if possible\n       # is also supported.\n       model = decondition(conditioned_model, Val{:m}());\n\njulia> model(rng)\n(m = 0.683947930996541, x = 10.0)\n\n\n\n\n\n","category":"method"},{"location":"#BangBang.empty!!-Tuple{VarInfo}","page":"Home","title":"BangBang.empty!!","text":"empty!!(vi::VarInfo)\n\nEmpty the fields of vi.metadata and reset vi.logp[] and vi.num_produce[] to zeros.\n\nThis is useful when using a sampling algorithm that assumes an empty vi, e.g. SMC.\n\n\n\n\n\n","category":"method"},{"location":"#BangBang.push!!-Tuple{AbstractVarInfo, VarName, Any, Distributions.Distribution, DynamicPPL.Selector}","page":"Home","title":"BangBang.push!!","text":"push!!(vi::VarInfo, vn::VarName, r, dist::Distribution, gid::Selector)\n\nPush a new random variable vn with a sampled value r sampled with a sampler of selector gid from a distribution dist to VarInfo vi.\n\n\n\n\n\n","category":"method"},{"location":"#BangBang.push!!-Tuple{AbstractVarInfo, VarName, Any, Distributions.Distribution, Sampler}","page":"Home","title":"BangBang.push!!","text":"push!!(vi::VarInfo, vn::VarName, r, dist::Distribution, spl::AbstractSampler)\n\nPush a new random variable vn with a sampled value r sampled with a sampler spl from a distribution dist to VarInfo vi, if it makes sense.\n\nThe sampler is passed here to invalidate its cache where defined.\n\n\n\n\n\n","category":"method"},{"location":"#BangBang.push!!-Tuple{AbstractVarInfo, VarName, Any, Distributions.Distribution}","page":"Home","title":"BangBang.push!!","text":"push!!(vi::VarInfo, vn::VarName, r, dist::Distribution)\n\nPush a new random variable vn with a sampled value r from a distribution dist to the VarInfo vi, mutating if it makes sense.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:|-Tuple{Model, Any}","page":"Home","title":"Base.:|","text":"model | (x = 1.0, ...)\n\nReturn a Model which now treats variables on the right-hand side as observations.\n\nSee condition for more information and examples.\n\n\n\n\n\n","category":"method"},{"location":"#Base.empty!-Tuple{DynamicPPL.Metadata}","page":"Home","title":"Base.empty!","text":"empty!(meta::Metadata)\n\nEmpty the fields of meta.\n\nThis is useful when using a sampling algorithm that assumes an empty meta, e.g. SMC.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{AbstractVarInfo, SampleFromPrior}","page":"Home","title":"Base.getindex","text":"getindex(vi::VarInfo, spl::Union{SampleFromPrior, Sampler})\n\nReturn the current value(s) of the random variables sampled by spl in vi.\n\nThe value(s) may or may not be transformed to Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{AbstractVarInfo, VarName}","page":"Home","title":"Base.getindex","text":"getindex(vi::VarInfo, vn::VarName)\ngetindex(vi::VarInfo, vns::Vector{<:VarName})\n\nReturn the current value(s) of vn (vns) in vi in the support of its (their) distribution(s).\n\nIf the value(s) is (are) transformed to the Euclidean space, it is (they are) transformed back.\n\n\n\n\n\n","category":"method"},{"location":"#Base.haskey-Tuple{VarInfo, VarName}","page":"Home","title":"Base.haskey","text":"haskey(vi::VarInfo, vn::VarName)\n\nCheck whether vn has been sampled in vi.\n\n\n\n\n\n","category":"method"},{"location":"#Base.isempty-Tuple{UntypedVarInfo}","page":"Home","title":"Base.isempty","text":"isempty(vi::VarInfo)\n\nReturn true if vi is empty and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#Base.keys-Tuple{SimpleVarInfo}","page":"Home","title":"Base.keys","text":"keys(vi::SimpleVarInfo)\n\nReturn an iterator of keys present in vi.\n\n\n\n\n\n","category":"method"},{"location":"#Base.keys-Tuple{UntypedVarInfo}","page":"Home","title":"Base.keys","text":"keys(vi::AbstractVarInfo)\n\nReturn an iterator over all vns in vi.\n\n\n\n\n\n","category":"method"},{"location":"#Base.nameof-Tuple{Model}","page":"Home","title":"Base.nameof","text":"nameof(model::Model)\n\nGet the name of the model as Symbol.\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex!-Tuple{AbstractVarInfo, Any, SampleFromPrior}","page":"Home","title":"Base.setindex!","text":"setindex!(vi::VarInfo, val, spl::Union{SampleFromPrior, Sampler})\n\nSet the current value(s) of the random variables sampled by spl in vi to val.\n\nThe value(s) may or may not be transformed to Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex!-Tuple{AbstractVarInfo, Any, VarName}","page":"Home","title":"Base.setindex!","text":"setindex!(vi::VarInfo, val, vn::VarName)\n\nSet the current value(s) of the random variable vn in vi to val.\n\nThe value(s) may or may not be transformed to Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL._apply!-Tuple{Any, AbstractVarInfo, Any, Any}","page":"Home","title":"DynamicPPL._apply!","text":"_apply!(kernel!, vi::AbstractVarInfo, values, keys)\n\nCalls kernel!(vi, vn, values, keys) for every vn in vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL._evaluate!!-Union{Tuple{argnames}, Tuple{_F}, Tuple{Model{_F, argnames}, Any, Any}} where {_F, argnames}","page":"Home","title":"DynamicPPL._evaluate!!","text":"_evaluate!!(model::Model, varinfo, context)\n\nEvaluate the model with the arguments matching the given context and varinfo object.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.acclogp!!-Tuple{VarInfo, Any}","page":"Home","title":"DynamicPPL.acclogp!!","text":"acclogp!!(vi::VarInfo, logp)\n\nAdd logp to the value of the log of the joint probability of the observed data and parameters sampled in vi, mutating if it makes sense.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.build_model_info-Tuple{Any}","page":"Home","title":"DynamicPPL.build_model_info","text":"build_model_info(input_expr)\n\nBuilds the model_info dictionary from the model's expression.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.build_output-Tuple{Any, Any}","page":"Home","title":"DynamicPPL.build_output","text":"build_output(modelinfo, linenumbernode)\n\nBuilds the output expression.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.canview-Tuple{Any, Any}","page":"Home","title":"DynamicPPL.canview","text":"canview(lens, container)\n\nReturn true if lens can be used to view container, and false otherwise.\n\nExamples\n\njulia> canview(@lens(_.a), (a = 1.0, ))\ntrue\n\njulia> canview(@lens(_.a), (b = 1.0, )) # property `a` does not exist\nfalse\n\njulia> canview(@lens(_.a[1]), (a = [1.0, 2.0], ))\ntrue\n\njulia> canview(@lens(_.a[3]), (a = [1.0, 2.0], )) # out of bounds\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.check_tilde_rhs-Tuple{Any}","page":"Home","title":"DynamicPPL.check_tilde_rhs","text":"check_tilde_rhs(x)\n\nCheck if the right-hand side x of a ~ is a Distribution or an array of Distributions, then return x.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.childcontext","page":"Home","title":"DynamicPPL.childcontext","text":"childcontext(context)\n\nReturn the descendant context of context.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicPPL.conditioned-Tuple{DynamicPPL.AbstractContext}","page":"Home","title":"DynamicPPL.conditioned","text":"conditioned(context::AbstractContext)\n\nReturn NamedTuple of values that are conditioned on under context`.\n\nNote that this will recursively traverse the context stack and return a merged version of the condition values.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.conditioned-Tuple{Model}","page":"Home","title":"DynamicPPL.conditioned","text":"conditioned(model::Model)\n\nReturn NamedTuple of values that are conditioned on under model.\n\nExamples\n\njulia> using Distributions\n\njulia> using DynamicPPL: conditioned, contextualize\n\njulia> @model function demo()\n           m ~ Normal()\n           x ~ Normal(m, 1)\n       end\ndemo (generic function with 2 methods)\n\njulia> m = demo();\n\njulia> # Returns all the variables we have conditioned on + their values.\n       conditioned(condition(m, x=100.0, m=1.0))\n(x = 100.0, m = 1.0)\n\njulia> # Nested ones also work (note that `PrefixContext` does nothing to the result).\n       cm = condition(contextualize(m, PrefixContext{:a}(condition(m=1.0))), x=100.0);\n\njulia> conditioned(cm)\n(x = 100.0, m = 1.0)\n\njulia> # Since we conditioned on `m`, not `a.m` as it will appear after prefixed,\n       # `a.m` is treated as a random variable.\n       keys(VarInfo(cm))\n1-element Vector{VarName{Symbol(\"a.m\"), Tuple{}}}:\n a.m\n\njulia> # If we instead condition on `a.m`, `m` in the model will be considered an observation.\n       cm = condition(contextualize(m, PrefixContext{:a}(condition(var\"a.m\"=1.0))), x=100.0);\n\njulia> conditioned(cm)\n(x = 100.0, a.m = 1.0)\n\njulia> keys(VarInfo(cm)) # <= no variables are sampled\nAny[]\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.contextual_isassumption-Tuple{DynamicPPL.IsLeaf, Any, Any}","page":"Home","title":"DynamicPPL.contextual_isassumption","text":"contextual_isassumption(context, vn)\n\nReturn true if vn is considered an assumption by context.\n\nThe default implementation for AbstractContext always returns true.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.dot_tilde_assume!!-NTuple{5, Any}","page":"Home","title":"DynamicPPL.dot_tilde_assume!!","text":"dot_tilde_assume!!(context, right, left, vn, vi)\n\nHandle broadcasted assumed variables, e.g., x .~ MvNormal() (where x does not occur in the model inputs), accumulate the log probability, and return the sampled value and updated vi.\n\nFalls back to dot_tilde_assume(context, right, left, vn, vi).\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.dot_tilde_assume-Tuple{SamplingContext, Any, Any, Any, Any}","page":"Home","title":"DynamicPPL.dot_tilde_assume","text":"dot_tilde_assume(context::SamplingContext, right, left, vn, vi)\n\nHandle broadcasted assumed variables, e.g., x .~ MvNormal() (where x does not occur in the model inputs), accumulate the log probability, and return the sampled value for a context associated with a sampler.\n\nFalls back to\n\ndot_tilde_assume(context.rng, context.context, context.sampler, right, left, vn, vi)\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.dot_tilde_observe!!-NTuple{4, Any}","page":"Home","title":"DynamicPPL.dot_tilde_observe!!","text":"dot_tilde_observe!!(context, right, left, vi)\n\nHandle broadcasted observed constants, e.g., [1.0] .~ MvNormal(), accumulate the log probability, and return the observed value and updated vi.\n\nFalls back to dot_tilde_observe(context, right, left, vi).\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.dot_tilde_observe!!-NTuple{5, Any}","page":"Home","title":"DynamicPPL.dot_tilde_observe!!","text":"dot_tilde_observe!!(context, right, left, vname, vi)\n\nHandle broadcasted observed values, e.g., x .~ MvNormal() (where x does occur in the model inputs), accumulate the log probability, and return the observed value and updated vi.\n\nFalls back to dot_tilde_observe!!(context, right, left, vi) ignoring the information about variable name and indices; if needed, these can be accessed through this function, though.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.dot_tilde_observe-Tuple{SamplingContext, Any, Any, Any}","page":"Home","title":"DynamicPPL.dot_tilde_observe","text":"dot_tilde_observe(context::SamplingContext, right, left, vi)\n\nHandle broadcasted observed constants, e.g., [1.0] .~ MvNormal(), accumulate the log probability, and return the observed value for a context associated with a sampler.\n\nFalls back to dot_tilde_observe(context.context, context.sampler, right, left, vi).\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.evaluate!!-Tuple{Model, AbstractVarInfo, DynamicPPL.AbstractContext}","page":"Home","title":"DynamicPPL.evaluate!!","text":"evaluate!!(model::Model[, rng, varinfo, sampler, context])\n\nSample from the model using the sampler with random number generator rng and the context, and store the sample and log joint probability in varinfo.\n\nReturns both the return-value of the original model, and the resulting varinfo.\n\nThe method resets the log joint probability of varinfo and increases the evaluation number of sampler.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.evaluate_threadsafe!!-Tuple{Any, Any, Any}","page":"Home","title":"DynamicPPL.evaluate_threadsafe!!","text":"evaluate_threadsafe!!(model, varinfo, context)\n\nEvaluate the model with varinfo wrapped inside a ThreadSafeVarInfo.\n\nWith the wrapper, Julia's multithreading can be used for observe statements in the model but parallel sampling will lead to undefined behaviour. This method is not exposed and supposed to be used only internally in DynamicPPL.\n\nSee also: evaluate_threadunsafe!!\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.evaluate_threadunsafe!!-Tuple{Any, Any, Any}","page":"Home","title":"DynamicPPL.evaluate_threadunsafe!!","text":"evaluate_threadunsafe!!(model, varinfo, context)\n\nEvaluate the model without wrapping varinfo inside a ThreadSafeVarInfo.\n\nIf the model makes use of Julia's multithreading this will lead to undefined behaviour. This method is not exposed and supposed to be used only internally in DynamicPPL.\n\nSee also: evaluate_threadsafe!!\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.generate_dot_tilde-Tuple{Any, Any}","page":"Home","title":"DynamicPPL.generate_dot_tilde","text":"generate_dot_tilde(left, right)\n\nGenerate the expression that replaces left .~ right in the model body.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.generate_mainbody-Tuple{Any, Any, Any}","page":"Home","title":"DynamicPPL.generate_mainbody","text":"generate_mainbody(mod, expr, warn)\n\nGenerate the body of the main evaluation function from expression expr and arguments args.\n\nIf warn is true, a warning is displayed if internal variables are used in the model definition.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.generate_tilde-Tuple{Any, Any}","page":"Home","title":"DynamicPPL.generate_tilde","text":"generate_tilde(left, right)\n\nGenerate an observe expression for data variables and assume expression for parameter variables.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.generated_quantities-Tuple{Model, AbstractMCMC.AbstractChains}","page":"Home","title":"DynamicPPL.generated_quantities","text":"generated_quantities(model::Model, chain::AbstractChains)\n\nExecute model for each of the samples in chain and return an array of the values returned by the model for each sample.\n\nExamples\n\nGeneral\n\nOften you might have additional quantities computed inside the model that you want to inspect, e.g.\n\n@model function demo(x)\n    # sample and observe\n    θ ~ Prior()\n    x ~ Likelihood()\n    return interesting_quantity(θ, x)\nend\nm = demo(data)\nchain = sample(m, alg, n)\n# To inspect the `interesting_quantity(θ, x)` where `θ` is replaced by samples\n# from the posterior/`chain`:\ngenerated_quantities(m, chain) # <= results in a `Vector` of returned values\n                               #    from `interesting_quantity(θ, x)`\n\nConcrete (and simple)\n\njulia> using DynamicPPL, Turing\n\njulia> @model function demo(xs)\n           s ~ InverseGamma(2, 3)\n           m_shifted ~ Normal(10, √s)\n           m = m_shifted - 10\n\n           for i in eachindex(xs)\n               xs[i] ~ Normal(m, √s)\n           end\n\n           return (m, )\n       end\ndemo (generic function with 1 method)\n\njulia> model = demo(randn(10));\n\njulia> chain = sample(model, MH(), 10);\n\njulia> generated_quantities(model, chain)\n10×1 Array{Tuple{Float64},2}:\n (2.1964758025119338,)\n (2.1964758025119338,)\n (0.09270081916291417,)\n (0.09270081916291417,)\n (0.09270081916291417,)\n (0.09270081916291417,)\n (0.09270081916291417,)\n (0.043088571494005024,)\n (-0.16489786710222099,)\n (-0.16489786710222099,)\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.generated_quantities-Tuple{Model, NamedTuple}","page":"Home","title":"DynamicPPL.generated_quantities","text":"generated_quantities(model::Model, parameters::NamedTuple)\ngenerated_quantities(model::Model, values, keys)\ngenerated_quantities(model::Model, values, keys)\n\nExecute model with variables keys set to values and return the values returned by the model.\n\nIf a NamedTuple is given, keys=keys(parameters) and values=values(parameters).\n\nExample\n\njulia> using DynamicPPL, Distributions\n\njulia> @model function demo(xs)\n           s ~ InverseGamma(2, 3)\n           m_shifted ~ Normal(10, √s)\n           m = m_shifted - 10\n           for i in eachindex(xs)\n               xs[i] ~ Normal(m, √s)\n           end\n           return (m, )\n       end\ndemo (generic function with 2 methods)\n\njulia> model = demo(randn(10));\n\njulia> parameters = (; s = 1.0, m_shifted=10);\n\njulia> generated_quantities(model, parameters)\n(0.0,)\n\njulia> generated_quantities(model, values(parameters), keys(parameters))\n(0.0,)\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.get_matching_type-Union{Tuple{T}, Tuple{AbstractMCMC.AbstractSampler, Any, Type{T}}} where T","page":"Home","title":"DynamicPPL.get_matching_type","text":"get_matching_type(spl::AbstractSampler, vi, ::Type{T}) where {T}\n\nGet the specialized version of type T for sampler spl.\n\nFor example, if T === Float64 and spl::Hamiltonian, the matching type is eltype(vi[spl]).\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.get_num_produce-Tuple{VarInfo}","page":"Home","title":"DynamicPPL.get_num_produce","text":"get_num_produce(vi::VarInfo)\n\nReturn the num_produce of vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getall-Tuple{UntypedVarInfo}","page":"Home","title":"DynamicPPL.getall","text":"getall(vi::VarInfo)\n\nReturn the values of all the variables in vi.\n\nThe values may or may not be transformed to Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getargnames-Union{Tuple{Model{_F, argnames}}, Tuple{_F}, Tuple{argnames}} where {argnames, _F}","page":"Home","title":"DynamicPPL.getargnames","text":"getargnames(model::Model)\n\nGet a tuple of the argument names of the model.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getargs_assignment-Tuple{Any}","page":"Home","title":"DynamicPPL.getargs_assignment","text":"getargs_assignment(x)\n\nReturn the arguments L and R, if x is an expression of the form L = R, or nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getargs_dottilde-Tuple{Any}","page":"Home","title":"DynamicPPL.getargs_dottilde","text":"getargs_dottilde(x)\n\nReturn the arguments L and R, if x is an expression of the form L .~ R or (~).(L, R), or nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getargs_tilde-Tuple{Any}","page":"Home","title":"DynamicPPL.getargs_tilde","text":"getargs_tilde(x)\n\nReturn the arguments L and R, if x is an expression of the form L ~ R, or nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getdist-Tuple{VarInfo, VarName}","page":"Home","title":"DynamicPPL.getdist","text":"getdist(vi::VarInfo, vn::VarName)\n\nReturn the distribution from which vn was sampled in vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getgid-Tuple{VarInfo, VarName}","page":"Home","title":"DynamicPPL.getgid","text":"getgid(vi::VarInfo, vn::VarName)\n\nReturn the set of sampler selectors associated with vn in vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getidx-Tuple{VarInfo, VarName}","page":"Home","title":"DynamicPPL.getidx","text":"getidx(vi::VarInfo, vn::VarName)\n\nReturn the index of vn in the metadata of vi corresponding to vn.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getlogp-Tuple{AbstractVarInfo}","page":"Home","title":"DynamicPPL.getlogp","text":"getlogp(vi::VarInfo)\n\nReturn the log of the joint probability of the observed data and parameters sampled in vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getmetadata-Tuple{VarInfo, VarName}","page":"Home","title":"DynamicPPL.getmetadata","text":"getmetadata(vi::VarInfo, vn::VarName)\n\nReturn the metadata in vi that belongs to vn.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getmissings-Union{Tuple{Model{_F, _a, _d, missings}}, Tuple{_d}, Tuple{_a}, Tuple{_F}, Tuple{missings}} where {missings, _F, _a, _d}","page":"Home","title":"DynamicPPL.getmissings","text":"getmissings(model::Model)\n\nGet a tuple of the names of the missing arguments of the model.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getrange-Tuple{VarInfo, VarName}","page":"Home","title":"DynamicPPL.getrange","text":"getrange(vi::VarInfo, vn::VarName)\n\nReturn the index range of vn in the metadata of vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getranges-Tuple{AbstractVarInfo, Vector{<:VarName}}","page":"Home","title":"DynamicPPL.getranges","text":"getranges(vi::AbstractVarInfo, vns::Vector{<:VarName})\n\nReturn the indices of vns in the metadata of vi corresponding to vn.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getval-Tuple{AbstractVarInfo, Vector{<:VarName}}","page":"Home","title":"DynamicPPL.getval","text":"getval(vi::VarInfo, vns::Vector{<:VarName})\n\nReturn the value(s) of vns.\n\nThe values may or may not be transformed to Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getval-Tuple{UntypedVarInfo, Union{Int64, UnitRange, Vector{Int64}}}","page":"Home","title":"DynamicPPL.getval","text":"getval(vi::UntypedVarInfo, vview::Union{Int, UnitRange, Vector{Int}})\n\nReturn a view vi.vals[vview].\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getval-Tuple{VarInfo, VarName}","page":"Home","title":"DynamicPPL.getval","text":"getval(vi::VarInfo, vn::VarName)\n\nReturn the value(s) of vn.\n\nThe values may or may not be transformed to Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getvalue-Tuple{DynamicPPL.AbstractContext, Any}","page":"Home","title":"DynamicPPL.getvalue","text":"getvalue(context, vn)\n\nReturn value of vn in context.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.getvalue_nested-Tuple{DynamicPPL.AbstractContext, Any}","page":"Home","title":"DynamicPPL.getvalue_nested","text":"getvalue_nested(context, vn)\n\nReturn the value of the parameter corresponding to vn from context or its descendants.\n\nThis is contrast to getvalue which only returns the value vn in context, not recursively looking into its descendants.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.hasvalue-Tuple{Any, Any}","page":"Home","title":"DynamicPPL.hasvalue","text":"hasvalue(context, vn)\n\nReturn true if vn is found in context.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.hasvalue_nested-Tuple{DynamicPPL.AbstractContext, Any}","page":"Home","title":"DynamicPPL.hasvalue_nested","text":"hasvalue_nested(context, vn)\n\nReturn true if vn is found in context or any of its descendants.\n\nThis is contrast to hasvalue which only checks for vn in context, not recursively checking if vn is in any of its descendants.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.inargnames-Union{Tuple{_F}, Tuple{argnames}, Tuple{s}, Tuple{VarName{s}, Model{_F, argnames}}} where {s, argnames, _F}","page":"Home","title":"DynamicPPL.inargnames","text":"inargnames(varname::VarName, model::Model)\n\nStatically check whether the variable of name varname is an argument of the model.\n\nPossibly existing indices of varname are neglected.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.increment_num_produce!-Tuple{VarInfo}","page":"Home","title":"DynamicPPL.increment_num_produce!","text":"increment_num_produce!(vi::VarInfo)\n\nAdd 1 to num_produce in vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.initialsampler-Tuple{Sampler}","page":"Home","title":"DynamicPPL.initialsampler","text":"initialsampler(sampler::Sampler)\n\nReturn the sampler that is used for generating the initial parameters when sampling with sampler.\n\nBy default, it returns an instance of SampleFromPrior.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.initialstep","page":"Home","title":"DynamicPPL.initialstep","text":"initialstep(rng, model, sampler, varinfo; kwargs...)\n\nPerform the initial sampling step of the sampler for the model.\n\nThe varinfo contains the initial samples, which can be provided by the user or sampled randomly.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicPPL.inmissings-Union{Tuple{_T}, Tuple{_a}, Tuple{_F}, Tuple{missings}, Tuple{s}, Tuple{VarName{s}, Model{_F, _a, _T, missings}}} where {s, missings, _F, _a, _T}","page":"Home","title":"DynamicPPL.inmissings","text":"inmissings(varname::VarName, model::Model)\n\nStatically check whether the variable of name varname is a statically declared unobserved variable of the model.\n\nPossibly existing indices of varname are neglected.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.invlink!-Tuple{UntypedVarInfo, AbstractMCMC.AbstractSampler}","page":"Home","title":"DynamicPPL.invlink!","text":"invlink!(vi::VarInfo, spl::AbstractSampler)\n\nTransform the values of the random variables sampled by spl in vi from the Euclidean space back to the support of their distributions and sets their corresponding \"trans\" flag values to false.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.is_flagged-Tuple{VarInfo, VarName, String}","page":"Home","title":"DynamicPPL.is_flagged","text":"is_flagged(vi::VarInfo, vn::VarName, flag::String)\n\nCheck whether vn has a true value for flag in vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.isassumption","page":"Home","title":"DynamicPPL.isassumption","text":"isassumption(expr[, vn])\n\nReturn an expression that can be evaluated to check if expr is an assumption in the model.\n\nLet expr be :(x[1]). It is an assumption in the following cases:     1. x is not among the input data to the model,     2. x is among the input data to the model but with a value missing, or     3. x is among the input data to the model with a value other than missing,        but x[1] === missing.\n\nWhen expr is not an expression or symbol (i.e., a literal), this expands to false.\n\nIf vn is specified, it will be assumed to refer to a expression which evaluates to a VarName, and this will be used in the subsequent checks. If vn is not specified, AbstractPPL.drop_escape(varname(expr)) will be used in its place.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicPPL.isfuncdef-Tuple{Expr}","page":"Home","title":"DynamicPPL.isfuncdef","text":"isfuncdef(expr)\n\nReturn true if expr is any form of function definition, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.islinked-Tuple{UntypedVarInfo, Union{SampleFromPrior, Sampler}}","page":"Home","title":"DynamicPPL.islinked","text":"islinked(vi::VarInfo, spl::Union{Sampler, SampleFromPrior})\n\nCheck whether vi is in the transformed space for a particular sampler spl.\n\nTuring's Hamiltonian samplers use the link and invlink functions from  Bijectors.jl to map a constrained variable (for example, one bounded to the space [0, 1]) from its constrained space to the set of  real numbers. islinked checks if the number is in the constrained space or the real space.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.isliteral-Tuple{Any}","page":"Home","title":"DynamicPPL.isliteral","text":"isliteral(expr)\n\nReturn true if expr is a literal, e.g. 1.0 or [1.0, ], and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.istrans-Tuple{AbstractVarInfo, VarName}","page":"Home","title":"DynamicPPL.istrans","text":"istrans(vi::VarInfo, vn::VarName)\n\nReturn true if vn's values in vi are transformed to Euclidean space, and false if they are in the support of vn's distribution.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.leafcontext-Tuple{Any}","page":"Home","title":"DynamicPPL.leafcontext","text":"leafcontext(context)\n\nReturn the leaf of context, i.e. the first descendant context that IsLeaf.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.link!-Tuple{UntypedVarInfo, Sampler}","page":"Home","title":"DynamicPPL.link!","text":"link!(vi::VarInfo, spl::Sampler)\n\nTransform the values of the random variables sampled by spl in vi from the support of their distributions to the Euclidean space and set their corresponding \"trans\" flag values to true.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.loadstate","page":"Home","title":"DynamicPPL.loadstate","text":"loadstate(data)\n\nLoad sampler state from data.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicPPL.logjoint-Tuple{Model, AbstractVarInfo}","page":"Home","title":"DynamicPPL.logjoint","text":"logjoint(model::Model, varinfo::AbstractVarInfo)\n\nReturn the log joint probability of variables varinfo for the probabilistic model.\n\nSee logjoint and loglikelihood.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.logjoint-Tuple{Model, Any}","page":"Home","title":"DynamicPPL.logjoint","text":"logjoint(model::Model, θ)\n\nReturn the log joint probability of variables θ for the probabilistic model.\n\nSee logjoint and loglikelihood.\n\nExamples\n\njulia> @model function demo(x)\n           m ~ Normal()\n           for i in eachindex(x)\n               x[i] ~ Normal(m, 1.0)\n           end\n       end\ndemo (generic function with 2 methods)\n\njulia> # Using a `NamedTuple`.\n       logjoint(demo([1.0]), (m = 100.0, ))\n-9902.33787706641\n\njulia> # Using a `Dict`.\n       logjoint(demo([1.0]), Dict(@varname(m) => 100.0))\n-9902.33787706641\n\njulia> # Truth.\n       logpdf(Normal(100.0, 1.0), 1.0) + logpdf(Normal(), 100.0)\n-9902.33787706641\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.logprior-Tuple{Model, AbstractVarInfo}","page":"Home","title":"DynamicPPL.logprior","text":"logprior(model::Model, varinfo::AbstractVarInfo)\n\nReturn the log prior probability of variables varinfo for the probabilistic model.\n\nSee also logjoint and loglikelihood.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.logprior-Tuple{Model, Any}","page":"Home","title":"DynamicPPL.logprior","text":"logprior(model::Model, θ)\n\nReturn the log prior probability of variables θ for the probabilistic model.\n\nSee also logjoint and loglikelihood.\n\nExamples\n\njulia> @model function demo(x)\n           m ~ Normal()\n           for i in eachindex(x)\n               x[i] ~ Normal(m, 1.0)\n           end\n       end\ndemo (generic function with 2 methods)\n\njulia> # Using a `NamedTuple`.\n       logprior(demo([1.0]), (m = 100.0, ))\n-5000.918938533205\n\njulia> # Using a `Dict`.\n       logprior(demo([1.0]), Dict(@varname(m) => 100.0))\n-5000.918938533205\n\njulia> # Truth.\n       logpdf(Normal(), 100.0)\n-5000.918938533205\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.matchingvalue-Tuple{Any, Any, Any}","page":"Home","title":"DynamicPPL.matchingvalue","text":"matchingvalue(sampler, vi, value)\nmatchingvalue(context::AbstractContext, vi, value)\n\nConvert the value to the correct type for the sampler or context and the vi object.\n\nFor a context that is not a SamplingContext, we fall back to matchingvalue(SampleFromPrior(), vi, value).\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.observations-Tuple{Model}","page":"Home","title":"DynamicPPL.observations","text":"observations(model::Model)\n\nAlias for conditioned.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.parent-Tuple{Setfield.Lens}","page":"Home","title":"DynamicPPL.parent","text":"parent(lens::Setfield.Lens)\n\nReturn the parent lens. If lens doesn't have a parent, nothing is returned.\n\nSee also: [parent_and_child].\n\nExamples\n\njulia> parent(@lens(_.a[1]))\n(@lens _.a)\n\njulia> # Parent of lens without parents results in `nothing`.\n       (parent ∘ parent)(@lens(_.a[1])) === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.parent-Tuple{VarName}","page":"Home","title":"DynamicPPL.parent","text":"parent(vn::VarName)\n\nReturn the parent VarName.\n\nExamples\n\njulia> parent(@varname(x.a[1]))\nx.a\n\njulia> (parent ∘ parent)(@varname(x.a[1]))\nx\n\njulia> (parent ∘ parent ∘ parent)(@varname(x.a[1]))\nx\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.parent_and_child-Tuple{Setfield.Lens}","page":"Home","title":"DynamicPPL.parent_and_child","text":"parent_and_child(lens::Setfield.Lens)\n\nReturn a 2-tuple of lenses (parent, child) where parent is the parent lens of lens and child is the child lens of lens.\n\nIf lens does not have a parent, we return (nothing, lens).\n\nSee also: [parent].\n\nExamples\n\njulia> parent_and_child(@lens(_.a[1]))\n((@lens _.a), (@lens _[1]))\n\njulia> parent_and_child(@lens(_.a))\n(nothing, (@lens _.a))\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.pointwise_loglikelihoods-Union{Tuple{T}, Tuple{Model, Any}, Tuple{Model, Any, Type{T}}} where T","page":"Home","title":"DynamicPPL.pointwise_loglikelihoods","text":"pointwise_loglikelihoods(model::Model, chain::Chains, keytype = String)\n\nRuns model on each sample in chain returning a Dict{String, Matrix{Float64}} with keys corresponding to symbols of the observations, and values being matrices of shape (num_chains, num_samples).\n\nkeytype specifies what the type of the keys used in the returned Dict are. Currently, only String and VarName are supported.\n\nNotes\n\nSay y is a Vector of n i.i.d. Normal(μ, σ) variables, with μ and σ both being <:Real. Then the observe (i.e. when the left-hand side is an observation) statements can be implemented in three ways:\n\nusing a for loop:\n\nfor i in eachindex(y)\n    y[i] ~ Normal(μ, σ)\nend\n\nusing .~:\n\ny .~ Normal(μ, σ)\n\nusing MvNormal:\n\ny ~ MvNormal(fill(μ, n), σ^2 * I)\n\nIn (1) and (2), y will be treated as a collection of n i.i.d. 1-dimensional variables, while in (3) y will be treated as a single n-dimensional observation.\n\nThis is important to keep in mind, in particular if the computation is used for downstream computations.\n\nExamples\n\nFrom chain\n\njulia> using DynamicPPL, Turing\n\njulia> @model function demo(xs, y)\n           s ~ InverseGamma(2, 3)\n           m ~ Normal(0, √s)\n           for i in eachindex(xs)\n               xs[i] ~ Normal(m, √s)\n           end\n\n           y ~ Normal(m, √s)\n       end\ndemo (generic function with 1 method)\n\njulia> model = demo(randn(3), randn());\n\njulia> chain = sample(model, MH(), 10);\n\njulia> pointwise_loglikelihoods(model, chain)\nDict{String,Array{Float64,2}} with 4 entries:\n  \"xs[3]\" => [-1.42862; -2.67573; … ; -1.66251; -1.66251]\n  \"xs[1]\" => [-1.42932; -2.68123; … ; -1.66333; -1.66333]\n  \"xs[2]\" => [-1.6724; -0.861339; … ; -1.62359; -1.62359]\n  \"y\"     => [-1.51265; -0.914129; … ; -1.5499; -1.5499]\n\njulia> pointwise_loglikelihoods(model, chain, String)\nDict{String,Array{Float64,2}} with 4 entries:\n  \"xs[3]\" => [-1.42862; -2.67573; … ; -1.66251; -1.66251]\n  \"xs[1]\" => [-1.42932; -2.68123; … ; -1.66333; -1.66333]\n  \"xs[2]\" => [-1.6724; -0.861339; … ; -1.62359; -1.62359]\n  \"y\"     => [-1.51265; -0.914129; … ; -1.5499; -1.5499]\n\njulia> pointwise_loglikelihoods(model, chain, VarName)\nDict{VarName,Array{Float64,2}} with 4 entries:\n  xs[2] => [-1.6724; -0.861339; … ; -1.62359; -1.62359]\n  y     => [-1.51265; -0.914129; … ; -1.5499; -1.5499]\n  xs[1] => [-1.42932; -2.68123; … ; -1.66333; -1.66333]\n  xs[3] => [-1.42862; -2.67573; … ; -1.66251; -1.66251]\n\nBroadcasting\n\nNote that x .~ Dist() will treat x as a collection of independent observations rather than as a single observation.\n\njulia> @model function demo(x)\n           x .~ Normal()\n       end;\n\njulia> m = demo([1.0, ]);\n\njulia> ℓ = pointwise_loglikelihoods(m, VarInfo(m)); first(ℓ[@varname(x[1])])\n-1.4189385332046727\n\njulia> m = demo([1.0; 1.0]);\n\njulia> ℓ = pointwise_loglikelihoods(m, VarInfo(m)); first.((ℓ[@varname(x[1])], ℓ[@varname(x[2])]))\n(-1.4189385332046727, -1.4189385332046727)\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.replace_returns-Tuple{Any}","page":"Home","title":"DynamicPPL.replace_returns","text":"replace_returns(expr)\n\nReturn Expr with all return ... statements replaced with return ..., DynamicPPL.return_values(__varinfo__).\n\nNote that this method will not replace return statements within function definitions. This is checked using isfuncdef.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.reset_num_produce!-Tuple{AbstractVarInfo}","page":"Home","title":"DynamicPPL.reset_num_produce!","text":"reset_num_produce!(vi::AbstractVarInfo)\n\nReset the value of num_produce the log of the joint probability of the observed data and parameters sampled in vi to 0.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.resetlogp!!-Tuple{AbstractVarInfo}","page":"Home","title":"DynamicPPL.resetlogp!!","text":"resetlogp!!(vi::AbstractVarInfo)\n\nReset the value of the log of the joint probability of the observed data and parameters sampled in vi to 0, mutating if it makes sense.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.set_flag!-Tuple{VarInfo, VarName, String}","page":"Home","title":"DynamicPPL.set_flag!","text":"set_flag!(vi::VarInfo, vn::VarName, flag::String)\n\nSet vn's value for flag to true in vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.set_num_produce!-Tuple{VarInfo, Int64}","page":"Home","title":"DynamicPPL.set_num_produce!","text":"set_num_produce!(vi::VarInfo, n::Int)\n\nSet the num_produce field of vi to n.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.set_retained_vns_del_by_spl!-Tuple{UntypedVarInfo, Sampler}","page":"Home","title":"DynamicPPL.set_retained_vns_del_by_spl!","text":"set_retained_vns_del_by_spl!(vi::VarInfo, spl::Sampler)\n\nSet the \"del\" flag of variables in vi with order > vi.num_produce[] to true.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.setall!-Tuple{UntypedVarInfo, Any}","page":"Home","title":"DynamicPPL.setall!","text":"setall!(vi::VarInfo, val)\n\nSet the values of all the variables in vi to val.\n\nThe values may or may not be transformed to Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.setchildcontext","page":"Home","title":"DynamicPPL.setchildcontext","text":"setchildcontext(parent::AbstractContext, child::AbstractContext)\n\nReconstruct parent but now using child is its childcontext, effectively updating the child context.\n\nExamples\n\njulia> ctx = SamplingContext();\n\njulia> DynamicPPL.childcontext(ctx)\nDefaultContext()\n\njulia> ctx_prior = DynamicPPL.setchildcontext(ctx, PriorContext()); # only compute the logprior\n\njulia> DynamicPPL.childcontext(ctx_prior)\nPriorContext{Nothing}(nothing)\n\n\n\n\n\n","category":"function"},{"location":"#DynamicPPL.setgid!-Tuple{VarInfo, DynamicPPL.Selector, VarName}","page":"Home","title":"DynamicPPL.setgid!","text":"setgid!(vi::VarInfo, gid::Selector, vn::VarName)\n\nAdd gid to the set of sampler selectors associated with vn in vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.setleafcontext-Tuple{Any, Any}","page":"Home","title":"DynamicPPL.setleafcontext","text":"setleafcontext(left, right)\n\nReturn left but now with its leaf context replaced by right.\n\nNote that this also works even if right is not a leaf context, in which case effectively append right to left, dropping the original leaf context of left.\n\nExamples\n\njulia> using DynamicPPL: leafcontext, setleafcontext, childcontext, setchildcontext, AbstractContext\n\njulia> struct ParentContext{C} <: AbstractContext\n           context::C\n       end\n\njulia> DynamicPPL.NodeTrait(::ParentContext) = DynamicPPL.IsParent()\n\njulia> DynamicPPL.childcontext(context::ParentContext) = context.context\n\njulia> DynamicPPL.setchildcontext(::ParentContext, child) = ParentContext(child)\n\njulia> Base.show(io::IO, c::ParentContext) = print(io, \"ParentContext(\", childcontext(c), \")\")\n\njulia> ctx = ParentContext(ParentContext(DefaultContext()))\nParentContext(ParentContext(DefaultContext()))\n\njulia> # Replace the leaf context with another leaf.\n       leafcontext(setleafcontext(ctx, PriorContext()))\nPriorContext{Nothing}(nothing)\n\njulia> # Append another parent context.\n       setleafcontext(ctx, ParentContext(DefaultContext()))\nParentContext(ParentContext(ParentContext(DefaultContext())))\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.setlogp!!-Tuple{VarInfo, Any}","page":"Home","title":"DynamicPPL.setlogp!!","text":"setlogp!!(vi::VarInfo, logp)\n\nSet the log of the joint probability of the observed data and parameters sampled in vi to logp, mutating if it makes sense.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.setorder!-Tuple{VarInfo, VarName, Int64}","page":"Home","title":"DynamicPPL.setorder!","text":"setorder!(vi::VarInfo, vn::VarName, index::Int)\n\nSet the order of vn in vi to index, where order is the number of observe statements run before samplingvn`.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.settrans!-Tuple{AbstractVarInfo, Bool, VarName}","page":"Home","title":"DynamicPPL.settrans!","text":"settrans!(vi::VarInfo, trans::Bool, vn::VarName)\n\nSet the trans flag value of vn in vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.setval!-Tuple{AbstractVarInfo, Any}","page":"Home","title":"DynamicPPL.setval!","text":"setval!(vi::AbstractVarInfo, x)\nsetval!(vi::AbstractVarInfo, values, keys)\nsetval!(vi::AbstractVarInfo, chains::AbstractChains, sample_idx::Int, chain_idx::Int)\n\nSet the values in vi to the provided values and leave those which are not present in x or chains unchanged.\n\nNotes\n\nThis is rather limited for two reasons:\n\nIt uses subsumes_string(string(vn), map(string, keys)) under the hood, and therefore suffers from the same limitations as subsumes_string.\nIt will set every vn present in keys. It will NOT however set every k present in keys. This means that if vn == [m[1], m[2]], representing some variable m, calling setval!(vi, (m = [1.0, 2.0])) will be a no-op since it will try to find m[1] and m[2] in keys((m = [1.0, 2.0])).\n\nExample\n\njulia> using DynamicPPL, Distributions, StableRNGs\n\njulia> @model function demo(x)\n           m ~ Normal()\n           for i in eachindex(x)\n               x[i] ~ Normal(m, 1)\n           end\n       end;\n\njulia> rng = StableRNG(42);\n\njulia> m = demo([missing]);\n\njulia> var_info = DynamicPPL.VarInfo(rng, m);\n\njulia> var_info[@varname(m)]\n-0.6702516921145671\n\njulia> var_info[@varname(x[1])]\n-0.22312984965118443\n\njulia> DynamicPPL.setval!(var_info, (m = 100.0, )); # set `m` and and keep `x[1]`\n\njulia> var_info[@varname(m)] # [✓] changed\n100.0\n\njulia> var_info[@varname(x[1])] # [✓] unchanged\n-0.22312984965118443\n\njulia> m(rng, var_info); # rerun model\n\njulia> var_info[@varname(m)] # [✓] unchanged\n100.0\n\njulia> var_info[@varname(x[1])] # [✓] unchanged\n-0.22312984965118443\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.setval!-Tuple{UntypedVarInfo, Any, Union{Int64, UnitRange, Vector{Int64}}}","page":"Home","title":"DynamicPPL.setval!","text":"setval!(vi::UntypedVarInfo, val, vview::Union{Int, UnitRange, Vector{Int}})\n\nSet the value of vi.vals[vview] to val.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.setval!-Tuple{VarInfo, Any, VarName}","page":"Home","title":"DynamicPPL.setval!","text":"setval!(vi::VarInfo, val, vn::VarName)\n\nSet the value(s) of vn in the metadata of vi to val.\n\nThe values may or may not be transformed to Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.setval_and_resample!-Tuple{AbstractVarInfo, Any}","page":"Home","title":"DynamicPPL.setval_and_resample!","text":"setval_and_resample!(vi::AbstractVarInfo, x)\nsetval_and_resample!(vi::AbstractVarInfo, values, keys)\nsetval_and_resample!(vi::AbstractVarInfo, chains::AbstractChains, sample_idx, chain_idx)\n\nSet the values in vi to the provided values and those which are not present in x or chains to be resampled.\n\nNote that this does not resample the values not provided! It will call setflag!(vi, vn, \"del\") for variables vn for which no values are provided, which means that the next time we call model(vi) these variables will be resampled.\n\nNote\n\nThis suffers from the same limitations as setval!. See setval! for more info.\n\nExample\n\njulia> using DynamicPPL, Distributions, StableRNGs\n\njulia> @model function demo(x)\n           m ~ Normal()\n           for i in eachindex(x)\n               x[i] ~ Normal(m, 1)\n           end\n       end;\n\njulia> rng = StableRNG(42);\n\njulia> m = demo([missing]);\n\njulia> var_info = DynamicPPL.VarInfo(rng, m);\n\njulia> var_info[@varname(m)]\n-0.6702516921145671\n\njulia> var_info[@varname(x[1])]\n-0.22312984965118443\n\njulia> DynamicPPL.setval_and_resample!(var_info, (m = 100.0, )); # set `m` and ready `x[1]` for resampling\n\njulia> var_info[@varname(m)] # [✓] changed\n100.0\n\njulia> var_info[@varname(x[1])] # [✓] unchanged\n-0.22312984965118443\n\njulia> m(rng, var_info); # sample `x[1]` conditioned on `m = 100.0`\n\njulia> var_info[@varname(m)] # [✓] unchanged\n100.0\n\njulia> var_info[@varname(x[1])] # [✓] changed\n101.37363069798343\n\nSee also\n\nsetval!\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.splitlens-Tuple{Any, Any}","page":"Home","title":"DynamicPPL.splitlens","text":"splitlens(condition, lens)\n\nReturn a 3-tuple (parent, child, issuccess) where, if issuccess is true, parent is a lens such that condition(parent) is true and parent ∘ child == lens.\n\nIf issuccess is false, then no such split could be found.\n\nExamples\n\njulia> p, c, issucesss = splitlens(@lens(_.a[1])) do parent\n           # Succeeds!\n           parent == @lens(_.a)\n       end\n((@lens _.a), (@lens _[1]), true)\n\njulia> p ∘ c\n(@lens _.a[1])\n\njulia> splitlens(@lens(_.a[1])) do parent\n           # Fails!\n           parent == @lens(_.b)\n       end\n(nothing, (@lens _.a[1]), false)\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.subsumes_string","page":"Home","title":"DynamicPPL.subsumes_string","text":"subsumes_string(u::String, v::String[, u_indexing])\n\nCheck whether stringified variable name v describes a sub-range of stringified variable u.\n\nThis is a very restricted version subumes(u::VarName, v::VarName) only really supporting:\n\nScalar: x subsumes x[1, 2], x[1, 2] subsumes x[1, 2][3], etc.\n\nNote\n\nTo get same matching capabilities as AbstractPPL.subumes(u::VarName, v::VarName)  for strings, one can always do eval(varname(Meta.parse(u)) to get VarName of u, and similarly to v. But this is slow.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicPPL.syms-Tuple{UntypedVarInfo}","page":"Home","title":"DynamicPPL.syms","text":"syms(vi::VarInfo)\n\nReturns a tuple of the unique symbols of random variables sampled in vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.tilde_assume!!-NTuple{4, Any}","page":"Home","title":"DynamicPPL.tilde_assume!!","text":"tilde_assume!!(context, right, vn, vi)\n\nHandle assumed variables, e.g., x ~ Normal() (where x does occur in the model inputs), accumulate the log probability, and return the sampled value and updated vi.\n\nBy default, calls tilde_assume(context, right, vn, vi) and accumulates the log probability of vi with the returned value.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.tilde_assume-Tuple{SamplingContext, Any, Any, Any}","page":"Home","title":"DynamicPPL.tilde_assume","text":"tilde_assume(context::SamplingContext, right, vn, vi)\n\nHandle assumed variables, e.g., x ~ Normal() (where x does occur in the model inputs), accumulate the log probability, and return the sampled value with a context associated with a sampler.\n\nFalls back to\n\ntilde_assume(context.rng, context.context, context.sampler, right, vn, vi)\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.tilde_observe!!-NTuple{4, Any}","page":"Home","title":"DynamicPPL.tilde_observe!!","text":"tilde_observe(context, right, left, vi)\n\nHandle observed constants, e.g., 1.0 ~ Normal(), accumulate the log probability, and return the observed value.\n\nBy default, calls tilde_observe(context, right, left, vi) and accumulates the log probability of vi with the returned value.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.tilde_observe!!-NTuple{5, Any}","page":"Home","title":"DynamicPPL.tilde_observe!!","text":"tilde_observe!!(context, right, left, vname, vi)\n\nHandle observed variables, e.g., x ~ Normal() (where x does occur in the model inputs), accumulate the log probability, and return the observed value and updated vi.\n\nFalls back to tilde_observe!!(context, right, left, vi) ignoring the information about variable name and indices; if needed, these can be accessed through this function, though.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.tilde_observe-Tuple{SamplingContext, Any, Any, Any}","page":"Home","title":"DynamicPPL.tilde_observe","text":"tilde_observe(context::SamplingContext, right, left, vi)\n\nHandle observed constants with a context associated with a sampler.\n\nFalls back to tilde_observe(context.context, context.sampler, right, left, vi).\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.tonamedtuple-Tuple{VarInfo}","page":"Home","title":"DynamicPPL.tonamedtuple","text":"tonamedtuple(vi::VarInfo)\n\nConvert a vi into a NamedTuple where each variable symbol maps to the values and  indexing string of the variable.\n\nFor example, a model that had a vector of vector-valued variables x would return\n\n(x = ([1.5, 2.0], [3.0, 1.0], [\"x[1]\", \"x[2]\"]), )\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.unset_flag!-Tuple{VarInfo, VarName, String}","page":"Home","title":"DynamicPPL.unset_flag!","text":"unset_flag!(vi::VarInfo, vn::VarName, flag::String)\n\nSet vn's value for flag to false in vi.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.unwrap_right_left_vns-Tuple{Any, Any, Any}","page":"Home","title":"DynamicPPL.unwrap_right_left_vns","text":"unwrap_right_left_vns(right, left, vns)\n\nReturn the unwrapped distributions on the right-hand side and values and variable names on the left-hand side of a .~ expression such as x .~ Normal().\n\nThis is used mainly to unwrap NamedDist distributions and adjust the indices of the variables.\n\nExample\n\njulia> _, _, vns = DynamicPPL.unwrap_right_left_vns(MvNormal(ones(2), I), randn(2, 2), @varname(x)); vns[end]\nx[:,2]\n\njulia> _, _, vns = DynamicPPL.unwrap_right_left_vns(Normal(), randn(1, 2), @varname(x)); vns[end]\nx[1,2]\n\njulia> _, _, vns = DynamicPPL.unwrap_right_left_vns(Normal(), randn(1, 2), @varname(x[:])); vns[end]\nx[:][1,2]\n\njulia> _, _, vns = DynamicPPL.unwrap_right_left_vns(Normal(), randn(3), @varname(x[1])); vns[end]\nx[1][3]\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.unwrap_right_vn-Tuple{Any, Any}","page":"Home","title":"DynamicPPL.unwrap_right_vn","text":"unwrap_right_vn(right, vn)\n\nReturn the unwrapped distribution on the right-hand side and variable name on the left-hand side of a ~ expression such as x ~ Normal().\n\nThis is used mainly to unwrap NamedDist distributions.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.updategid!-Tuple{AbstractVarInfo, VarName, Sampler}","page":"Home","title":"DynamicPPL.updategid!","text":"updategid!(vi::VarInfo, vn::VarName, spl::Sampler)\n\nSet vn's gid to Set([spl.selector]), if vn does not have a sampler selector linked and vn's symbol is in the space of spl.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.values_as-Tuple{SimpleVarInfo}","page":"Home","title":"DynamicPPL.values_as","text":"values_as(varinfo[, Type])\n\nReturn the values/realizations in varinfo as Type, if implemented.\n\nIf no Type is provided, return values as stored in varinfo.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.values_as-Tuple{UntypedVarInfo, Type{NamedTuple}}","page":"Home","title":"DynamicPPL.values_as","text":"values_as(vi::AbstractVarInfo, ::Type{NamedTuple})\nvalues_as(vi::AbstractVarInfo, ::Type{Dict})\n\nReturn values in vi as the specified type.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.values_as-Tuple{VarInfo}","page":"Home","title":"DynamicPPL.values_as","text":"values_as(vi::AbstractVarInfo)\n\n\n\n\n\n","category":"method"},{"location":"#StatsBase.loglikelihood-Tuple{Model, AbstractVarInfo}","page":"Home","title":"StatsBase.loglikelihood","text":"loglikelihood(model::Model, varinfo::AbstractVarInfo)\n\nReturn the log likelihood of variables varinfo for the probabilistic model.\n\nSee also logjoint and logprior.\n\n\n\n\n\n","category":"method"},{"location":"#StatsBase.loglikelihood-Tuple{Model, Any}","page":"Home","title":"StatsBase.loglikelihood","text":"loglikelihood(model::Model, θ)\n\nReturn the log likelihood of variables θ for the probabilistic model.\n\nSee also logjoint and logprior.\n\nExamples\n\njulia> @model function demo(x)\n           m ~ Normal()\n           for i in eachindex(x)\n               x[i] ~ Normal(m, 1.0)\n           end\n       end\ndemo (generic function with 2 methods)\n\njulia> # Using a `NamedTuple`.\n       loglikelihood(demo([1.0]), (m = 100.0, ))\n-4901.418938533205\n\njulia> # Using a `Dict`.\n       loglikelihood(demo([1.0]), Dict(@varname(m) => 100.0))\n-4901.418938533205\n\njulia> # Truth.\n       logpdf(Normal(100.0, 1.0), 1.0)\n-4901.418938533205\n\n\n\n\n\n","category":"method"},{"location":"#DynamicPPL.@addlogprob!-Tuple{Any}","page":"Home","title":"DynamicPPL.@addlogprob!","text":"@addlogprob!(ex)\n\nAdd the result of the evaluation of ex to the joint log probability.\n\n\n\n\n\n","category":"macro"},{"location":"#DynamicPPL.@model","page":"Home","title":"DynamicPPL.@model","text":"@model(expr[, warn = false])\n\nMacro to specify a probabilistic model.\n\nIf warn is true, a warning is displayed if internal variable names are used in the model definition.\n\nExamples\n\nModel definition:\n\n@model function model(x, y = 42)\n    ...\nend\n\nTo generate a Model, call model(xvalue) or model(xvalue, yvalue).\n\n\n\n\n\n","category":"macro"},{"location":"#DynamicPPL.@submodel-Tuple{Any, Any}","page":"Home","title":"DynamicPPL.@submodel","text":"@submodel prefix=... model\n@submodel prefix=... ... = model\n\nRun a Turing model nested inside of a Turing model and add \"prefix.\" as a prefix to all random variables inside of the model.\n\nValid expressions for prefix=... are:\n\nprefix=false: no prefix is used.\nprefix=true: attempt to automatically determine the prefix from the left-hand side ... = model by first converting into a VarName, and then calling Symbol on this.\nprefix=expression: results in the prefix Symbol(expression).\n\nThe prefix makes it possible to run the same Turing model multiple times while keeping track of all random variables correctly.\n\nExamples\n\nExample models\n\njulia> @model function demo1(x)\n           x ~ Normal()\n           return 1 + abs(x)\n       end;\n\njulia> @model function demo2(x, y, z)\n            @submodel prefix=\"sub1\" a = demo1(x)\n            @submodel prefix=\"sub2\" b = demo1(y)\n            return z ~ Uniform(-a, b)\n       end;\n\nWhen we sample from the model demo2(missing, missing, 0.4) random variables sub1.x and sub2.x will be sampled:\n\njulia> vi = VarInfo(demo2(missing, missing, 0.4));\n\njulia> @varname(var\"sub1.x\") in keys(vi)\ntrue\n\njulia> @varname(var\"sub2.x\") in keys(vi)\ntrue\n\nVariables a and b are not tracked since they can be computed from the random variables sub1.x and sub2.x that were tracked when running demo1:\n\njulia> @varname(a) in keys(vi)\nfalse\n\njulia> @varname(b) in keys(vi)\nfalse\n\nWe can check that the log joint probability of the model accumulated in vi is correct:\n\njulia> sub1_x = vi[@varname(var\"sub1.x\")];\n\njulia> sub2_x = vi[@varname(var\"sub2.x\")];\n\njulia> logprior = logpdf(Normal(), sub1_x) + logpdf(Normal(), sub2_x);\n\njulia> loglikelihood = logpdf(Uniform(-1 - abs(sub1_x), 1 + abs(sub2_x)), 0.4);\n\njulia> getlogp(vi) ≈ logprior + loglikelihood\ntrue\n\nDifferent ways of setting the prefix\n\njulia> @model inner() = x ~ Normal()\ninner (generic function with 2 methods)\n\njulia> # When `prefix` is unspecified, no prefix is used.\n       @model outer() = @submodel a = inner()\nouter (generic function with 2 methods)\n\njulia> @varname(x) in keys(VarInfo(outer()))\ntrue\n\njulia> # Explicitely don't use any prefix.\n       @model outer() = @submodel prefix=false a = inner()\nouter (generic function with 2 methods)\n\njulia> @varname(x) in keys(VarInfo(outer()))\ntrue\n\njulia> # Automatically determined from `a`.\n       @model outer() = @submodel prefix=true a = inner()\nouter (generic function with 2 methods)\n\njulia> @varname(var\"a.x\") in keys(VarInfo(outer()))\ntrue\n\njulia> # Using a static string.\n       @model outer() = @submodel prefix=\"my prefix\" a = inner()\nouter (generic function with 2 methods)\n\njulia> @varname(var\"my prefix.x\") in keys(VarInfo(outer()))\ntrue\n\njulia> # Using string interpolation.\n       @model outer() = @submodel prefix=\"$(inner().name)\" a = inner()\nouter (generic function with 2 methods)\n\njulia> @varname(var\"inner.x\") in keys(VarInfo(outer()))\ntrue\n\njulia> # Or using some arbitrary expression.\n       @model outer() = @submodel prefix=1 + 2 a = inner()\nouter (generic function with 2 methods)\n\njulia> @varname(var\"3.x\") in keys(VarInfo(outer()))\ntrue\n\njulia> # (×) Automatic prefixing without a left-hand side expression does not work!\n       @model outer() = @submodel prefix=true inner()\nERROR: LoadError: cannot automatically prefix with no left-hand side\n[...]\n\nNotes\n\nThe choice prefix=expression means that the prefixing will incur a runtime cost. This is also the case for prefix=true, depending on whether the expression on the the right-hand side of ... = model requires runtime-information or not, e.g. x = model will result in the static prefix x, while x[i] = model will be resolved at runtime.\n\n\n\n\n\n","category":"macro"},{"location":"#DynamicPPL.@submodel-Tuple{Any}","page":"Home","title":"DynamicPPL.@submodel","text":"@submodel model\n@submodel ... = model\n\nRun a Turing model nested inside of a Turing model.\n\nExamples\n\njulia> @model function demo1(x)\n           x ~ Normal()\n           return 1 + abs(x)\n       end;\n\njulia> @model function demo2(x, y)\n            @submodel a = demo1(x)\n            return y ~ Uniform(0, a)\n       end;\n\nWhen we sample from the model demo2(missing, 0.4) random variable x will be sampled:\n\njulia> vi = VarInfo(demo2(missing, 0.4));\n\njulia> @varname(x) in keys(vi)\ntrue\n\nVariable a is not tracked since it can be computed from the random variable x that was tracked when running demo1:\n\njulia> @varname(a) in keys(vi)\nfalse\n\nWe can check that the log joint probability of the model accumulated in vi is correct:\n\njulia> x = vi[@varname(x)];\n\njulia> getlogp(vi) ≈ logpdf(Normal(), x) + logpdf(Uniform(0, 1 + abs(x)), 0.4)\ntrue\n\n\n\n\n\n","category":"macro"}]
}
