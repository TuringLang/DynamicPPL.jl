# TODO(mhauru) The policy of vectorising all values was set when the old VarInfo type was
# using a Vector as the internal storage in all cases. We should revisit this, and allow
# values to be stored "raw", since VarNamedTuple supports it.
#
# NOTE(penelopeysm): The main problem with unvectorising values is that when calling
# `unflatten!!`, it is not clear how many elements to take from the vector. In general
# we would need to know the distribution to get this data, which is fine if we are 
# executing the model, but `unflatten!!` does not have that information. As long as we
# depend on the behaviour of `unflatten!!` somewhere, we cannot get rid of it.

# TODO(mhauru) Related to the above, I think we should reconsider whether we should store
# transformations at all. We rarely use them, since they may be dynamic in a model.
# tilde_assume!! rather gets the transformation from the current distribution encountered
# during model execution. However, this would change the interface quite a lot, so I want to
# finish implementing VarInfo using VNT (mostly) respecting the old interface first.
#
# NOTE(penelopeysm) The above is in principle doable right now. the main issue with removing
# the transform is that we cannot get `varinfo[vn]` any more. It is arguable whether this
# method is really needed. On one hand, it is a pretty useful way of seeing the current
# value of a variable in the VarInfo. On the other hand, it is not guaranteed to be correct
# (because `unflatten!` might change the required transform); so one could argue that the
# question of "what is the true value" is generally unanswerable, and we should not expose a
# method that pretends to know the answer.. I would lean towards removing it, but doing so
# would require a fair amount of changes in the test suite, so it will have to wait for a
# time when fewer big PRs are ongoing.

"""
    AbstractTransformedValue

An abstract type for values that enter the DynamicPPL tilde-pipeline.

These values are generated by an [`AbstractInitStrategy`](@ref): the function
[`DynamicPPL.init`](@ref) should return an `AbstractTransformedValue`.

Each `AbstractTransformedValue` contains some version of the actual variable's value,
together with a transformation that can be used to convert the internal value back to the
original space.

Current subtypes are [`VectorValue`](@ref), [`LinkedVectorValue`](@ref), and
[`UntransformedValue`](@ref). DynamicPPL's [`VarInfo`](@ref) type stores either
`VectorValue`s or `LinkedVectorValue`s internally, depending on the link status of the
`VarInfo`.

!!! warning
    Even though the subtypes listed above are public, this abstract type is not itself part
    of the public API and should not be subtyped by end users. Much of DynamicPPL's model
    evaluation methods depends on these subtypes having predictable behaviour, i.e., their
    transforms should always be `from_linked_vec_transform(dist)`,
    `from_vec_transform(dist)`, or their inverse. If you create a new subtype of
    `AbstractTransformedValue` and use it, DynamicPPL will not know how to handle it and may
    either error or silently give incorrect results.

    In principle, it should be possible to subtype this and allow for custom transformations
    to be used (not just the 'default' ones). However, this is not currently implemented.

Subtypes of this should implement the following functions:

- `DynamicPPL.get_transform(tv::AbstractTransformedValue)`: Get the transformation that
  converts the internal value back to the original space.

- `DynamicPPL.get_internal_value(tv::AbstractTransformedValue)`: Get the internal value
  stored in `tv`.

- `DynamicPPL.update_value(tv::AbstractTransformedValue, new_val)`: Create a new
  `AbstractTransformedValue` with the same transformation as `tv`, but with internal value
  `new_val`.

- `DynamicPPL.VarNamedTuples.vnt_size(tv::AbstractTransformedValue)`: Get the size of the
  original value before transformation.

As a freebie, the function `DynamicPPL.get_true_value(tv::AbstractTransformedValue)` is also
defined (which applies the transformation to the internal value), as well as
`DynamicPPL.get_true_value_with_logjac(tv::AbstractTransformedValue)`, which also computes
the log-absolute-determinant of the Jacobian of the transformation.
"""
abstract type AbstractTransformedValue end
function get_true_value(tval::AbstractTransformedValue)
    return get_transform(tval)(get_internal_value(tval))
end
function get_true_value_with_logjac(tval::AbstractTransformedValue)
    return Bijectors.with_logabsdet_jacobian(get_transform(tval), get_internal_value(tval))
end

"""
    VectorValue{V<:AbstractVector,T,S}

A transformed value that stores its internal value as a vectorised form. This is what
VarInfo sees as an "unlinked value".

These values can be generated when using `InitFromParams` with a VarInfo's internal values.
"""
struct VectorValue{V<:AbstractVector,T,S} <: AbstractTransformedValue
    "The internal (vectorised) value."
    val::V
    """The unvectorisation transform required to convert `val` back to the original space.

    Note that this transform is cached and thus may be inaccurate if `unflatten!!` is called
    on the VarInfo containing this `VectorValue`. This transform is only ever used when
    calling `varinfo[vn]` to get the original value back; in all other cases, where model
    evaluation occurs, the correct transform is determined from the distribution associated
    with the variable."""
    transform::T
    """The size of the original value before transformation. This is needed when a
    `TransformedValue` is stored as a block in an array."""
    size::S
    function VectorValue(val::V, tfm::T, size::S) where {V<:AbstractVector,T,S}
        return new{V,T,S}(val, tfm, size)
    end
end

"""
    LinkedVectorValue{V<:AbstractVector,T,S}

A transformed value that stores its internal value as a linked andvectorised form. This is
what VarInfo sees as a "linked value".

These values can be generated when using `InitFromParams` with a VarInfo's internal values.
"""
struct LinkedVectorValue{V<:AbstractVector,T,S} <: AbstractTransformedValue
    "The internal (linked + vectorised) value."
    val::V
    """The unlinking transform required to convert `val` back to the original space.

    Note that this transform is cached and thus may be inaccurate if `unflatten!!` is called
    on the VarInfo containing this `VectorValue`. This transform is only ever used when
    calling `varinfo[vn]` to get the original value back; in all other cases, where model
    evaluation occurs, the correct transform is determined from the distribution associated
    with the variable."""
    transform::T
    """The size of the original value before transformation. This is needed when a
    `TransformedValue` is stored as a block in an array."""
    size::S
    function LinkedVectorValue(val::V, tfm::T, size::S) where {V<:AbstractVector,T,S}
        return new{V,T,S}(val, tfm, size)
    end
end

for T in (:VectorValue, :LinkedVectorValue)
    @eval begin
        function Base.:(==)(tv1::$T, tv2::$T)
            return (tv1.val == tv2.val) &
                   (tv1.transform == tv2.transform) &
                   (tv1.size == tv2.size)
        end
        function Base.isequal(tv1::$T, tv2::$T)
            return isequal(tv1.val, tv2.val) &&
                   isequal(tv1.transform, tv2.transform) &&
                   isequal(tv1.size, tv2.size)
        end
        VarNamedTuples.vnt_size(tv::$T) = tv.size

        get_transform(tv::$T) = tv.transform
        get_internal_value(tv::$T) = tv.val

        function update_value(tv::$T, new_val)
            return $T(new_val, tv.transform, tv.size)
        end
    end
end

"""
    UntransformedValue{V}

A raw, untransformed, value.

These values can be generated from initialisation strategies such as `InitFromPrior`,
`InitFromUniform`, and `InitFromParams` on a standard container type.
"""
struct UntransformedValue{V} <: AbstractTransformedValue
    "The value."
    val::V
    UntransformedValue(val::V) where {V} = new{V}(val)
end
is_transformed(::UntransformedValue) = false
VarNamedTuples.vnt_size(tv::UntransformedValue) = vnt_size(tv.val)
Base.:(==)(tv1::UntransformedValue, tv2::UntransformedValue) = tv1.val == tv2.val
Base.isequal(tv1::UntransformedValue, tv2::UntransformedValue) = isequal(tv1.val, tv2.val)
get_transform(::UntransformedValue) = typed_identity
get_internal_value(tv::UntransformedValue) = tv.val
