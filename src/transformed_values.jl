# TODO(mhauru) The policy of vectorising all values was set when the old VarInfo type was
# using a Vector as the internal storage in all cases. We should revisit this, and allow
# values to be stored "raw", since VarNamedTuple supports it.
#
# NOTE(penelopeysm): The main problem with unvectorising values is that when calling
# `unflatten!!`, it is not clear how many elements to take from the vector. In general
# we would need to know the distribution to get this data, which is fine if we are 
# executing the model, but `unflatten!!` does not have that information. As long as we
# depend on the behaviour of `unflatten!!` somewhere, we cannot get rid of it.

# TODO(mhauru) Related to the above, I think we should reconsider whether we should store
# transformations at all. We rarely use them, since they may be dynamic in a model.
# tilde_assume!! rather gets the transformation from the current distribution encountered
# during model execution. However, this would change the interface quite a lot, so I want to
# finish implementing VarInfo using VNT (mostly) respecting the old interface first.
#
# NOTE(penelopeysm) The above is in principle doable right now. the main issue with removing
# the transform is that we cannot get `varinfo[vn]` any more. It is arguable whether this
# method is really needed. On one hand, it is a pretty useful way of seeing the current
# value of a variable in the VarInfo. On the other hand, it is not guaranteed to be correct
# (because `unflatten!` might change the required transform); so one could argue that the
# question of "what is the true value" is generally unanswerable, and we should not expose a
# method that pretends to know the answer.. I would lean towards removing it, but doing so
# would require a fair amount of changes in the test suite, so it will have to wait for a
# time when fewer big PRs are ongoing.

"""
    AbstractTransformedValue

An abstract type for values that enter the DynamicPPL tilde-pipeline.

These values are generated by an [`AbstractInitStrategy`](@ref): the function
[`DynamicPPL.init`](@ref) should return an `AbstractTransformedValue`.

Each `AbstractTransformedValue` contains some version of the actual variable's value,
together with a transformation that can be used to convert the internal value back to the
original space.

Current subtypes are [`VectorValue`](@ref), [`LinkedVectorValue`](@ref), and
[`UntransformedValue`](@ref). DynamicPPL's [`VarInfo`](@ref) type stores either
`VectorValue`s or `LinkedVectorValue`s internally, depending on the link status of the
`VarInfo`.

!!! warning
    Even though the subtypes listed above are public, this abstract type is not itself part
    of the public API and should not be subtyped by end users. Much of DynamicPPL's model
    evaluation methods depends on these subtypes having predictable behaviour, i.e., their
    transforms should always be `from_linked_vec_transform(dist)`,
    `from_vec_transform(dist)`, or their inverse. If you create a new subtype of
    `AbstractTransformedValue` and use it, DynamicPPL will not know how to handle it and may
    either error or silently give incorrect results.

    In principle, it should be possible to subtype this and allow for custom transformations
    to be used (not just the 'default' ones). However, this is not currently implemented.

Subtypes of this should implement the following functions:

- `DynamicPPL.get_transform(tv::AbstractTransformedValue)`: Get the transformation that
  converts the internal value back to the original space.

- `DynamicPPL.get_internal_value(tv::AbstractTransformedValue)`: Get the internal value
  stored in `tv`.

- `DynamicPPL.set_internal_value(tv::AbstractTransformedValue, new_val)`: Create a new
  `AbstractTransformedValue` with the same transformation as `tv`, but with internal value
  `new_val`.
"""
abstract type AbstractTransformedValue end

"""
    get_transform(tv::AbstractTransformedValue)

Get the transformation that converts the internal value back to the raw value.

!!! warning
    If the distribution associated with the variable has changed since this
    `AbstractTransformedValue` was created, this transform may be inaccurate. This can
    happen e.g. if `unflatten!!` has been called on a VarInfo containing this.

    Consequently, when the distribution on the right-hand side of a tilde-statement is
    available, you should always prefer regenerating the transform from that distribution
    rather than using this function.
"""
function get_transform end

"""
    get_internal_value(tv::AbstractTransformedValue)

Get the internal value stored in `tv`.
"""
function get_internal_value end

"""
    set_internal_value(tv::AbstractTransformedValue, new_val)

Create a new `AbstractTransformedValue` with the same transformation as `tv`, but with
internal value `new_val`.
"""
function set_internal_value end

"""
    VectorValue{V<:AbstractVector,T}

A transformed value that stores its internal value as a vectorised form. This is what
VarInfo sees as an "unlinked value".

These values can be generated when using `InitFromParams` with a VarInfo's internal values.
"""
struct VectorValue{V<:AbstractVector,T} <: AbstractTransformedValue
    "The internal (vectorised) value."
    val::V
    """The unvectorisation transform required to convert `val` back to the original space.

    Note that this transform is cached and thus may be inaccurate if `unflatten!!` is called
    on the VarInfo containing this `VectorValue`. This transform is only ever used when
    calling `varinfo[vn]` to get the original value back; in all other cases, where model
    evaluation occurs, the correct transform is determined from the distribution associated
    with the variable."""
    transform::T
    function VectorValue(val::V, tfm::T) where {V<:AbstractVector,T}
        return new{V,T}(val, tfm)
    end
end
function VectorValue(val::AbstractVector, dist::Distribution)
    return VectorValue(val, from_vec_transform(dist))
end

"""
    LinkedVectorValue{V<:AbstractVector,T}

A transformed value that stores its internal value as a linked and vectorised form. This is
what VarInfo sees as a "linked value".

These values can be generated when using `InitFromParams` with a VarInfo's internal values.
"""
struct LinkedVectorValue{V<:AbstractVector,T} <: AbstractTransformedValue
    "The internal (linked + vectorised) value."
    val::V
    """The unlinking transform required to convert `val` back to the original space.

    Note that this transform is cached and thus may be inaccurate if `unflatten!!` is called
    on the VarInfo containing this `VectorValue`. This transform is only ever used when
    calling `varinfo[vn]` to get the original value back; in all other cases, where model
    evaluation occurs, the correct transform is determined from the distribution associated
    with the variable."""
    transform::T
    function LinkedVectorValue(val::V, tfm::T) where {V<:AbstractVector,T}
        return new{V,T}(val, tfm)
    end
end
function LinkedVectorValue(val::AbstractVector, dist::Distribution)
    return LinkedVectorValue(val, from_linked_vec_transform(dist))
end

for T in (:VectorValue, :LinkedVectorValue)
    @eval begin
        function Base.:(==)(tv1::$T, tv2::$T)
            return (tv1.val == tv2.val) & (tv1.transform == tv2.transform)
        end
        function Base.isequal(tv1::$T, tv2::$T)
            return isequal(tv1.val, tv2.val) && isequal(tv1.transform, tv2.transform)
        end

        get_transform(tv::$T) = tv.transform
        get_internal_value(tv::$T) = tv.val

        function set_internal_value(tv::$T, new_val)
            return $T(new_val, tv.transform)
        end
        function set_internal_transform(tv::$T, dist::Distribution)
            return $T(tv.val, dist)
        end
    end
end

"""
    UntransformedValue{V}

A raw, untransformed, value.

These values can be generated from initialisation strategies such as `InitFromPrior`,
`InitFromUniform`, and `InitFromParams` on a standard container type.
"""
struct UntransformedValue{V} <: AbstractTransformedValue
    "The value."
    val::V
    UntransformedValue(val::V) where {V} = new{V}(val)
end
Base.:(==)(tv1::UntransformedValue, tv2::UntransformedValue) = tv1.val == tv2.val
Base.isequal(tv1::UntransformedValue, tv2::UntransformedValue) = isequal(tv1.val, tv2.val)
get_transform(::UntransformedValue) = typed_identity
get_internal_value(tv::UntransformedValue) = tv.val
set_internal_value(::UntransformedValue, new_val) = UntransformedValue(new_val)
set_internal_transform(tv::UntransformedValue, ::Distribution) = tv

"""
    abstract type AbstractTransform end

An abstract type to represent the intended transformation for a variable.
"""
abstract type AbstractTransform end

"""
    DynamicLink <: AbstractTransform

A type indicating that a target transformation should be derived by recomputing the invlink
transform from the distribution on the right-hand side of the tilde.
"""
struct DynamicLink <: AbstractTransform end

"""
    Unlink <: AbstractTransform

A type indicating that the target transformation should be nothing.
"""
struct Unlink <: AbstractTransform end

"""
    abstract type AbstractTransformStrategy end

An abstract type for strategies that determine how each variable should be transformed.

For subtypes of `AbstractTransformStrategy`, the only method that needs to be overloaded is
[`DynamicPPL.target_transform(::AbstractTransformStrategy, vn::VarName)`](@ref
DynamicPPL.target_transform), which returns an [`AbstractTransform`](@ref) that
specifies how the variable with name `vn` should be transformed.

The transform strategy dictates how the log-Jacobian is accumulated during model evaluation.
Regardless of what initialisation strategy is used (and what kind of transformed value
`init()` returns, the log-Jacobian that is accumulated is always the log-Jacobian for the
forward transform specified by `target_transform(strategy, vn)`.

That is, even if `init()` returns an `UntransformedValue`, if the transform strategy is
`LinkAll()` (which returns `DynamicLink` for all variables), then the log-Jacobian for
linking will be accumulated during model evaluation.

Subtypes in DynamicPPL are [`LinkAll`](@ref), [`UnlinkAll`](@ref), [`LinkSome`](@ref), and
[`UnlinkSome`](@ref).
"""
abstract type AbstractTransformStrategy end

"""
    target_transform(linker::AbstractTransformStrategy, vn::VarName)

Determine whether a variable with name `vn` should be linked according to the `linker`
strategy. Returns `DynamicLink()` if the variable should be linked, or `Unlink()` if it
should not.

This function can in the future be extended to support fixed transformations.
"""
function target_transform end

"""
    LinkAll() <: AbstractTransformStrategy

Indicate that all variables should be linked.
"""
struct LinkAll <: AbstractTransformStrategy end
target_transform(::LinkAll, ::VarName) = DynamicLink()

"""
    UnlinkAll() <: AbstractTransformStrategy

Indicate that all variables should be unlinked.
"""
struct UnlinkAll <: AbstractTransformStrategy end
target_transform(::UnlinkAll, ::VarName) = Unlink()

"""
    LinkSome(vns::Set{<:VarName}, fallback) <: AbstractTransformStrategy

Indicate that the variables in `vns` must be linked. The link statuses of other variables
are determined by the `fallback` strategy.
"""
struct LinkSome{V<:Set{<:VarName},L<:AbstractTransformStrategy} <: AbstractTransformStrategy
    vns::V
    fallback::L
end
LinkSome(::Set{<:VarName}, ::LinkAll) = LinkAll()
function target_transform(linker::LinkSome, vn::VarName)
    return if any(linker_vn -> subsumes(linker_vn, vn), linker.vns)
        DynamicLink()
    else
        target_transform(linker.fallback, vn)
    end
end
function Base.:(==)(ls1::LinkSome, ls2::LinkSome)
    return (ls1.vns == ls2.vns) & (ls1.fallback == ls2.fallback)
end
function Base.isequal(ls1::LinkSome, ls2::LinkSome)
    return isequal(ls1.vns, ls2.vns) && isequal(ls1.fallback, ls2.fallback)
end

"""
    UnlinkSome(vns::Set{<:VarName}, fallback) <: AbstractTransformStrategy

Indicate that the variables in `vns` must not be linked. The link statuses of other
variables are determined by the `fallback` strategy.
"""
struct UnlinkSome{V<:Set{<:VarName},L<:AbstractTransformStrategy} <:
       AbstractTransformStrategy
    vns::V
    fallback::L
end
UnlinkSome(::Set{<:VarName}, ::UnlinkAll) = UnlinkAll()
function target_transform(linker::UnlinkSome, vn::VarName)
    return if any(linker_vn -> subsumes(linker_vn, vn), linker.vns)
        Unlink()
    else
        target_transform(linker.fallback, vn)
    end
end
UnlinkSome(::Any, ::UnlinkAll) = UnlinkAll()
function Base.:(==)(us1::UnlinkSome, us2::UnlinkSome)
    return (us1.vns == us2.vns) & (us1.fallback == us2.fallback)
end
function Base.isequal(us1::UnlinkSome, us2::UnlinkSome)
    return isequal(us1.vns, us2.vns) && isequal(us1.fallback, us2.fallback)
end

"""
    DynamicPPL.apply_transform_strategy(
        strategy::AbstractTransformStrategy,
        tv::AbstractTransformedValue,
        vn::VarName,
        dist::Distribution,
    )

Apply the given `strategy` to the transformed value `tv` for a tilde-statement `vn ~ dist`.

Specifically, this function does a number of things:

- Calculates the raw value associated with `tv`.

- Checks whether the `strategy` expects the VarName `vn` to be linked or unlinked. If the
  current link status of `tv` matches the expected link status, `tv` is returned unchanged.
  Otherwise, either linking or unlinking is applied as necessary. Note that this function
  does not perform vectorisation unless it is needed.

  A table summarising the possible transformations is as follows:

  | tv isa ...          | `target_transform(...) isa DynamicLink` | `target_transform(...) isa Unlink` |
  |---------------------|---------------------------------|------------------------------------|
  | `LinkedVectorValue` | -> `LinkedVectorValue`          | -> `UntransformedValue`            |
  | `VectorValue`       | -> `LinkedVectorValue`          | -> `VectorValue`                   |
  | `UntransformedValue`| -> `LinkedVectorValue`          | -> `UntransformedValue`            |

- If `vn` is supposed to be linked, calculates the associated log-Jacobian adjustment for
  the **forward** linking transformation (i.e., from unlinked to linked).

This function returns a tuple of `(raw_value, new_tv, logjac)`.

!!! note
    This function is therefore the single source of truth for whether `logjac` should be
    incremented during model evaluation.
"""
function apply_transform_strategy(
    strategy::AbstractTransformStrategy,
    tv::AbstractTransformedValue,
    vn::VarName,
    dist::Distribution,
)
    target = target_transform(strategy, vn)
    raw_value = get_raw_value(tv, dist)
    return apply_transform(raw_value, target, tv, dist)
end

function apply_transform(
    ::Any, target::AbstractTransform, ::AbstractTransformedValue, ::Distribution
)
    return error("unknown target transform $target")
end

function get_raw_value(tv::Union{LinkedVectorValue,UntransformedValue}, ::Distribution)
    return get_internal_value(tv)
end
function get_raw_value(tv::VectorValue, dist::Distribution)
    invlink = from_vec_transform(dist)
    return invlink(get_internal_value(tv))
end

function apply_transform(
    raw_value, ::Unlink, tv::Union{VectorValue,UntransformedValue}, dist::Distribution
)
    return (raw_value, tv, zero(LogProbType))
end
function apply_transform(raw_value, ::Unlink, ::LinkedVectorValue, dist::Distribution)
    finvlink = from_linked_vec_transform(dist)
    linked_value = finvlink(raw_value)
    return (linked_value, UntransformedValue(linked_value), zero(LogProbType))
end

function apply_transform(
    raw_value, ::DynamicLink, tv::Union{VectorValue,UntransformedValue}, dist::Distribution
)
    flink = to_linked_vec_transform(dist)
    linked_value, logjac = with_logabsdet_jacobian(flink, raw_value)
    finvlink = from_linked_vec_transform(dist)
    linked_tv = LinkedVectorValue(linked_value, finvlink)
    return (raw_value, linked_tv, logjac)
end
function apply_transform(
    raw_value, ::DynamicLink, tv::LinkedVectorValue, dist::Distribution
)
    finvlink = from_linked_vec_transform(dist)
    unlinked_value, inv_logjac = with_logabsdet_jacobian(finvlink, raw_value)
    return (unlinked_value, tv, -inv_logjac)
end
