<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DynamicPPL</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body>
<!-- NAVBAR START -->
<style>
    @import url('https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap');

    /* Documenter.jl CSS Overrides */
    html {
        scroll-padding-top: calc(var(--navbar-height) + 1rem);
    }
    .docs-sidebar, #documenter {
        margin-top: var(--navbar-height);
    }
    .docs-version-selector {
        margin-bottom: 60px !important;
    }
    @media screen and (max-width: 1056px) {
        .docs-version-selector {
            margin-bottom: 60px !important;
        }
        .docs-sidebar {
            margin-top: 0 !important;
        }
    }
    /* End of Documenter.jl Tweaks */

    /* Color and Font Variables */
    :root {
        --heading-color: #6c757d;
        --item-color: rgb(165, 165, 165);
        --primary-bg: white;
        --hover-color: #8faad2;
        --deprecated-bg: #ff4d4d;
        --deprecated-text: white;
        --icon-color: #6c757d;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --dropdown-hover-bg: #e9ecef;
        
        /* Typography */
        --font-family: "Source Sans Pro", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        --nav-link-font-size: 1.0625rem;
        --turing-title-font-size: 21.25px;
        --icon-font-size: 1.25rem;
        --dropdown-arrow-font-size: 0.6875rem;
        --badge-font-size: 0.75rem;

        /* Sizing and Spacing */
        --navbar-height: 3.75rem;
        --logo-height: 31px;
        --logo-width: auto;
        --logo-padding-top: 7px;
        --logo-margin-left: 0.8rem;
        --title-margin-left: 0.4px;
        --title-nav-spacing: 1.1rem;
        --nav-item-margin-left: 1.3rem;
        --icon-margin-left: 1rem;
        --dropdown-padding: 1.875rem;
        --dropdown-item-width: 12.5rem;
        --dropdown-subitem-width: 15.625rem;
        --dropdown-subitem-padding: 0.125rem 0.625rem;
    }

    /* Dark Theme Variable Overrides */
    html.theme--documenter-dark {
        --heading-color: #e0e0e0;
        --item-color: #bdbdbd;
        --primary-bg: #1f2424;
        --hover-color: #ffffff;
        --icon-color: #e0e0e0;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #424242;
    }

    /* Catppuccin Theme Overrides */
    html.theme--catppuccin-latte {
        --heading-color: #4c4f69;
        --primary-bg: #eff1f5;
        --icon-color: #4c4f69;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --dropdown-hover-bg: #e6e9ef;
    }
    html.theme--catppuccin-frappe {
        --heading-color: #c6d0f5;
        --primary-bg: #303446;
        --icon-color: #c6d0f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #51576d;
    }
    html.theme--catppuccin-macchiato {
        --heading-color: #cad3f5;
        --primary-bg: #24273a;
        --icon-color: #cad3f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #494d64;
    }
    html.theme--catppuccin-mocha {
        --heading-color: #cad3f5;
        --primary-bg: #1e1e2e;
        --icon-color: #cad3f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #45475a;
    }


    /* Main Navigation Bar */
    .ext-navigation {
        font-family: var(--font-family);
        position: fixed;
        height: var(--navbar-height);
        top: 0;
        width: 100%;
        background-color: var(--primary-bg);
        z-index: 1000;
        box-shadow: 0 2px 4px var(--shadow-color);
        display: flex;
        align-items: center;
        padding: 0 1.0625rem;
        transition: transform 0.3s, background-color 0.3s;
    }

    nav.ext-navigation .ext-navbar-logo {
        margin-left: var(--logo-margin-left);
        height: auto;
        max-height: var(--logo-height);
        width: auto;
        padding-top: var(--logo-padding-top);
    }
    
    /* Theme-aware logo text color */
    .ext-navbar-logo .logo-text {
        fill: var(--heading-color);
    }
    
    .ext-navbar-title {
        color: var(--heading-color) !important;
        font-size: var(--turing-title-font-size) !important;
        margin-left: var(--title-margin-left);
        text-decoration: none;
        transition: color 0.2s ease;
    }
    
    .ext-navbar-title:hover {
        color: var(--hover-color) !important;
    }

    .ext-nav-links {
        display: flex;
        align-items: center;
        list-style-type: none;
        margin: 0;
        padding: 0;
        flex-grow: 1;
        margin-left: var(--title-nav-spacing);
    }

    .ext-nav-links li:first-child {
        margin-left: 0 !important;
    }

    .ext-nav-links li {
        margin-left: var(--nav-item-margin-left) !important;
    }

    .ext-nav-link {
        color: var(--heading-color) !important;
        text-decoration: none;
        font-size: var(--nav-link-font-size) !important;
        transition: color 0.2s ease;
        cursor: pointer;
    }

    .ext-nav-link:hover,
    .ext-navbar-item-single a:hover,
    .ext-navbar-icons a:hover {
        color: var(--hover-color) !important;
    }

    .ext-navbar-item-single a {
        color: var(--heading-color) !important;
    }
    
    .ext-navbar-icons {
        display: flex;
        align-items: center;
    }

    .ext-navbar-icons a {
        color: var(--icon-color) !important;
        font-size: var(--icon-font-size) !important;
        transition: color 0.2s ease;
        margin-left: var(--icon-margin-left);
    }

    .ext-menu-toggle {
        display: none;
        font-size: 1.5rem;
        color: var(--heading-color);
        cursor: pointer;
    }

    .ext-dropdown {
        display: none;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        padding: var(--dropdown-padding);
        position: absolute;
        top: var(--navbar-height);
        width: 100%;
        left: 0;
        background-color: var(--primary-bg);
        line-height: 1.875rem;
        opacity: 0;
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out, background-color 0.3s;
        transform: translateY(-0.625rem);
        box-shadow: 0 4px 6px var(--shadow-color);
    }

    #library-handler::after {
        content: "▼";
        font-size: var(--dropdown-arrow-font-size);
        margin-left: 0.3125rem;
        transition: transform 0.3s ease-in-out;
    }

    #library-handler.open::after {
        content: "▲";
    }

    .ext-dropdown.show {
        display: grid;
        opacity: 1;
        transform: translateY(0);
    }

    .ext-dropdown ul {
        width: var(--dropdown-item-width);
        margin-bottom: 1.25rem;
    }

    .ext-dropdown ul li {
        text-align: left;
        display: flex;
        align-items: center;
    }

    .ext-dropdown ul a li {
        color: var(--item-color);
        width: var(--dropdown-subitem-width);
        border-radius: 3px;
        padding: var(--dropdown-subitem-padding);
        transition: background-color 0.2s ease;
    }

    .ext-dropdown ul a li:hover {
        background-color: var(--dropdown-hover-bg);
    }

    .ext-dropdown-item-heading {
        color: var(--heading-color);
        text-align: center;
    }

    .deprecated-badge {
        background-color: var(--deprecated-bg);
        color: var(--deprecated-text);
        font-size: var(--badge-font-size);
        padding: .1rem;
        border-radius: 3px;
        margin-left: 0.5rem;
        line-height: 1;
    }

    @media (max-width: 966px) {
        .ext-dropdown {
            grid-template-columns: 1fr 1fr 1fr;
        }
    }

    @media (max-width: 768px) {
        .ext-nav-links {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            background-color: var(--primary-bg);
            position: absolute;
            top: var(--navbar-height);
            left: 0;
            padding: 0.625rem 0;
            height: auto;
            overflow-y: auto;
            box-shadow: 0 4px 6px var(--shadow-color);
            margin-left: 0;
        }

        .ext-nav-links.show {
            display: flex;
        }

        .ext-nav-links li {
            margin: 0.625rem 0 !important;
            text-align: center;
        }
        
        .ext-menu-toggle {
            display: block;
            margin-left: auto;
        }

        .ext-navigation.hide {
            transform: translateY(calc(-1 * var(--navbar-height)));
        }

        .ext-dropdown {
            position: static;
            display: block;
            opacity: 1;
            transform: none;
            box-shadow: none;
            grid-template-columns: 1fr;
            padding: 0.625rem;
            text-align: center;
        }

        .ext-dropdown ul {
            width: auto;
            display: inline-block;
            margin: 0 auto 0.3125rem;
            text-align: left;
        }
    }
</style>
<nav class="ext-navigation">
    <a href="https://turinglang.org/">
        <svg width="4333" height="1145" viewBox="0 0 4333 1145" fill="none" xmlns="http://www.w3.org/2000/svg" class="ext-navbar-logo">
            <path class="logo-text" d="M0.44603 193.181V66.9868H663.471V193.181H406.62V898H257.297V193.181H0.44603ZM1097.24 635.874V274.74H1244.13V898H1101.7V787.225H1095.21C1081.14 822.121 1058.01 850.66 1025.82 872.842C993.902 895.024 954.542 906.115 907.744 906.115C866.896 906.115 830.783 897.053 799.403 878.929C768.295 860.534 743.948 833.889 726.365 798.993C708.782 763.826 699.99 721.356 699.99 671.581V274.74H846.878V648.858C846.878 688.353 857.699 719.733 879.34 742.997C900.981 766.261 929.385 777.893 964.551 777.893C986.192 777.893 1007.16 772.618 1027.45 762.068C1047.73 751.518 1064.37 735.828 1077.35 714.999C1090.61 693.899 1097.24 667.524 1097.24 635.874ZM1395.17 898V274.74H1537.6V378.617H1544.09C1555.45 342.639 1574.93 314.911 1602.52 295.434C1630.38 275.687 1662.17 265.813 1697.88 265.813C1705.99 265.813 1715.05 266.219 1725.06 267.031C1735.34 267.572 1743.86 268.518 1750.63 269.871V404.992C1744.4 402.828 1734.53 400.934 1721 399.311C1707.75 397.417 1694.9 396.471 1682.46 396.471C1655.68 396.471 1631.6 402.287 1610.23 413.919C1589.13 425.28 1572.49 441.105 1560.32 461.393C1548.15 481.682 1542.06 505.081 1542.06 531.591V898H1395.17ZM1848.21 898V274.74H1995.1V898H1848.21ZM1922.06 186.283C1898.8 186.283 1878.78 178.573 1862.01 163.154C1845.24 147.464 1836.85 128.664 1836.85 106.752C1836.85 84.5701 1845.24 65.7695 1862.01 50.3503C1878.78 34.6606 1898.8 26.8158 1922.06 26.8158C1945.6 26.8158 1965.61 34.6606 1982.12 50.3503C1998.89 65.7695 2007.27 84.5701 2007.27 106.752C2007.27 128.664 1998.89 147.464 1982.12 163.154C1965.61 178.573 1945.6 186.283 1922.06 186.283ZM2293.04 532.809V898H2146.15V274.74H2286.54V380.646H2293.85C2308.18 345.75 2331.04 318.022 2362.42 297.463C2394.07 276.904 2433.16 266.625 2479.69 266.625C2522.7 266.625 2560.17 275.822 2592.09 294.217C2624.28 312.612 2649.17 339.257 2666.75 374.153C2684.6 409.049 2693.39 451.385 2693.12 501.159V898H2546.24V523.882C2546.24 482.223 2535.41 449.626 2513.77 426.092C2492.4 402.557 2462.78 390.79 2424.91 390.79C2399.21 390.79 2376.35 396.471 2356.34 407.832C2336.59 418.923 2321.03 435.019 2309.67 456.119C2298.58 477.218 2293.04 502.782 2293.04 532.809ZM3113.5 1144.71C3060.75 1144.71 3015.44 1137.54 2977.57 1123.2C2939.7 1109.13 2909.26 1090.2 2886.27 1066.39C2863.28 1042.59 2847.32 1016.21 2838.39 987.269L2970.67 955.213C2976.62 967.386 2985.28 979.424 2996.64 991.327C3008 1003.5 3023.28 1013.51 3042.49 1021.35C3061.97 1029.47 3086.45 1033.53 3115.93 1033.53C3157.59 1033.53 3192.08 1023.38 3219.4 1003.09C3246.73 983.076 3260.39 950.074 3260.39 904.087V786.008H3253.08C3245.51 801.157 3234.42 816.711 3219.81 832.671C3205.47 848.632 3186.4 862.022 3162.6 872.842C3139.06 883.663 3109.44 889.073 3073.73 889.073C3025.85 889.073 2982.44 877.847 2943.48 855.394C2904.8 832.671 2873.96 798.857 2850.97 753.952C2828.24 708.777 2816.88 652.24 2816.88 584.341C2816.88 515.902 2828.24 458.147 2850.97 411.078C2873.96 363.739 2904.93 327.896 2943.89 303.55C2982.84 278.933 3026.26 266.625 3074.14 266.625C3110.66 266.625 3140.69 272.847 3164.22 285.29C3188.03 297.463 3206.96 312.206 3221.03 329.519C3235.09 346.561 3245.78 362.657 3253.08 377.805H3261.2V274.74H3406.06V908.144C3406.06 961.435 3393.34 1005.53 3367.92 1040.42C3342.49 1075.32 3307.73 1101.43 3263.63 1118.74C3219.54 1136.05 3169.5 1144.71 3113.5 1144.71ZM3114.72 773.835C3145.83 773.835 3172.34 766.261 3194.25 751.112C3216.16 735.963 3232.79 714.187 3244.16 685.783C3255.52 657.379 3261.2 623.295 3261.2 583.53C3261.2 544.305 3255.52 509.95 3244.16 480.465C3233.07 450.979 3216.56 428.12 3194.65 411.89C3173.01 395.389 3146.37 387.138 3114.72 387.138C3081.98 387.138 3054.66 395.659 3032.75 412.701C3010.84 429.744 2994.34 453.143 2983.25 482.899C2972.16 512.385 2966.61 545.929 2966.61 583.53C2966.61 621.672 2972.16 655.08 2983.25 683.754C2994.61 712.158 3011.25 734.34 3033.16 750.3C3055.34 765.99 3082.53 773.835 3114.72 773.835ZM3647.08 906.927C3622.47 906.927 3601.37 898.271 3583.78 880.958C3566.2 863.645 3557.54 842.545 3557.82 817.658C3557.54 793.312 3566.2 772.482 3583.78 755.17C3601.37 737.857 3622.47 729.2 3647.08 729.2C3670.89 729.2 3691.58 737.857 3709.17 755.17C3727.02 772.482 3736.08 793.312 3736.35 817.658C3736.08 834.159 3731.75 849.173 3723.37 862.698C3715.25 876.224 3704.43 887.044 3690.91 895.16C3677.65 903.004 3663.04 906.927 3647.08 906.927ZM3888.01 274.74H4034.9V933.708C4034.9 978.613 4026.38 1015.67 4009.33 1044.89C3992.29 1074.1 3967.67 1095.88 3935.48 1110.22C3903.29 1124.55 3864.2 1131.72 3818.22 1131.72C3812.81 1131.72 3807.8 1131.59 3803.2 1131.32C3798.6 1131.32 3793.6 1131.18 3788.19 1130.91V1011.21C3792.25 1011.48 3795.9 1011.62 3799.15 1011.62C3802.39 1011.89 3805.77 1012.02 3809.29 1012.02C3837.42 1012.02 3857.58 1005.12 3869.75 991.327C3881.92 977.801 3888.01 957.918 3888.01 931.679V274.74ZM3961.05 186.283C3937.51 186.283 3917.36 178.573 3900.59 163.154C3884.09 147.464 3875.84 128.664 3875.84 106.752C3875.84 84.5701 3884.09 65.7695 3900.59 50.3503C3917.36 34.6606 3937.51 26.8158 3961.05 26.8158C3984.31 26.8158 4004.19 34.6606 4020.7 50.3503C4037.47 65.7695 4045.85 84.5701 4045.85 106.752C4045.85 128.664 4037.47 147.464 4020.7 163.154C4004.19 178.573 3984.31 186.283 3961.05 186.283ZM4332.83 66.9868V898H4185.94V66.9868H4332.83Z" fill="currentColor"/>
            <path d="M4076 108.5C4076 168.424 4027.42 217 3967.5 217C3907.58 217 3859 168.424 3859 108.5C3859 48.5762 3907.58 0 3967.5 0C4027.42 0 4076 48.5762 4076 108.5Z" fill="#389725"/>
            <path d="M3755 814.5C3755 874.424 3706.42 923 3646.5 923C3586.58 923 3538 874.424 3538 814.5C3538 754.576 3586.58 706 3646.5 706C3706.42 706 3755 754.576 3755 814.5Z" fill="#9457B1"/>
            <path d="M2030 108.5C2030 168.424 1981.42 217 1921.5 217C1861.58 217 1813 168.424 1813 108.5C1813 48.5762 1861.58 0 1921.5 0C1981.42 0 2030 48.5762 2030 108.5Z" fill="#CA3B33"/>
        </svg>
    </a>
    <!-- <a class="ext-navbar-title" href="https://turinglang.org/">Turing.jl</a> -->
    
    <ul class="ext-nav-links">
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/getting-started/">Get Started</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/tutorials/">Tutorials</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/faq/">FAQ</a></li>
        <li>
            <p class="ext-nav-link" id="library-handler">Libraries</p>
            <div class="ext-dropdown" id="ext-dropdown-items">
                <ul>
                    <li class="ext-dropdown-item-heading">Modelling Languages</li>
                    <a href="https://turinglang.org/DynamicPPL.jl/"><li>DynamicPPL</li></a>
                    <a href="https://turinglang.org/JuliaBUGS.jl/"><li>JuliaBUGS</li></a>
                    <a href="https://turinglang.org/TuringGLM.jl/"><li>TuringGLM</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">MCMC</li>
                    <a href="https://turinglang.org/AdvancedHMC.jl/"><li>AdvancedHMC</li></a>
                    <a href="https://turinglang.org/AbstractMCMC.jl/"><li>AbstractMCMC</li></a>
                    <a href="https://github.com/theogf/ThermodynamicIntegration.jl"><li>ThermodynamicIntegration</li></a>
                    <a href="https://turinglang.org/AdvancedPS.jl/"><li>AdvancedPS</li></a>
                    <a href="https://turinglang.org/SliceSampling.jl/"><li>SliceSampling</li></a>
                    <a href="https://turinglang.org/EllipticalSliceSampling.jl/"><li>EllipticalSliceSampling</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">Diagnostics</li>
                    <a href="https://turinglang.org/MCMCChains.jl/"><li>MCMCChains</li></a>
                    <a href="https://turinglang.org/MCMCDiagnosticTools.jl/"><li>MCMCDiagnosticTools</li></a>
                    <a href="https://chalk-lab.github.io/ParetoSmooth.jl/"><li>ParetoSmooth</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">Gaussian Processes</li>
                    <a href="https://juliagaussianprocesses.github.io/AbstractGPs.jl/"><li>AbstractGPs</li></a>
                    <a href="https://juliagaussianprocesses.github.io/KernelFunctions.jl/"><li>KernelFunctions</li></a>
                    <a href="https://juliagaussianprocesses.github.io/ApproximateGPs.jl/"><li>ApproximateGPs</li></a>
                </ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/Bijectors.jl/">Bijectors</a></li></ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/TuringCallbacks.jl/">TuringCallbacks</a></li></ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/Deprecated/TuringBenchmarking/">TuringBenchmarking</a><span class="deprecated-badge">Deprecated</span></li></ul>
            </div>
        </li>
        <li><a class="ext-nav-link" href="https://turinglang.org/news/">News</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/team/">Team</a></li>
    </ul>

    <div class="ext-navbar-icons">
        <a href="https://x.com/TuringLang" aria-label="Turing on X"><i class="fa-brands fa-x-twitter"></i></a>
        <a href="https://discourse.julialang.org/c/domain/probprog/48" aria-label="Turing on Discourse"><i class="fa-brands fa-discourse"></i></a>
        <a href="https://julialang.slack.com/archives/CCYDC34A0" aria-label="Turing on Slack"><i class="fa-brands fa-slack"></i></a>
        <a href="https://github.com/TuringLang/" aria-label="Turing.jl on GitHub"><i class="fa-brands fa-github"></i></a>
    </div>

    <span class="ext-menu-toggle"><i class="fa-solid fa-bars"></i></span>
</nav>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const menuToggle = document.querySelector(".ext-menu-toggle");
        const navLinks = document.querySelector(".ext-nav-links");
        const nav = document.querySelector(".ext-navigation");
        const libraryHandler = document.getElementById("library-handler");
        const dropdownContainer = document.getElementById("ext-dropdown-items");
        let lastScrollY = window.scrollY;

        function closeDropdown() {
            if (dropdownContainer.classList.contains("show")) {
                libraryHandler.classList.remove("open");
                dropdownContainer.classList.remove("show");
                setTimeout(() => {
                    if (!dropdownContainer.classList.contains("show")) {
                        dropdownContainer.style.display = "none";
                    }
                }, 300);
            }
        }

        function openDropdown() {
            dropdownContainer.style.display = "grid";
            libraryHandler.classList.add("open");
            setTimeout(() => {
                dropdownContainer.classList.add("show");
            }, 10);
        }

        function setAppropriateHeight() {
            if (window.innerWidth <= 768) {
                const viewportHeight = window.innerHeight;
                const navHeight = nav.offsetHeight;
                navLinks.style.maxHeight = `${viewportHeight - navHeight}px`;
                navLinks.style.overflowY = "auto";
            } else {
                navLinks.style.maxHeight = "";
                navLinks.style.overflowY = "";
            }
        }

        menuToggle.addEventListener("click", (event) => {
            event.stopPropagation();
            navLinks.classList.toggle("show");
            if (navLinks.classList.contains("show")) {
                setAppropriateHeight();
                closeDropdown();
                dropdownContainer.style.display = "none";
            }
        });

        libraryHandler.addEventListener("click", (event) => {
            event.stopPropagation();
            event.preventDefault();
            if (dropdownContainer.classList.contains("show")) {
                closeDropdown();
            } else {
                openDropdown();
            }
            setAppropriateHeight();
        });

        // Close all menus if a click is registered outside the navigation bar.
        document.addEventListener("click", (event) => {
            if (!nav.contains(event.target)) {
                navLinks.classList.remove("show");
                closeDropdown();
            }
        });

        // Hide navigation bar on scroll down in mobile view.
        window.addEventListener("scroll", () => {
            if (window.innerWidth <= 768) {
                if (window.scrollY > lastScrollY && window.scrollY > nav.offsetHeight){
                    nav.classList.add("hide");
                } else {
                    nav.classList.remove("hide");
                }
                lastScrollY = window.scrollY;
            }
        });

        window.addEventListener("resize", setAppropriateHeight);
    });
</script>
<!-- NAVBAR END -->



<div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>DynamicPPL</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="test_utils/">TestUtils</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/TuringLang/DynamicPPL.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DynamicPPL"><a class="docs-heading-anchor" href="#DynamicPPL">DynamicPPL</a><a id="DynamicPPL-1"></a><a class="docs-heading-anchor-permalink" href="#DynamicPPL" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.AbstractVarInfo" href="#DynamicPPL.AbstractVarInfo"><code>DynamicPPL.AbstractVarInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVarInfo</code></pre><p>Abstract supertype for data structures that capture random variables when executing a probabilistic model and accumulate log densities such as the log likelihood or the log joint probability of the model.</p><p>See also: <a href="#DynamicPPL.VarInfo"><code>VarInfo</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/DynamicPPL.jl#L125-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.DefaultContext" href="#DynamicPPL.DefaultContext"><code>DynamicPPL.DefaultContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DefaultContext &lt;: AbstractContext end</code></pre><p>The <code>DefaultContext</code> is used by default to compute log the joint probability of the data  and parameters when running the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.IsLeaf" href="#DynamicPPL.IsLeaf"><code>DynamicPPL.IsLeaf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsLeaf</code></pre><p>Specifies that the context is a leaf in the context-tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.IsParent" href="#DynamicPPL.IsParent"><code>DynamicPPL.IsParent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsParent</code></pre><p>Specifies that the context is a parent in the context-tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.LikelihoodContext" href="#DynamicPPL.LikelihoodContext"><code>DynamicPPL.LikelihoodContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LikelihoodContext{Tvars} &lt;: AbstractContext
    vars::Tvars
end</code></pre><p>The <code>LikelihoodContext</code> enables the computation of the log likelihood of the parameters when  running the model. <code>vars</code> can be used to evaluate the log likelihood for specific values  of the model&#39;s parameters. If <code>vars</code> is <code>nothing</code>, the parameter values inside the <code>VarInfo</code> will be used by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L189-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.Metadata" href="#DynamicPPL.Metadata"><code>DynamicPPL.Metadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>Metadata</code> struct stores some metadata about the parameters of the model. This helps query certain information about a variable, such as its distribution, which samplers sample this variable, its value and whether this value is transformed to real space or not.</p><p>Let <code>md</code> be an instance of <code>Metadata</code>:</p><ul><li><code>md.vns</code> is the vector of all <code>VarName</code> instances.</li><li><code>md.idcs</code> is the dictionary that maps each <code>VarName</code> instance to its index in</li></ul><p><code>md.vns</code>, <code>md.ranges</code> <code>md.dists</code>, <code>md.orders</code> and <code>md.flags</code>.</p><ul><li><code>md.vns[md.idcs[vn]] == vn</code>.</li><li><code>md.dists[md.idcs[vn]]</code> is the distribution of <code>vn</code>.</li><li><code>md.gids[md.idcs[vn]]</code> is the set of algorithms used to sample <code>vn</code>. This is used in</li></ul><p>the Gibbs sampling process.</p><ul><li><code>md.orders[md.idcs[vn]]</code> is the number of <code>observe</code> statements before <code>vn</code> is sampled.</li><li><code>md.ranges[md.idcs[vn]]</code> is the index range of <code>vn</code> in <code>md.vals</code>.</li><li><code>md.vals[md.ranges[md.idcs[vn]]]</code> is the vector of values of corresponding to <code>vn</code>.</li><li><code>md.flags</code> is a dictionary of true/false flags. <code>md.flags[flag][md.idcs[vn]]</code> is the</li></ul><p>value of <code>flag</code> corresponding to <code>vn</code>.</p><p>To make <code>md::Metadata</code> type stable, all the <code>md.vns</code> must have the same symbol and distribution type. However, one can have a Julia variable, say <code>x</code>, that is a matrix or a hierarchical array sampled in partitions, e.g. <code>x[1][:] ~ MvNormal(zeros(2), I); x[2][:] ~ MvNormal(ones(2), I)</code>, and is managed by a single <code>md::Metadata</code> so long as all the distributions on the RHS of <code>~</code> are of the same type. Type unstable <code>Metadata</code> will still work but will have inferior performance. When sampling, the first iteration uses a type unstable <code>Metadata</code> for all the variables then a specialized <code>Metadata</code> is used for each symbol along with a function barrier to make the rest of the sampling type stable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L9-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.Metadata-Tuple{}" href="#DynamicPPL.Metadata-Tuple{}"><code>DynamicPPL.Metadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Metadata()</code></pre><p>Construct an empty type unstable instance of <code>Metadata</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.MiniBatchContext" href="#DynamicPPL.MiniBatchContext"><code>DynamicPPL.MiniBatchContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MiniBatchContext{Tctx, T} &lt;: AbstractContext
    context::Tctx
    loglike_scalar::T
end</code></pre><p>The <code>MiniBatchContext</code> enables the computation of  <code>log(prior) + s * log(likelihood of a batch)</code> when running the model, where <code>s</code> is the  <code>loglike_scalar</code> field, typically equal to <code>the number of data points / batch size</code>.  This is useful in batch-based stochastic gradient descent algorithms to be optimizing  <code>log(prior) + log(likelihood of all the data points)</code> in the expectation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L204-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.Model" href="#DynamicPPL.Model"><code>DynamicPPL.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Model{F,argnames,defaultnames,missings,Targs,Tdefaults}
    name::Symbol
    f::F
    args::NamedTuple{argnames,Targs}
    defaults::NamedTuple{defaultnames,Tdefaults}
end</code></pre><p>A <code>Model</code> struct with model evaluation function of type <code>F</code>, arguments of names <code>argnames</code> types <code>Targs</code>, default arguments of names <code>defaultnames</code> with types <code>Tdefaults</code>, and missing arguments <code>missings</code>.</p><p>Here <code>argnames</code>, <code>defaultargnames</code>, and <code>missings</code> are tuples of symbols, e.g. <code>(:a, :b)</code>.</p><p>An argument with a type of <code>Missing</code> will be in <code>missings</code> by default. However, in non-traditional use-cases <code>missings</code> can be defined differently. All variables in <code>missings</code> are treated as random variables rather than observations.</p><p>The default arguments are used internally when constructing instances of the same model with different arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Model(f, (x = 1.0, y = 2.0))
Model{typeof(f),(:x, :y),(),(),Tuple{Float64,Float64},Tuple{}}(f, (x = 1.0, y = 2.0), NamedTuple())

julia&gt; Model(f, (x = 1.0, y = 2.0), (x = 42,))
Model{typeof(f),(:x, :y),(:x,),(),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))

julia&gt; Model{(:y,)}(f, (x = 1.0, y = 2.0), (x = 42,)) # with special definition of missings
Model{typeof(f),(:x, :y),(:x,),(:y,),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.Model-Tuple" href="#DynamicPPL.Model-Tuple"><code>DynamicPPL.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(model::Model)([rng, varinfo, sampler, context])</code></pre><p>Sample from the <code>model</code> using the <code>sampler</code> with random number generator <code>rng</code> and the <code>context</code>, and store the sample and log joint probability in <code>varinfo</code>.</p><p>The method resets the log joint probability of <code>varinfo</code> and increases the evaluation number of <code>sampler</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L368-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.Model-Union{Tuple{Ctx}, Tuple{Tdefaults}, Tuple{defaultnames}, Tuple{Targs}, Tuple{argnames}, Tuple{F}, Tuple{missings}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple{defaultnames, Tdefaults}}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple{defaultnames, Tdefaults}, Ctx}} where {missings, F, argnames, Targs, defaultnames, Tdefaults, Ctx}" href="#DynamicPPL.Model-Union{Tuple{Ctx}, Tuple{Tdefaults}, Tuple{defaultnames}, Tuple{Targs}, Tuple{argnames}, Tuple{F}, Tuple{missings}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple{defaultnames, Tdefaults}}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple{defaultnames, Tdefaults}, Ctx}} where {missings, F, argnames, Targs, defaultnames, Tdefaults, Ctx}"><code>DynamicPPL.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model{missings}(name::Symbol, f, args::NamedTuple, defaults::NamedTuple)</code></pre><p>Create a model of name <code>name</code> with evaluation function <code>f</code> and missing arguments overwritten by <code>missings</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.Model-Union{Tuple{Targs}, Tuple{argnames}, Tuple{F}, Tuple{Symbol, F, NamedTuple{argnames, Targs}}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple, AbstractPPL.AbstractContext}} where {F, argnames, Targs}" href="#DynamicPPL.Model-Union{Tuple{Targs}, Tuple{argnames}, Tuple{F}, Tuple{Symbol, F, NamedTuple{argnames, Targs}}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple}, Tuple{Symbol, F, NamedTuple{argnames, Targs}, NamedTuple, AbstractPPL.AbstractContext}} where {F, argnames, Targs}"><code>DynamicPPL.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(name::Symbol, f, args::NamedTuple[, defaults::NamedTuple = ()])</code></pre><p>Create a model of name <code>name</code> with evaluation function <code>f</code> and missing arguments deduced from <code>args</code>.</p><p>Default arguments <code>defaults</code> are used internally when constructing instances of the same model with different arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.NamedDist" href="#DynamicPPL.NamedDist"><code>DynamicPPL.NamedDist</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A named distribution that carries the name of the random variable with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/distribution_wrappers.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.NodeTrait" href="#DynamicPPL.NodeTrait"><code>DynamicPPL.NodeTrait</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NodeTrait(context)
NodeTrait(f, context)</code></pre><p>Specifies the role of <code>context</code> in the context-tree.</p><p>The officially supported traits are:</p><ul><li><code>IsLeaf</code>: <code>context</code> does not have any decendants.</li><li><code>IsParent</code>: <code>context</code> has a child context to which we often defer. Expects the following methods to be implemented:<ul><li><a href="#DynamicPPL.childcontext"><code>childcontext</code></a></li><li><a href="#DynamicPPL.setchildcontext"><code>setchildcontext</code></a></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.PrefixContext" href="#DynamicPPL.PrefixContext"><code>DynamicPPL.PrefixContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrefixContext{Prefix}(context)</code></pre><p>Create a context that allows you to use the wrapped <code>context</code> when running the model and adds the <code>Prefix</code> to all parameters.</p><p>This context is useful in nested models to ensure that the names of the parameters are unique.</p><p>See also: <a href="#DynamicPPL.@submodel-Tuple{Any, Any}"><code>@submodel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L229-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.PriorContext" href="#DynamicPPL.PriorContext"><code>DynamicPPL.PriorContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PriorContext{Tvars} &lt;: AbstractContext
    vars::Tvars
end</code></pre><p>The <code>PriorContext</code> enables the computation of the log prior of the parameters <code>vars</code> when  running the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L175-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.SampleFromPrior" href="#DynamicPPL.SampleFromPrior"><code>DynamicPPL.SampleFromPrior</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SampleFromPrior</code></pre><p>Sampling algorithm that samples unobserved random variables from their prior distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/sampler.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.SampleFromUniform" href="#DynamicPPL.SampleFromUniform"><code>DynamicPPL.SampleFromUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SampleFromUniform</code></pre><p>Sampling algorithm that samples unobserved random variables from a uniform distribution.</p><p><strong>References</strong></p><p><a href="https://mc-stan.org/docs/2_28/reference-manual/initialization.html#random-initial-values">Stan reference manual</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/sampler.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.Sampler" href="#DynamicPPL.Sampler"><code>DynamicPPL.Sampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sampler{T}</code></pre><p>Generic sampler type for inference algorithms of type <code>T</code> in DynamicPPL.</p><p><code>Sampler</code> should implement the AbstractMCMC interface, and in particular <code>AbstractMCMC.step</code>. A default implementation of the initial sampling step is provided that supports resuming sampling from a previous state and setting initial parameter values. It requires to overload <a href="#DynamicPPL.loadstate"><code>loadstate</code></a> and <a href="#DynamicPPL.initialstep"><code>initialstep</code></a> for loading previous states and actually performing the initial sampling step, respectively. Additionally, sometimes one might want to implement <a href="#DynamicPPL.initialsampler-Tuple{Sampler}"><code>initialsampler</code></a> that specifies how the initial parameter values are sampled if they are not provided. By default, values are sampled from the prior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/sampler.jl#L34-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.SamplingContext" href="#DynamicPPL.SamplingContext"><code>DynamicPPL.SamplingContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SamplingContext(
        [rng::Random.AbstractRNG=Random.GLOBAL_RNG],
        [sampler::AbstractSampler=SampleFromPrior()],
        [context::AbstractContext=DefaultContext()],
)</code></pre><p>Create a context that allows you to sample parameters with the <code>sampler</code> when running the model. The <code>context</code> determines how the returned log density is computed when running the model.</p><p>See also: <a href="#DynamicPPL.DefaultContext"><code>DefaultContext</code></a>, <a href="#DynamicPPL.LikelihoodContext"><code>LikelihoodContext</code></a>, <a href="#DynamicPPL.PriorContext"><code>PriorContext</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L122-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.SimpleVarInfo" href="#DynamicPPL.SimpleVarInfo"><code>DynamicPPL.SimpleVarInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleVarInfo{NT,T} &lt;: AbstractVarInfo</code></pre><p>A simple wrapper of the parameters with a <code>logp</code> field for accumulation of the logdensity.</p><p>Currently only implemented for <code>NT&lt;:NamedTuple</code> and <code>NT&lt;:Dict</code>.</p><p><strong>Notes</strong></p><p>The major differences between this and <code>TypedVarInfo</code> are:</p><ol><li><code>SimpleVarInfo</code> does not require linearization.</li><li><code>SimpleVarInfo</code> can use more efficient bijectors.</li><li><code>SimpleVarInfo</code> is only type-stable if <code>NT&lt;:NamedTuple</code> and either a) no indexing is used in tilde-statements, or b) the values have been specified with the correct shapes.</li></ol><p><strong>Examples</strong></p><p><strong>General usage</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using StableRNGs

julia&gt; @model function demo()
           m ~ Normal()
           x = Vector{Float64}(undef, 2)
           for i in eachindex(x)
               x[i] ~ Normal()
           end
           return x
       end
demo (generic function with 2 methods)

julia&gt; m = demo();

julia&gt; rng = StableRNG(42);

julia&gt; ### Sampling ###
       ctx = SamplingContext(rng, SampleFromPrior(), DefaultContext());

julia&gt; # In the `NamedTuple` version we need to provide the place-holder values for
       # the variables which are using &quot;containers&quot;, e.g. `Array`.
       # In this case, this means that we need to specify `x` but not `m`.
       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo((x = ones(2), )), ctx);

julia&gt; # (✓) Vroom, vroom! FAST!!!
       vi[@varname(x[1])]
0.4471218424633827

julia&gt; # We can also access arbitrary varnames pointing to `x`, e.g.
       vi[@varname(x)]
2-element Vector{Float64}:
 0.4471218424633827
 1.3736306979834252

julia&gt; vi[@varname(x[1:2])]
2-element Vector{Float64}:
 0.4471218424633827
 1.3736306979834252

julia&gt; # (×) If we don&#39;t provide the container...
       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo(), ctx); vi
ERROR: type NamedTuple has no field x
[...]

julia&gt; # If one does not know the varnames, we can use a `Dict` instead.
       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo{Float64}(Dict()), ctx);

julia&gt; # (✓) Sort of fast, but only possible at runtime.
       vi[@varname(x[1])]
-1.019202452456547

julia&gt; # In addtion, we can only access varnames as they appear in the model!
       vi[@varname(x)]
ERROR: KeyError: key x not found
[...]

julia&gt; vi[@varname(x[1:2])]
ERROR: KeyError: key x[1:2] not found
[...]</code></pre><p><strong>Indexing</strong></p><p>Using <code>NamedTuple</code> as underlying storage.</p><pre><code class="language-julia-repl hljs">julia&gt; svi_nt = SimpleVarInfo((m = (a = [1.0], ), ));

julia&gt; svi_nt[@varname(m)]
(a = [1.0],)

julia&gt; svi_nt[@varname(m.a)]
1-element Vector{Float64}:
 1.0

julia&gt; svi_nt[@varname(m.a[1])]
1.0

julia&gt; svi_nt[@varname(m.a[2])]
ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]
[...]

julia&gt; svi_nt[@varname(m.b)]
ERROR: type NamedTuple has no field b
[...]</code></pre><p>Using <code>Dict</code> as underlying storage.</p><pre><code class="language-julia-repl hljs">julia&gt; svi_dict = SimpleVarInfo(Dict(@varname(m) =&gt; (a = [1.0], )));

julia&gt; svi_dict[@varname(m)]
(a = [1.0],)

julia&gt; svi_dict[@varname(m.a)]
1-element Vector{Float64}:
 1.0

julia&gt; svi_dict[@varname(m.a[1])]
1.0

julia&gt; svi_dict[@varname(m.a[2])]
ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]
[...]

julia&gt; svi_dict[@varname(m.b)]
ERROR: type NamedTuple has no field b
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/simple_varinfo.jl#L1-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.ThreadSafeVarInfo" href="#DynamicPPL.ThreadSafeVarInfo"><code>DynamicPPL.ThreadSafeVarInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ThreadSafeVarInfo</code></pre><p>A <code>ThreadSafeVarInfo</code> object wraps an <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a> object and an array of log probabilities for thread-safe execution of a probabilistic model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/threadsafe.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.TypedVarInfo-Tuple{UntypedVarInfo}" href="#DynamicPPL.TypedVarInfo-Tuple{UntypedVarInfo}"><code>DynamicPPL.TypedVarInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TypedVarInfo(vi::UntypedVarInfo)</code></pre><p>This function finds all the unique <code>sym</code>s from the instances of <code>VarName{sym}</code> found in <code>vi.metadata.vns</code>. It then extracts the metadata associated with each symbol from the global <code>vi.metadata</code> field. Finally, a new <code>VarInfo</code> is created with a new <code>metadata</code> as a <code>NamedTuple</code> mapping from symbols to type-stable <code>Metadata</code> instances, one for each symbol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L525-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.VarInfo" href="#DynamicPPL.VarInfo"><code>DynamicPPL.VarInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VarInfo{Tmeta, Tlogp} &lt;: AbstractVarInfo
    metadata::Tmeta
    logp::Base.RefValue{Tlogp}
    num_produce::Base.RefValue{Int}
end</code></pre><p>A light wrapper over one or more instances of <code>Metadata</code>. Let <code>vi</code> be an instance of <code>VarInfo</code>. If <code>vi isa VarInfo{&lt;:Metadata}</code>, then only one <code>Metadata</code> instance is used for all the sybmols. <code>VarInfo{&lt;:Metadata}</code> is aliased <code>UntypedVarInfo</code>. If <code>vi isa VarInfo{&lt;:NamedTuple}</code>, then <code>vi.metadata</code> is a <code>NamedTuple</code> that maps each symbol used on the LHS of <code>~</code> in the model to its <code>Metadata</code> instance. The latter allows for the type specialization of <code>vi</code> after the first sampling iteration when all the symbols have been observed. <code>VarInfo{&lt;:NamedTuple}</code> is aliased <code>TypedVarInfo</code>.</p><p>Note: It is the user&#39;s responsibility to ensure that each &quot;symbol&quot; is visited at least once whenever the model is called, regardless of any stochastic branching. Each symbol refers to a Julia variable and can be a hierarchical array of many random variables, e.g. <code>x[1] ~ ...</code> and <code>x[2] ~ ...</code> both have the same symbol <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L78-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPPL.condition-Tuple{Model}" href="#AbstractPPL.condition-Tuple{Model}"><code>AbstractPPL.condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">condition(model::Model; values...)
condition(model::Model, values::NamedTuple)</code></pre><p>Return a <code>Model</code> which now treats the variables in <code>values</code> as observations.</p><p>See also: <a href="#AbstractPPL.decondition-Tuple{DynamicPPL.IsLeaf, Any, Vararg{Any}}"><code>decondition</code></a>, <a href="#DynamicPPL.conditioned-Tuple{AbstractPPL.AbstractContext}"><code>conditioned</code></a></p><p><strong>Limitations</strong></p><p>This does currently <em>not</em> work with variables that are provided to the model as arguments, e.g. <code>@model function demo(x) ... end</code> means that <code>condition</code> will not affect the variable <code>x</code>.</p><p>Therefore if one wants to make use of <code>condition</code> and <a href="#AbstractPPL.decondition-Tuple{DynamicPPL.IsLeaf, Any, Vararg{Any}}"><code>decondition</code></a> one should not be specifying any random variables as arguments.</p><p>This is done for the sake of backwards compatibility.</p><p><strong>Examples</strong></p><p><strong>Simple univariate model</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions; using StableRNGs; rng = StableRNG(42); # For reproducibility.

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; model(rng)
(m = -0.6702516921145671, x = -0.22312984965118443)

julia&gt; # Create a new instance which treats `x` as observed
       # with value `100.0`, and similarly for `m=1.0`.
       conditioned_model = condition(model, x=100.0, m=1.0);

julia&gt; conditioned_model(rng)
(m = 1.0, x = 100.0)

julia&gt; # Let&#39;s only condition on `x = 100.0`.
       conditioned_model = condition(model, x = 100.0);

julia&gt; conditioned_model(rng)
(m = 1.3736306979834252, x = 100.0)

julia&gt; # We can also use the nicer `|` syntax.
       conditioned_model = model | (x = 100.0, );

julia&gt; conditioned_model(rng)
(m = 1.3095394956381083, x = 100.0)</code></pre><p><strong>Condition only a part of a multivariate variable</strong></p><p>Not only can be condition on multivariate random variables, but we can also use the standard mechanism of setting something to <code>missing</code> in the call to <code>condition</code> to only condition on a part of the variable.</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_mv(::Type{TV}=Float64) where {TV}
           m = Vector{TV}(undef, 2)
           m[1] ~ Normal()
           m[2] ~ Normal()
           return m
       end
demo_mv (generic function with 3 methods)

julia&gt; model = demo_mv();

julia&gt; conditioned_model = condition(model, m = [missing, 1.0]);

julia&gt; conditioned_model(rng) # (✓) `m[1]` sampled, `m[2]` is fixed
2-element Vector{Float64}:
 0.12607002180931043
 1.0</code></pre><p>Intuitively one might also expect to be able to write <code>model | (x[1] = 1.0, )</code>. Unfortunately this is not supported due to performance.</p><pre><code class="language-julia-repl hljs">julia&gt; condition(model, var&quot;x[2]&quot; = 1.0)(rng) # (×) `x[2]` is not set to 1.0.
2-element Vector{Float64}:
  0.683947930996541
 -1.019202452456547</code></pre><p>We will likely provide some syntactic sugar for this in the future.</p><p><strong>Nested models</strong></p><p><code>condition</code> of course also supports the use of nested models through the use of <a href="#DynamicPPL.@submodel-Tuple{Any, Any}"><code>@submodel</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; @model demo_inner() = m ~ Normal()
demo_inner (generic function with 2 methods)

julia&gt; @model function demo_outer()
           @submodel m = demo_inner()
           return m
       end
demo_outer (generic function with 2 methods)

julia&gt; model = demo_outer();

julia&gt; model(rng)
-0.7935128416361353

julia&gt; conditioned_model = model | (m = 1.0, );

julia&gt; conditioned_model(rng)
1.0</code></pre><p>But one needs to be careful when prefixing variables in the nested models:</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_outer_prefix()
           @submodel prefix=&quot;inner&quot; m = demo_inner()
           return m
       end
demo_outer_prefix (generic function with 2 methods)

julia&gt; # This doesn&#39;t work now!
       conditioned_model = demo_outer_prefix() | (m = 1.0, );

julia&gt; conditioned_model(rng)
1.7747246334368165

julia&gt; # `m` in `demo_inner` is referred to as `inner.m` internally, so we do:
       conditioned_model = demo_outer_prefix() | (var&quot;inner.m&quot; = 1.0, );

julia&gt; conditioned_model(rng)
1.0

julia&gt; # Note that the above `var&quot;...&quot;` is just standard Julia syntax:
       keys((var&quot;inner.m&quot; = 1.0, ))
(Symbol(&quot;inner.m&quot;),)</code></pre><p>The difference is maybe more obvious once we look at how these different in their trace/<code>VarInfo</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; keys(VarInfo(demo_outer()))
1-element Vector{VarName{:m, Tuple{}}}:
 m

julia&gt; keys(VarInfo(demo_outer_prefix()))
1-element Vector{VarName{Symbol(&quot;inner.m&quot;), Tuple{}}}:
 inner.m</code></pre><p>From this we can tell what the correct way to condition <code>m</code> within <code>demo_inner</code> is in the two different models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L95-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPPL.condition-Tuple{}" href="#AbstractPPL.condition-Tuple{}"><code>AbstractPPL.condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">condition([context::AbstractContext,] values::NamedTuple)
condition([context::AbstractContext]; values...)</code></pre><p>Return <code>ConditionContext</code> with <code>values</code> and <code>context</code> if <code>values</code> is non-empty, otherwise return <code>context</code> which is <a href="#DynamicPPL.DefaultContext"><code>DefaultContext</code></a> by default.</p><p>See also: <a href="#AbstractPPL.decondition-Tuple{DynamicPPL.IsLeaf, Any, Vararg{Any}}"><code>decondition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L380-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPPL.decondition-Tuple{DynamicPPL.IsLeaf, Any, Vararg{Any}}" href="#AbstractPPL.decondition-Tuple{DynamicPPL.IsLeaf, Any, Vararg{Any}}"><code>AbstractPPL.decondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decondition(context::AbstractContext, syms...)</code></pre><p>Return <code>context</code> but with <code>syms</code> no longer conditioned on.</p><p>Note that this recursively traverses contexts, deconditioning all along the way.</p><p>See also: <a href="#AbstractPPL.condition-Tuple{Model}"><code>condition</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L399-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPPL.decondition-Tuple{Model, Vararg{Any}}" href="#AbstractPPL.decondition-Tuple{Model, Vararg{Any}}"><code>AbstractPPL.decondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decondition(model::Model)
decondition(model::Model, syms...)</code></pre><p>Return a <code>Model</code> for which <code>syms...</code> are <em>not</em> considered observations. If no <code>syms</code> are provided, then all variables currently considered observations will no longer be.</p><p>This is essentially the inverse of <a href="#AbstractPPL.condition-Tuple{Model}"><code>condition</code></a>. This also means that it suffers from the same limitiations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions; using StableRNGs; rng = StableRNG(42); # For reproducibility.

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; conditioned_model = condition(demo(), m = 1.0, x = 10.0);

julia&gt; conditioned_model(rng)
(m = 1.0, x = 10.0)

julia&gt; model = decondition(conditioned_model, :m);

julia&gt; model(rng)
(m = -0.6702516921145671, x = 10.0)

julia&gt; # `decondition` multiple at once:
       decondition(model, :m, :x)(rng)
(m = 0.4471218424633827, x = 1.820752540446808)

julia&gt; # `decondition` without any symbols will `decondition` all variables.
       decondition(model)(rng)
(m = 1.3095394956381083, x = 1.4356095174474188)

julia&gt; # Usage of `Val` to perform `decondition` at compile-time if possible
       # is also supported.
       model = decondition(conditioned_model, Val{:m}());

julia&gt; model(rng)
(m = 0.683947930996541, x = 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L262-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPPL.evaluate!!-Tuple{Model, AbstractVarInfo, AbstractPPL.AbstractContext}" href="#AbstractPPL.evaluate!!-Tuple{Model, AbstractVarInfo, AbstractPPL.AbstractContext}"><code>AbstractPPL.evaluate!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate!!(model::Model[, rng, varinfo, sampler, context])</code></pre><p>Sample from the <code>model</code> using the <code>sampler</code> with random number generator <code>rng</code> and the <code>context</code>, and store the sample and log joint probability in <code>varinfo</code>.</p><p>Returns both the return-value of the original model, and the resulting varinfo.</p><p>The method resets the log joint probability of <code>varinfo</code> and increases the evaluation number of <code>sampler</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L389-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BangBang.empty!!-Tuple{VarInfo}" href="#BangBang.empty!!-Tuple{VarInfo}"><code>BangBang.empty!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empty!!(vi::VarInfo)</code></pre><p>Empty the fields of <code>vi.metadata</code> and reset <code>vi.logp[]</code> and <code>vi.num_produce[]</code> to zeros.</p><p>This is useful when using a sampling algorithm that assumes an empty <code>vi</code>, e.g. <code>SMC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L590-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BangBang.push!!-Tuple{AbstractVarInfo, VarName, Any, Distributions.Distribution, DynamicPPL.Selector}" href="#BangBang.push!!-Tuple{AbstractVarInfo, VarName, Any, Distributions.Distribution, DynamicPPL.Selector}"><code>BangBang.push!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">push!!(vi::VarInfo, vn::VarName, r, dist::Distribution, gid::Selector)</code></pre><p>Push a new random variable <code>vn</code> with a sampled value <code>r</code> sampled with a sampler of selector <code>gid</code> from a distribution <code>dist</code> to <code>VarInfo</code> <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1128-L1133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BangBang.push!!-Tuple{AbstractVarInfo, VarName, Any, Distributions.Distribution, Sampler}" href="#BangBang.push!!-Tuple{AbstractVarInfo, VarName, Any, Distributions.Distribution, Sampler}"><code>BangBang.push!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">push!!(vi::VarInfo, vn::VarName, r, dist::Distribution, spl::AbstractSampler)</code></pre><p>Push a new random variable <code>vn</code> with a sampled value <code>r</code> sampled with a sampler <code>spl</code> from a distribution <code>dist</code> to <code>VarInfo</code> <code>vi</code>, if it makes sense.</p><p>The sampler is passed here to invalidate its cache where defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1109-L1116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BangBang.push!!-Tuple{AbstractVarInfo, VarName, Any, Distributions.Distribution}" href="#BangBang.push!!-Tuple{AbstractVarInfo, VarName, Any, Distributions.Distribution}"><code>BangBang.push!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">push!!(vi::VarInfo, vn::VarName, r, dist::Distribution)</code></pre><p>Push a new random variable <code>vn</code> with a sampled value <code>r</code> from a distribution <code>dist</code> to the <code>VarInfo</code> <code>vi</code>, mutating if it makes sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1099-L1104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:|-Tuple{Model, Any}" href="#Base.:|-Tuple{Model, Any}"><code>Base.:|</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model | (x = 1.0, ...)</code></pre><p>Return a <code>Model</code> which now treats variables on the right-hand side as observations.</p><p>See <a href="#AbstractPPL.condition-Tuple{Model}"><code>condition</code></a> for more information and examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty!-Tuple{DynamicPPL.Metadata}" href="#Base.empty!-Tuple{DynamicPPL.Metadata}"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empty!(meta::Metadata)</code></pre><p>Empty the fields of <code>meta</code>.</p><p>This is useful when using a sampling algorithm that assumes an empty <code>meta</code>, e.g. <code>SMC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L197-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractVarInfo, SampleFromPrior}" href="#Base.getindex-Tuple{AbstractVarInfo, SampleFromPrior}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(vi::VarInfo, spl::Union{SampleFromPrior, Sampler})</code></pre><p>Return the current value(s) of the random variables sampled by <code>spl</code> in <code>vi</code>.</p><p>The value(s) may or may not be transformed to Euclidean space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L926-L932">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractVarInfo, VarName}" href="#Base.getindex-Tuple{AbstractVarInfo, VarName}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(vi::VarInfo, vn::VarName)
getindex(vi::VarInfo, vns::Vector{&lt;:VarName})</code></pre><p>Return the current value(s) of <code>vn</code> (<code>vns</code>) in <code>vi</code> in the support of its (their) distribution(s).</p><p>If the value(s) is (are) transformed to the Euclidean space, it is (they are) transformed back.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L897-L906">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.haskey-Tuple{VarInfo, VarName}" href="#Base.haskey-Tuple{VarInfo, VarName}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">haskey(vi::VarInfo, vn::VarName)</code></pre><p>Check whether <code>vn</code> has been sampled in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1039-L1043">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{UntypedVarInfo}" href="#Base.isempty-Tuple{UntypedVarInfo}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isempty(vi::VarInfo)</code></pre><p>Return true if <code>vi</code> is empty and false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L716-L720">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Tuple{SimpleVarInfo}" href="#Base.keys-Tuple{SimpleVarInfo}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">keys(vi::SimpleVarInfo)</code></pre><p>Return an iterator of keys present in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/simple_varinfo.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Tuple{UntypedVarInfo}" href="#Base.keys-Tuple{UntypedVarInfo}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">keys(vi::AbstractVarInfo)</code></pre><p>Return an iterator over all <code>vns</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L614-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nameof-Tuple{Model}" href="#Base.nameof-Tuple{Model}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nameof(model::Model)</code></pre><p>Get the name of the <code>model</code> as <code>Symbol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L513-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractVarInfo, Any, SampleFromPrior}" href="#Base.setindex!-Tuple{AbstractVarInfo, Any, SampleFromPrior}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(vi::VarInfo, val, spl::Union{SampleFromPrior, Sampler})</code></pre><p>Set the current value(s) of the random variables sampled by <code>spl</code> in <code>vi</code> to <code>val</code>.</p><p>The value(s) may or may not be transformed to Euclidean space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L963-L969">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractVarInfo, Any, VarName}" href="#Base.setindex!-Tuple{AbstractVarInfo, Any, VarName}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(vi::VarInfo, val, vn::VarName)</code></pre><p>Set the current value(s) of the random variable <code>vn</code> in <code>vi</code> to <code>val</code>.</p><p>The value(s) may or may not be transformed to Euclidean space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L951-L957">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL._apply!-Tuple{Any, AbstractVarInfo, Any, Any}" href="#DynamicPPL._apply!-Tuple{Any, AbstractVarInfo, Any, Any}"><code>DynamicPPL._apply!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_apply!(kernel!, vi::AbstractVarInfo, values, keys)</code></pre><p>Calls <code>kernel!(vi, vn, values, keys)</code> for every <code>vn</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1271-L1275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL._evaluate!!-Union{Tuple{argnames}, Tuple{_F}, Tuple{Model{_F, argnames}, Any, Any}} where {_F, argnames}" href="#DynamicPPL._evaluate!!-Union{Tuple{argnames}, Tuple{_F}, Tuple{Model{_F, argnames}, Any, Any}} where {_F, argnames}"><code>DynamicPPL._evaluate!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_evaluate!!(model::Model, varinfo, context)</code></pre><p>Evaluate the <code>model</code> with the arguments matching the given <code>context</code> and <code>varinfo</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L473-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.acclogp!!-Tuple{VarInfo, Any}" href="#DynamicPPL.acclogp!!-Tuple{VarInfo, Any}"><code>DynamicPPL.acclogp!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acclogp!!(vi::VarInfo, logp)</code></pre><p>Add <code>logp</code> to the value of the log of the joint probability of the observed data and parameters sampled in <code>vi</code>, mutating if it makes sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L668-L673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.build_model_info-Tuple{Any}" href="#DynamicPPL.build_model_info-Tuple{Any}"><code>DynamicPPL.build_model_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_model_info(input_expr)</code></pre><p>Builds the <code>model_info</code> dictionary from the model&#39;s expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L217-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.build_output-Tuple{Any, Any}" href="#DynamicPPL.build_output-Tuple{Any, Any}"><code>DynamicPPL.build_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_output(modelinfo, linenumbernode)</code></pre><p>Builds the output expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L554-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.canview-Tuple{Any, Any}" href="#DynamicPPL.canview-Tuple{Any, Any}"><code>DynamicPPL.canview</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canview(lens, container)</code></pre><p>Return <code>true</code> if <code>lens</code> can be used to view <code>container</code>, and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; canview(@lens(_.a), (a = 1.0, ))
true

julia&gt; canview(@lens(_.a), (b = 1.0, )) # property `a` does not exist
false

julia&gt; canview(@lens(_.a[1]), (a = [1.0, 2.0], ))
true

julia&gt; canview(@lens(_.a[3]), (a = [1.0, 2.0], )) # out of bounds
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/utils.jl#L177-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.check_tilde_rhs-Tuple{Any}" href="#DynamicPPL.check_tilde_rhs-Tuple{Any}"><code>DynamicPPL.check_tilde_rhs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_tilde_rhs(x)</code></pre><p>Check if the right-hand side <code>x</code> of a <code>~</code> is a <code>Distribution</code> or an array of <code>Distributions</code>, then return <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.childcontext" href="#DynamicPPL.childcontext"><code>DynamicPPL.childcontext</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">childcontext(context)</code></pre><p>Return the descendant context of <code>context</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.conditioned-Tuple{AbstractPPL.AbstractContext}" href="#DynamicPPL.conditioned-Tuple{AbstractPPL.AbstractContext}"><code>DynamicPPL.conditioned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conditioned(context::AbstractContext)</code></pre><p>Return <code>NamedTuple</code> of values that are conditioned on under context`.</p><p>Note that this will recursively traverse the context stack and return a merged version of the condition values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L433-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.conditioned-Tuple{Model}" href="#DynamicPPL.conditioned-Tuple{Model}"><code>DynamicPPL.conditioned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conditioned(model::Model)</code></pre><p>Return <code>NamedTuple</code> of values that are conditioned on under <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; using DynamicPPL: conditioned, contextualize

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
       end
demo (generic function with 2 methods)

julia&gt; m = demo();

julia&gt; # Returns all the variables we have conditioned on + their values.
       conditioned(condition(m, x=100.0, m=1.0))
(x = 100.0, m = 1.0)

julia&gt; # Nested ones also work (note that `PrefixContext` does nothing to the result).
       cm = condition(contextualize(m, PrefixContext{:a}(condition(m=1.0))), x=100.0);

julia&gt; conditioned(cm)
(x = 100.0, m = 1.0)

julia&gt; # Since we conditioned on `m`, not `a.m` as it will appear after prefixed,
       # `a.m` is treated as a random variable.
       keys(VarInfo(cm))
1-element Vector{VarName{Symbol(&quot;a.m&quot;), Tuple{}}}:
 a.m

julia&gt; # If we instead condition on `a.m`, `m` in the model will be considered an observation.
       cm = condition(contextualize(m, PrefixContext{:a}(condition(var&quot;a.m&quot;=1.0))), x=100.0);

julia&gt; conditioned(cm)
(x = 100.0, a.m = 1.0)

julia&gt; keys(VarInfo(cm)) # &lt;= no variables are sampled
Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L321-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.contextual_isassumption-Tuple{DynamicPPL.IsLeaf, Any, Any}" href="#DynamicPPL.contextual_isassumption-Tuple{DynamicPPL.IsLeaf, Any, Any}"><code>DynamicPPL.contextual_isassumption</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contextual_isassumption(context, vn)</code></pre><p>Return <code>true</code> if <code>vn</code> is considered an assumption by <code>context</code>.</p><p>The default implementation for <code>AbstractContext</code> always returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L54-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.dot_tilde_assume!!-NTuple{5, Any}" href="#DynamicPPL.dot_tilde_assume!!-NTuple{5, Any}"><code>DynamicPPL.dot_tilde_assume!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot_tilde_assume!!(context, right, left, vn, vi)</code></pre><p>Handle broadcasted assumed variables, e.g., <code>x .~ MvNormal()</code> (where <code>x</code> does not occur in the model inputs), accumulate the log probability, and return the sampled value and updated <code>vi</code>.</p><p>Falls back to <code>dot_tilde_assume(context, right, left, vn, vi)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/context_implementations.jl#L366-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.dot_tilde_assume-Tuple{SamplingContext, Any, Any, Any, Any}" href="#DynamicPPL.dot_tilde_assume-Tuple{SamplingContext, Any, Any, Any, Any}"><code>DynamicPPL.dot_tilde_assume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot_tilde_assume(context::SamplingContext, right, left, vn, vi)</code></pre><p>Handle broadcasted assumed variables, e.g., <code>x .~ MvNormal()</code> (where <code>x</code> does not occur in the model inputs), accumulate the log probability, and return the sampled value for a context associated with a sampler.</p><p>Falls back to</p><pre><code class="language-julia hljs">dot_tilde_assume(context.rng, context.context, context.sampler, right, left, vn, vi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/context_implementations.jl#L239-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.dot_tilde_observe!!-NTuple{4, Any}" href="#DynamicPPL.dot_tilde_observe!!-NTuple{4, Any}"><code>DynamicPPL.dot_tilde_observe!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot_tilde_observe!!(context, right, left, vi)</code></pre><p>Handle broadcasted observed constants, e.g., <code>[1.0] .~ MvNormal()</code>, accumulate the log probability, and return the observed value and updated <code>vi</code>.</p><p>Falls back to <code>dot_tilde_observe(context, right, left, vi)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/context_implementations.jl#L595-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.dot_tilde_observe!!-NTuple{5, Any}" href="#DynamicPPL.dot_tilde_observe!!-NTuple{5, Any}"><code>DynamicPPL.dot_tilde_observe!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot_tilde_observe!!(context, right, left, vname, vi)</code></pre><p>Handle broadcasted observed values, e.g., <code>x .~ MvNormal()</code> (where <code>x</code> does occur in the model inputs), accumulate the log probability, and return the observed value and updated <code>vi</code>.</p><p>Falls back to <code>dot_tilde_observe!!(context, right, left, vi)</code> ignoring the information about variable name and indices; if needed, these can be accessed through this function, though.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/context_implementations.jl#L582-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.dot_tilde_observe-Tuple{SamplingContext, Any, Any, Any}" href="#DynamicPPL.dot_tilde_observe-Tuple{SamplingContext, Any, Any, Any}"><code>DynamicPPL.dot_tilde_observe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot_tilde_observe(context::SamplingContext, right, left, vi)</code></pre><p>Handle broadcasted observed constants, e.g., <code>[1.0] .~ MvNormal()</code>, accumulate the log probability, and return the observed value for a context associated with a sampler.</p><p>Falls back to <code>dot_tilde_observe(context.context, context.sampler, right, left, vi)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/context_implementations.jl#L547-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.evaluate_threadsafe!!-Tuple{Any, Any, Any}" href="#DynamicPPL.evaluate_threadsafe!!-Tuple{Any, Any, Any}"><code>DynamicPPL.evaluate_threadsafe!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate_threadsafe!!(model, varinfo, context)</code></pre><p>Evaluate the <code>model</code> with <code>varinfo</code> wrapped inside a <code>ThreadSafeVarInfo</code>.</p><p>With the wrapper, Julia&#39;s multithreading can be used for observe statements in the <code>model</code> but parallel sampling will lead to undefined behaviour. This method is not exposed and supposed to be used only internally in DynamicPPL.</p><p>See also: <a href="#DynamicPPL.evaluate_threadunsafe!!-Tuple{Any, Any, Any}"><code>evaluate_threadunsafe!!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L456-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.evaluate_threadunsafe!!-Tuple{Any, Any, Any}" href="#DynamicPPL.evaluate_threadunsafe!!-Tuple{Any, Any, Any}"><code>DynamicPPL.evaluate_threadunsafe!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate_threadunsafe!!(model, varinfo, context)</code></pre><p>Evaluate the <code>model</code> without wrapping <code>varinfo</code> inside a <code>ThreadSafeVarInfo</code>.</p><p>If the <code>model</code> makes use of Julia&#39;s multithreading this will lead to undefined behaviour. This method is not exposed and supposed to be used only internally in DynamicPPL.</p><p>See also: <a href="#DynamicPPL.evaluate_threadsafe!!-Tuple{Any, Any, Any}"><code>evaluate_threadsafe!!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L442-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.generate_dot_tilde-Tuple{Any, Any}" href="#DynamicPPL.generate_dot_tilde-Tuple{Any, Any}"><code>DynamicPPL.generate_dot_tilde</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_dot_tilde(left, right)</code></pre><p>Generate the expression that replaces <code>left .~ right</code> in the model body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L431-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.generate_mainbody-Tuple{Any, Any, Any}" href="#DynamicPPL.generate_mainbody-Tuple{Any, Any, Any}"><code>DynamicPPL.generate_mainbody</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_mainbody(mod, expr, warn)</code></pre><p>Generate the body of the main evaluation function from expression <code>expr</code> and arguments <code>args</code>.</p><p>If <code>warn</code> is true, a warning is displayed if internal variables are used in the model definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L298-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.generate_tilde-Tuple{Any, Any}" href="#DynamicPPL.generate_tilde-Tuple{Any, Any}"><code>DynamicPPL.generate_tilde</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_tilde(left, right)</code></pre><p>Generate an <code>observe</code> expression for data variables and <code>assume</code> expression for parameter variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L369-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.generated_quantities-Tuple{Model, AbstractMCMC.AbstractChains}" href="#DynamicPPL.generated_quantities-Tuple{Model, AbstractMCMC.AbstractChains}"><code>DynamicPPL.generated_quantities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generated_quantities(model::Model, chain::AbstractChains)</code></pre><p>Execute <code>model</code> for each of the samples in <code>chain</code> and return an array of the values returned by the <code>model</code> for each sample.</p><p><strong>Examples</strong></p><p><strong>General</strong></p><p>Often you might have additional quantities computed inside the model that you want to inspect, e.g.</p><pre><code class="language-julia hljs">@model function demo(x)
    # sample and observe
    θ ~ Prior()
    x ~ Likelihood()
    return interesting_quantity(θ, x)
end
m = demo(data)
chain = sample(m, alg, n)
# To inspect the `interesting_quantity(θ, x)` where `θ` is replaced by samples
# from the posterior/`chain`:
generated_quantities(m, chain) # &lt;= results in a `Vector` of returned values
                               #    from `interesting_quantity(θ, x)`</code></pre><p><strong>Concrete (and simple)</strong></p><pre><code class="language-julia hljs">julia&gt; using DynamicPPL, Turing

julia&gt; @model function demo(xs)
           s ~ InverseGamma(2, 3)
           m_shifted ~ Normal(10, √s)
           m = m_shifted - 10

           for i in eachindex(xs)
               xs[i] ~ Normal(m, √s)
           end

           return (m, )
       end
demo (generic function with 1 method)

julia&gt; model = demo(randn(10));

julia&gt; chain = sample(model, MH(), 10);

julia&gt; generated_quantities(model, chain)
10×1 Array{Tuple{Float64},2}:
 (2.1964758025119338,)
 (2.1964758025119338,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.043088571494005024,)
 (-0.16489786710222099,)
 (-0.16489786710222099,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L553-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.generated_quantities-Tuple{Model, NamedTuple}" href="#DynamicPPL.generated_quantities-Tuple{Model, NamedTuple}"><code>DynamicPPL.generated_quantities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generated_quantities(model::Model, parameters::NamedTuple)
generated_quantities(model::Model, values, keys)
generated_quantities(model::Model, values, keys)</code></pre><p>Execute <code>model</code> with variables <code>keys</code> set to <code>values</code> and return the values returned by the <code>model</code>.</p><p>If a <code>NamedTuple</code> is given, <code>keys=keys(parameters)</code> and <code>values=values(parameters)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions

julia&gt; @model function demo(xs)
           s ~ InverseGamma(2, 3)
           m_shifted ~ Normal(10, √s)
           m = m_shifted - 10
           for i in eachindex(xs)
               xs[i] ~ Normal(m, √s)
           end
           return (m, )
       end
demo (generic function with 2 methods)

julia&gt; model = demo(randn(10));

julia&gt; parameters = (; s = 1.0, m_shifted=10);

julia&gt; generated_quantities(model, parameters)
(0.0,)

julia&gt; generated_quantities(model, values(parameters), keys(parameters))
(0.0,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L621-L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.get_matching_type-Union{Tuple{T}, Tuple{AbstractMCMC.AbstractSampler, Any, Type{T}}} where T" href="#DynamicPPL.get_matching_type-Union{Tuple{T}, Tuple{AbstractMCMC.AbstractSampler, Any, Type{T}}} where T"><code>DynamicPPL.get_matching_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_matching_type(spl::AbstractSampler, vi, ::Type{T}) where {T}</code></pre><p>Get the specialized version of type <code>T</code> for sampler <code>spl</code>.</p><p>For example, if <code>T === Float64</code> and <code>spl::Hamiltonian</code>, the matching type is <code>eltype(vi[spl])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L662-L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.get_num_produce-Tuple{VarInfo}" href="#DynamicPPL.get_num_produce-Tuple{VarInfo}"><code>DynamicPPL.get_num_produce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_num_produce(vi::VarInfo)</code></pre><p>Return the <code>num_produce</code> of <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L687-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getall-Tuple{UntypedVarInfo}" href="#DynamicPPL.getall-Tuple{UntypedVarInfo}"><code>DynamicPPL.getall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getall(vi::VarInfo)</code></pre><p>Return the values of all the variables in <code>vi</code>.</p><p>The values may or may not be transformed to Euclidean space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L315-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getargnames-Union{Tuple{Model{_F, argnames}}, Tuple{_F}, Tuple{argnames}} where {argnames, _F}" href="#DynamicPPL.getargnames-Union{Tuple{Model{_F, argnames}}, Tuple{_F}, Tuple{argnames}} where {argnames, _F}"><code>DynamicPPL.getargnames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getargnames(model::Model)</code></pre><p>Get a tuple of the argument names of the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L499-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getargs_assignment-Tuple{Any}" href="#DynamicPPL.getargs_assignment-Tuple{Any}"><code>DynamicPPL.getargs_assignment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getargs_assignment(x)</code></pre><p>Return the arguments <code>L</code> and <code>R</code>, if <code>x</code> is an expression of the form <code>L = R</code>, or <code>nothing</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/utils.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getargs_dottilde-Tuple{Any}" href="#DynamicPPL.getargs_dottilde-Tuple{Any}"><code>DynamicPPL.getargs_dottilde</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getargs_dottilde(x)</code></pre><p>Return the arguments <code>L</code> and <code>R</code>, if <code>x</code> is an expression of the form <code>L .~ R</code> or <code>(~).(L, R)</code>, or <code>nothing</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/utils.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getargs_tilde-Tuple{Any}" href="#DynamicPPL.getargs_tilde-Tuple{Any}"><code>DynamicPPL.getargs_tilde</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getargs_tilde(x)</code></pre><p>Return the arguments <code>L</code> and <code>R</code>, if <code>x</code> is an expression of the form <code>L ~ R</code>, or <code>nothing</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/utils.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getdist-Tuple{VarInfo, VarName}" href="#DynamicPPL.getdist-Tuple{VarInfo, VarName}"><code>DynamicPPL.getdist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getdist(vi::VarInfo, vn::VarName)</code></pre><p>Return the distribution from which <code>vn</code> was sampled in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L279-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getgid-Tuple{VarInfo, VarName}" href="#DynamicPPL.getgid-Tuple{VarInfo, VarName}"><code>DynamicPPL.getgid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getgid(vi::VarInfo, vn::VarName)</code></pre><p>Return the set of sampler selectors associated with <code>vn</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L353-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getidx-Tuple{VarInfo, VarName}" href="#DynamicPPL.getidx-Tuple{VarInfo, VarName}"><code>DynamicPPL.getidx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getidx(vi::VarInfo, vn::VarName)</code></pre><p>Return the index of <code>vn</code> in the metadata of <code>vi</code> corresponding to <code>vn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L256-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getlogp-Tuple{AbstractVarInfo}" href="#DynamicPPL.getlogp-Tuple{AbstractVarInfo}"><code>DynamicPPL.getlogp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getlogp(vi::VarInfo)</code></pre><p>Return the log of the joint probability of the observed data and parameters sampled in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L649-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getmetadata-Tuple{VarInfo, VarName}" href="#DynamicPPL.getmetadata-Tuple{VarInfo, VarName}"><code>DynamicPPL.getmetadata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getmetadata(vi::VarInfo, vn::VarName)</code></pre><p>Return the metadata in <code>vi</code> that belongs to <code>vn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L248-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getmissings-Union{Tuple{Model{_F, _a, _d, missings}}, Tuple{_d}, Tuple{_a}, Tuple{_F}, Tuple{missings}} where {missings, _F, _a, _d}" href="#DynamicPPL.getmissings-Union{Tuple{Model{_F, _a, _d, missings}}, Tuple{_d}, Tuple{_a}, Tuple{_F}, Tuple{missings}} where {missings, _F, _a, _d}"><code>DynamicPPL.getmissings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getmissings(model::Model)</code></pre><p>Get a tuple of the names of the missing arguments of the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L506-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getrange-Tuple{VarInfo, VarName}" href="#DynamicPPL.getrange-Tuple{VarInfo, VarName}"><code>DynamicPPL.getrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getrange(vi::VarInfo, vn::VarName)</code></pre><p>Return the index range of <code>vn</code> in the metadata of <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L263-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getranges-Tuple{AbstractVarInfo, Vector{&lt;:VarName}}" href="#DynamicPPL.getranges-Tuple{AbstractVarInfo, Vector{&lt;:VarName}}"><code>DynamicPPL.getranges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getranges(vi::AbstractVarInfo, vns::Vector{&lt;:VarName})</code></pre><p>Return the indices of <code>vns</code> in the metadata of <code>vi</code> corresponding to <code>vn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getval-Tuple{AbstractVarInfo, Vector{&lt;:VarName}}" href="#DynamicPPL.getval-Tuple{AbstractVarInfo, Vector{&lt;:VarName}}"><code>DynamicPPL.getval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getval(vi::VarInfo, vns::Vector{&lt;:VarName})</code></pre><p>Return the value(s) of <code>vns</code>.</p><p>The values may or may not be transformed to Euclidean space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L304-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getval-Tuple{UntypedVarInfo, Union{Int64, UnitRange, Vector{Int64}}}" href="#DynamicPPL.getval-Tuple{UntypedVarInfo, Union{Int64, UnitRange, Vector{Int64}}}"><code>DynamicPPL.getval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getval(vi::UntypedVarInfo, vview::Union{Int, UnitRange, Vector{Int}})</code></pre><p>Return a view <code>vi.vals[vview]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getval-Tuple{VarInfo, VarName}" href="#DynamicPPL.getval-Tuple{VarInfo, VarName}"><code>DynamicPPL.getval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getval(vi::VarInfo, vn::VarName)</code></pre><p>Return the value(s) of <code>vn</code>.</p><p>The values may or may not be transformed to Euclidean space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L286-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getvalue-Tuple{AbstractPPL.AbstractContext, Any}" href="#DynamicPPL.getvalue-Tuple{AbstractPPL.AbstractContext, Any}"><code>DynamicPPL.getvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getvalue(context, vn)</code></pre><p>Return value of <code>vn</code> in <code>context</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L326-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.getvalue_nested-Tuple{AbstractPPL.AbstractContext, Any}" href="#DynamicPPL.getvalue_nested-Tuple{AbstractPPL.AbstractContext, Any}"><code>DynamicPPL.getvalue_nested</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getvalue_nested(context, vn)</code></pre><p>Return the value of the parameter corresponding to <code>vn</code> from <code>context</code> or its descendants.</p><p>This is contrast to <a href="#DynamicPPL.getvalue-Tuple{AbstractPPL.AbstractContext, Any}"><code>getvalue</code></a> which only returns the value <code>vn</code> in <code>context</code>, not recursively looking into its descendants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L355-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.hasvalue-Tuple{Any, Any}" href="#DynamicPPL.hasvalue-Tuple{Any, Any}"><code>DynamicPPL.hasvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasvalue(context, vn)</code></pre><p>Return <code>true</code> if <code>vn</code> is found in <code>context</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L310-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.hasvalue_nested-Tuple{AbstractPPL.AbstractContext, Any}" href="#DynamicPPL.hasvalue_nested-Tuple{AbstractPPL.AbstractContext, Any}"><code>DynamicPPL.hasvalue_nested</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasvalue_nested(context, vn)</code></pre><p>Return <code>true</code> if <code>vn</code> is found in <code>context</code> or any of its descendants.</p><p>This is contrast to <a href="#DynamicPPL.hasvalue-Tuple{Any, Any}"><code>hasvalue</code></a> which only checks for <code>vn</code> in <code>context</code>, not recursively checking if <code>vn</code> is in any of its descendants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L336-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.inargnames-Union{Tuple{_F}, Tuple{argnames}, Tuple{s}, Tuple{VarName{s}, Model{_F, argnames}}} where {s, argnames, _F}" href="#DynamicPPL.inargnames-Union{Tuple{_F}, Tuple{argnames}, Tuple{s}, Tuple{VarName{s}, Model{_F, argnames}}} where {s, argnames, _F}"><code>DynamicPPL.inargnames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inargnames(varname::VarName, model::Model)</code></pre><p>Statically check whether the variable of name <code>varname</code> is an argument of the <code>model</code>.</p><p>Possibly existing indices of <code>varname</code> are neglected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varname.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.increment_num_produce!-Tuple{VarInfo}" href="#DynamicPPL.increment_num_produce!-Tuple{VarInfo}"><code>DynamicPPL.increment_num_produce!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">increment_num_produce!(vi::VarInfo)</code></pre><p>Add 1 to <code>num_produce</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L701-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.initialsampler-Tuple{Sampler}" href="#DynamicPPL.initialsampler-Tuple{Sampler}"><code>DynamicPPL.initialsampler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialsampler(sampler::Sampler)</code></pre><p>Return the sampler that is used for generating the initial parameters when sampling with <code>sampler</code>.</p><p>By default, it returns an instance of <a href="#DynamicPPL.SampleFromPrior"><code>SampleFromPrior</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/sampler.jl#L109-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.initialstep" href="#DynamicPPL.initialstep"><code>DynamicPPL.initialstep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialstep(rng, model, sampler, varinfo; kwargs...)</code></pre><p>Perform the initial sampling step of the <code>sampler</code> for the <code>model</code>.</p><p>The <code>varinfo</code> contains the initial samples, which can be provided by the user or sampled randomly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/sampler.jl#L155-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.inmissings-Union{Tuple{_T}, Tuple{_a}, Tuple{_F}, Tuple{missings}, Tuple{s}, Tuple{VarName{s}, Model{_F, _a, _T, missings}}} where {s, missings, _F, _a, _T}" href="#DynamicPPL.inmissings-Union{Tuple{_T}, Tuple{_a}, Tuple{_F}, Tuple{missings}, Tuple{s}, Tuple{VarName{s}, Model{_F, _a, _T, missings}}} where {s, missings, _F, _a, _T}"><code>DynamicPPL.inmissings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inmissings(varname::VarName, model::Model)</code></pre><p>Statically check whether the variable of name <code>varname</code> is a statically declared unobserved variable of the <code>model</code>.</p><p>Possibly existing indices of <code>varname</code> are neglected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varname.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.invlink!-Tuple{UntypedVarInfo, AbstractMCMC.AbstractSampler}" href="#DynamicPPL.invlink!-Tuple{UntypedVarInfo, AbstractMCMC.AbstractSampler}"><code>DynamicPPL.invlink!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invlink!(vi::VarInfo, spl::AbstractSampler)</code></pre><p>Transform the values of the random variables sampled by <code>spl</code> in <code>vi</code> from the Euclidean space back to the support of their distributions and sets their corresponding <code>&quot;trans&quot;</code> flag values to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L801-L807">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.is_flagged-Tuple{VarInfo, VarName, String}" href="#DynamicPPL.is_flagged-Tuple{VarInfo, VarName, String}"><code>DynamicPPL.is_flagged</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_flagged(vi::VarInfo, vn::VarName, flag::String)</code></pre><p>Check whether <code>vn</code> has a true value for <code>flag</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1184-L1188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.isassumption" href="#DynamicPPL.isassumption"><code>DynamicPPL.isassumption</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isassumption(expr[, vn])</code></pre><p>Return an expression that can be evaluated to check if <code>expr</code> is an assumption in the model.</p><p>Let <code>expr</code> be <code>:(x[1])</code>. It is an assumption in the following cases:     1. <code>x</code> is not among the input data to the model,     2. <code>x</code> is among the input data to the model but with a value <code>missing</code>, or     3. <code>x</code> is among the input data to the model with a value other than missing,        but <code>x[1] === missing</code>.</p><p>When <code>expr</code> is not an expression or symbol (i.e., a literal), this expands to <code>false</code>.</p><p>If <code>vn</code> is specified, it will be assumed to refer to a expression which evaluates to a <code>VarName</code>, and this will be used in the subsequent checks. If <code>vn</code> is not specified, <code>AbstractPPL.drop_escape(varname(expr))</code> will be used in its place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.isfuncdef-Tuple{Expr}" href="#DynamicPPL.isfuncdef-Tuple{Expr}"><code>DynamicPPL.isfuncdef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isfuncdef(expr)</code></pre><p>Return <code>true</code> if <code>expr</code> is any form of function definition, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L485-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.islinked-Tuple{UntypedVarInfo, Union{SampleFromPrior, Sampler}}" href="#DynamicPPL.islinked-Tuple{UntypedVarInfo, Union{SampleFromPrior, Sampler}}"><code>DynamicPPL.islinked</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">islinked(vi::VarInfo, spl::Union{Sampler, SampleFromPrior})</code></pre><p>Check whether <code>vi</code> is in the transformed space for a particular sampler <code>spl</code>.</p><p>Turing&#39;s Hamiltonian samplers use the <code>link</code> and <code>invlink</code> functions from  <a href="https://github.com/TuringLang/Bijectors.jl">Bijectors.jl</a> to map a constrained variable (for example, one bounded to the space <code>[0, 1]</code>) from its constrained space to the set of  real numbers. <code>islinked</code> checks if the number is in the constrained space or the real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L869-L878">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.isliteral-Tuple{Any}" href="#DynamicPPL.isliteral-Tuple{Any}"><code>DynamicPPL.isliteral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isliteral(expr)</code></pre><p>Return <code>true</code> if <code>expr</code> is a literal, e.g. <code>1.0</code> or <code>[1.0, ]</code>, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.istrans-Tuple{AbstractVarInfo, VarName}" href="#DynamicPPL.istrans-Tuple{AbstractVarInfo, VarName}"><code>DynamicPPL.istrans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">istrans(vi::VarInfo, vn::VarName)</code></pre><p>Return true if <code>vn</code>&#39;s values in <code>vi</code> are transformed to Euclidean space, and false if they are in the support of <code>vn</code>&#39;s distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L641-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.leafcontext-Tuple{Any}" href="#DynamicPPL.leafcontext-Tuple{Any}"><code>DynamicPPL.leafcontext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leafcontext(context)</code></pre><p>Return the leaf of <code>context</code>, i.e. the first descendant context that <code>IsLeaf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.link!-Tuple{UntypedVarInfo, Sampler}" href="#DynamicPPL.link!-Tuple{UntypedVarInfo, Sampler}"><code>DynamicPPL.link!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">link!(vi::VarInfo, spl::Sampler)</code></pre><p>Transform the values of the random variables sampled by <code>spl</code> in <code>vi</code> from the support of their distributions to the Euclidean space and set their corresponding <code>&quot;trans&quot;</code> flag values to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L732-L738">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.loadstate" href="#DynamicPPL.loadstate"><code>DynamicPPL.loadstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loadstate(data)</code></pre><p>Load sampler state from <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/sampler.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.logjoint-Tuple{Model, AbstractVarInfo}" href="#DynamicPPL.logjoint-Tuple{Model, AbstractVarInfo}"><code>DynamicPPL.logjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logjoint(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log joint probability of variables <code>varinfo</code> for the probabilistic <code>model</code>.</p><p>See <a href="#DynamicPPL.logjoint-Tuple{Model, AbstractVarInfo}"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood-Tuple{Model, AbstractVarInfo}"><code>loglikelihood</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L520-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.logjoint-Tuple{Model, Any}" href="#DynamicPPL.logjoint-Tuple{Model, Any}"><code>DynamicPPL.logjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logjoint(model::Model, θ)</code></pre><p>Return the log joint probability of variables <code>θ</code> for the probabilistic <code>model</code>.</p><p>See <a href="#DynamicPPL.logjoint-Tuple{Model, AbstractVarInfo}"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood-Tuple{Model, AbstractVarInfo}"><code>loglikelihood</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1.0)
           end
       end
demo (generic function with 2 methods)

julia&gt; # Using a `NamedTuple`.
       logjoint(demo([1.0]), (m = 100.0, ))
-9902.33787706641

julia&gt; # Using a `Dict`.
       logjoint(demo([1.0]), Dict(@varname(m) =&gt; 100.0))
-9902.33787706641

julia&gt; # Truth.
       logpdf(Normal(100.0, 1.0), 1.0) + logpdf(Normal(), 100.0)
-9902.33787706641</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/simple_varinfo.jl#L426-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.logprior-Tuple{Model, AbstractVarInfo}" href="#DynamicPPL.logprior-Tuple{Model, AbstractVarInfo}"><code>DynamicPPL.logprior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logprior(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log prior probability of variables <code>varinfo</code> for the probabilistic <code>model</code>.</p><p>See also <a href="#DynamicPPL.logjoint-Tuple{Model, AbstractVarInfo}"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood-Tuple{Model, AbstractVarInfo}"><code>loglikelihood</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L531-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.logprior-Tuple{Model, Any}" href="#DynamicPPL.logprior-Tuple{Model, Any}"><code>DynamicPPL.logprior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logprior(model::Model, θ)</code></pre><p>Return the log prior probability of variables <code>θ</code> for the probabilistic <code>model</code>.</p><p>See also <a href="#DynamicPPL.logjoint-Tuple{Model, AbstractVarInfo}"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood-Tuple{Model, AbstractVarInfo}"><code>loglikelihood</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1.0)
           end
       end
demo (generic function with 2 methods)

julia&gt; # Using a `NamedTuple`.
       logprior(demo([1.0]), (m = 100.0, ))
-5000.918938533205

julia&gt; # Using a `Dict`.
       logprior(demo([1.0]), Dict(@varname(m) =&gt; 100.0))
-5000.918938533205

julia&gt; # Truth.
       logpdf(Normal(), 100.0)
-5000.918938533205</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/simple_varinfo.jl#L458-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.matchingvalue-Tuple{Any, Any, Any}" href="#DynamicPPL.matchingvalue-Tuple{Any, Any, Any}"><code>DynamicPPL.matchingvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matchingvalue(sampler, vi, value)
matchingvalue(context::AbstractContext, vi, value)</code></pre><p>Convert the <code>value</code> to the correct type for the <code>sampler</code> or <code>context</code> and the <code>vi</code> object.</p><p>For a <code>context</code> that is <em>not</em> a <code>SamplingContext</code>, we fall back to <code>matchingvalue(SampleFromPrior(), vi, value)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L623-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.observations-Tuple{Model}" href="#DynamicPPL.observations-Tuple{Model}"><code>DynamicPPL.observations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">observations(model::Model)</code></pre><p>Alias for <a href="#DynamicPPL.conditioned-Tuple{AbstractPPL.AbstractContext}"><code>conditioned</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L314-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.parent-Tuple{Setfield.Lens}" href="#DynamicPPL.parent-Tuple{Setfield.Lens}"><code>DynamicPPL.parent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parent(lens::Setfield.Lens)</code></pre><p>Return the parent lens. If <code>lens</code> doesn&#39;t have a parent, <code>nothing</code> is returned.</p><p>See also: [<code>parent_and_child</code>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; parent(@lens(_.a[1]))
(@lens _.a)

julia&gt; # Parent of lens without parents results in `nothing`.
       (parent ∘ parent)(@lens(_.a[1])) === nothing
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/utils.jl#L235-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.parent-Tuple{VarName}" href="#DynamicPPL.parent-Tuple{VarName}"><code>DynamicPPL.parent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parent(vn::VarName)</code></pre><p>Return the parent <code>VarName</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; parent(@varname(x.a[1]))
x.a

julia&gt; (parent ∘ parent)(@varname(x.a[1]))
x

julia&gt; (parent ∘ parent ∘ parent)(@varname(x.a[1]))
x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/utils.jl#L213-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.parent_and_child-Tuple{Setfield.Lens}" href="#DynamicPPL.parent_and_child-Tuple{Setfield.Lens}"><code>DynamicPPL.parent_and_child</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parent_and_child(lens::Setfield.Lens)</code></pre><p>Return a 2-tuple of lenses <code>(parent, child)</code> where <code>parent</code> is the parent lens of <code>lens</code> and <code>child</code> is the child lens of <code>lens</code>.</p><p>If <code>lens</code> does not have a parent, we return <code>(nothing, lens)</code>.</p><p>See also: [<code>parent</code>].</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; parent_and_child(@lens(_.a[1]))
((@lens _.a), (@lens _[1]))

julia&gt; parent_and_child(@lens(_.a))
(nothing, (@lens _.a))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/utils.jl#L255-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.pointwise_loglikelihoods-Union{Tuple{T}, Tuple{Model, Any}, Tuple{Model, Any, Type{T}}} where T" href="#DynamicPPL.pointwise_loglikelihoods-Union{Tuple{T}, Tuple{Model, Any}, Tuple{Model, Any, Type{T}}} where T"><code>DynamicPPL.pointwise_loglikelihoods</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointwise_loglikelihoods(model::Model, chain::Chains, keytype = String)</code></pre><p>Runs <code>model</code> on each sample in <code>chain</code> returning a <code>Dict{String, Matrix{Float64}}</code> with keys corresponding to symbols of the observations, and values being matrices of shape <code>(num_chains, num_samples)</code>.</p><p><code>keytype</code> specifies what the type of the keys used in the returned <code>Dict</code> are. Currently, only <code>String</code> and <code>VarName</code> are supported.</p><p><strong>Notes</strong></p><p>Say <code>y</code> is a <code>Vector</code> of <code>n</code> i.i.d. <code>Normal(μ, σ)</code> variables, with <code>μ</code> and <code>σ</code> both being <code>&lt;:Real</code>. Then the <em>observe</em> (i.e. when the left-hand side is an <em>observation</em>) statements can be implemented in three ways:</p><ol><li>using a <code>for</code> loop:</li></ol><pre><code class="language-julia hljs">for i in eachindex(y)
    y[i] ~ Normal(μ, σ)
end</code></pre><ol><li>using <code>.~</code>:</li></ol><pre><code class="language-julia hljs">y .~ Normal(μ, σ)</code></pre><ol><li>using <code>MvNormal</code>:</li></ol><pre><code class="language-julia hljs">y ~ MvNormal(fill(μ, n), σ^2 * I)</code></pre><p>In (1) and (2), <code>y</code> will be treated as a collection of <code>n</code> i.i.d. 1-dimensional variables, while in (3) <code>y</code> will be treated as a <em>single</em> n-dimensional observation.</p><p>This is important to keep in mind, in particular if the computation is used for downstream computations.</p><p><strong>Examples</strong></p><p><strong>From chain</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Turing

julia&gt; @model function demo(xs, y)
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, √s)
           for i in eachindex(xs)
               xs[i] ~ Normal(m, √s)
           end

           y ~ Normal(m, √s)
       end
demo (generic function with 1 method)

julia&gt; model = demo(randn(3), randn());

julia&gt; chain = sample(model, MH(), 10);

julia&gt; pointwise_loglikelihoods(model, chain)
Dict{String,Array{Float64,2}} with 4 entries:
  &quot;xs[3]&quot; =&gt; [-1.42862; -2.67573; … ; -1.66251; -1.66251]
  &quot;xs[1]&quot; =&gt; [-1.42932; -2.68123; … ; -1.66333; -1.66333]
  &quot;xs[2]&quot; =&gt; [-1.6724; -0.861339; … ; -1.62359; -1.62359]
  &quot;y&quot;     =&gt; [-1.51265; -0.914129; … ; -1.5499; -1.5499]

julia&gt; pointwise_loglikelihoods(model, chain, String)
Dict{String,Array{Float64,2}} with 4 entries:
  &quot;xs[3]&quot; =&gt; [-1.42862; -2.67573; … ; -1.66251; -1.66251]
  &quot;xs[1]&quot; =&gt; [-1.42932; -2.68123; … ; -1.66333; -1.66333]
  &quot;xs[2]&quot; =&gt; [-1.6724; -0.861339; … ; -1.62359; -1.62359]
  &quot;y&quot;     =&gt; [-1.51265; -0.914129; … ; -1.5499; -1.5499]

julia&gt; pointwise_loglikelihoods(model, chain, VarName)
Dict{VarName,Array{Float64,2}} with 4 entries:
  xs[2] =&gt; [-1.6724; -0.861339; … ; -1.62359; -1.62359]
  y     =&gt; [-1.51265; -0.914129; … ; -1.5499; -1.5499]
  xs[1] =&gt; [-1.42932; -2.68123; … ; -1.66333; -1.66333]
  xs[3] =&gt; [-1.42862; -2.67573; … ; -1.66251; -1.66251]</code></pre><p><strong>Broadcasting</strong></p><p>Note that <code>x .~ Dist()</code> will treat <code>x</code> as a collection of <em>independent</em> observations rather than as a single observation.</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           x .~ Normal()
       end;

julia&gt; m = demo([1.0, ]);

julia&gt; ℓ = pointwise_loglikelihoods(m, VarInfo(m)); first(ℓ[@varname(x[1])])
-1.4189385332046727

julia&gt; m = demo([1.0; 1.0]);

julia&gt; ℓ = pointwise_loglikelihoods(m, VarInfo(m)); first.((ℓ[@varname(x[1])], ℓ[@varname(x[2])]))
(-1.4189385332046727, -1.4189385332046727)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/loglikelihoods.jl#L126-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.replace_returns-Tuple{Any}" href="#DynamicPPL.replace_returns-Tuple{Any}"><code>DynamicPPL.replace_returns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_returns(expr)</code></pre><p>Return <code>Expr</code> with all <code>return ...</code> statements replaced with <code>return ..., DynamicPPL.return_values(__varinfo__)</code>.</p><p>Note that this method will <em>not</em> replace <code>return</code> statements within function definitions. This is checked using <a href="#DynamicPPL.isfuncdef-Tuple{Expr}"><code>isfuncdef</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L505-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.reset_num_produce!-Tuple{AbstractVarInfo}" href="#DynamicPPL.reset_num_produce!-Tuple{AbstractVarInfo}"><code>DynamicPPL.reset_num_produce!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset_num_produce!(vi::AbstractVarInfo)</code></pre><p>Reset the value of <code>num_produce</code> the log of the joint probability of the observed data and parameters sampled in <code>vi</code> to 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L708-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.resetlogp!!-Tuple{AbstractVarInfo}" href="#DynamicPPL.resetlogp!!-Tuple{AbstractVarInfo}"><code>DynamicPPL.resetlogp!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resetlogp!!(vi::AbstractVarInfo)</code></pre><p>Reset the value of the log of the joint probability of the observed data and parameters sampled in <code>vi</code> to 0, mutating if it makes sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L679-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.set_flag!-Tuple{VarInfo, VarName, String}" href="#DynamicPPL.set_flag!-Tuple{VarInfo, VarName, String}"><code>DynamicPPL.set_flag!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_flag!(vi::VarInfo, vn::VarName, flag::String)</code></pre><p>Set <code>vn</code>&#39;s value for <code>flag</code> to <code>true</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L508-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.set_num_produce!-Tuple{VarInfo, Int64}" href="#DynamicPPL.set_num_produce!-Tuple{VarInfo, Int64}"><code>DynamicPPL.set_num_produce!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_num_produce!(vi::VarInfo, n::Int)</code></pre><p>Set the <code>num_produce</code> field of <code>vi</code> to <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L694-L698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.set_retained_vns_del_by_spl!-Tuple{UntypedVarInfo, Sampler}" href="#DynamicPPL.set_retained_vns_del_by_spl!-Tuple{UntypedVarInfo, Sampler}"><code>DynamicPPL.set_retained_vns_del_by_spl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_retained_vns_del_by_spl!(vi::VarInfo, spl::Sampler)</code></pre><p>Set the <code>&quot;del&quot;</code> flag of variables in <code>vi</code> with <code>order &gt; vi.num_produce[]</code> to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1203-L1207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.setall!-Tuple{UntypedVarInfo, Any}" href="#DynamicPPL.setall!-Tuple{UntypedVarInfo, Any}"><code>DynamicPPL.setall!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setall!(vi::VarInfo, val)</code></pre><p>Set the values of all the variables in <code>vi</code> to <code>val</code>.</p><p>The values may or may not be transformed to Euclidean space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L332-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.setchildcontext" href="#DynamicPPL.setchildcontext"><code>DynamicPPL.setchildcontext</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setchildcontext(parent::AbstractContext, child::AbstractContext)</code></pre><p>Reconstruct <code>parent</code> but now using <code>child</code> is its <a href="#DynamicPPL.childcontext"><code>childcontext</code></a>, effectively updating the child context.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ctx = SamplingContext();

julia&gt; DynamicPPL.childcontext(ctx)
DefaultContext()

julia&gt; ctx_prior = DynamicPPL.setchildcontext(ctx, PriorContext()); # only compute the logprior

julia&gt; DynamicPPL.childcontext(ctx_prior)
PriorContext{Nothing}(nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L40-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.setgid!-Tuple{VarInfo, DynamicPPL.Selector, VarName}" href="#DynamicPPL.setgid!-Tuple{VarInfo, DynamicPPL.Selector, VarName}"><code>DynamicPPL.setgid!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setgid!(vi::VarInfo, gid::Selector, vn::VarName)</code></pre><p>Add <code>gid</code> to the set of sampler selectors associated with <code>vn</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L632-L636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.setleafcontext-Tuple{Any, Any}" href="#DynamicPPL.setleafcontext-Tuple{Any, Any}"><code>DynamicPPL.setleafcontext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setleafcontext(left, right)</code></pre><p>Return <code>left</code> but now with its leaf context replaced by <code>right</code>.</p><p>Note that this also works even if <code>right</code> is not a leaf context, in which case effectively append <code>right</code> to <code>left</code>, dropping the original leaf context of <code>left</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL: leafcontext, setleafcontext, childcontext, setchildcontext, AbstractContext

julia&gt; struct ParentContext{C} &lt;: AbstractContext
           context::C
       end

julia&gt; DynamicPPL.NodeTrait(::ParentContext) = DynamicPPL.IsParent()

julia&gt; DynamicPPL.childcontext(context::ParentContext) = context.context

julia&gt; DynamicPPL.setchildcontext(::ParentContext, child) = ParentContext(child)

julia&gt; Base.show(io::IO, c::ParentContext) = print(io, &quot;ParentContext(&quot;, childcontext(c), &quot;)&quot;)

julia&gt; ctx = ParentContext(ParentContext(DefaultContext()))
ParentContext(ParentContext(DefaultContext()))

julia&gt; # Replace the leaf context with another leaf.
       leafcontext(setleafcontext(ctx, PriorContext()))
PriorContext{Nothing}(nothing)

julia&gt; # Append another parent context.
       setleafcontext(ctx, ParentContext(DefaultContext()))
ParentContext(ParentContext(ParentContext(DefaultContext())))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/contexts.jl#L70-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.setlogp!!-Tuple{VarInfo, Any}" href="#DynamicPPL.setlogp!!-Tuple{VarInfo, Any}"><code>DynamicPPL.setlogp!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setlogp!!(vi::VarInfo, logp)</code></pre><p>Set the log of the joint probability of the observed data and parameters sampled in <code>vi</code> to <code>logp</code>, mutating if it makes sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L657-L662">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.setorder!-Tuple{VarInfo, VarName, Int64}" href="#DynamicPPL.setorder!-Tuple{VarInfo, VarName, Int64}"><code>DynamicPPL.setorder!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setorder!(vi::VarInfo, vn::VarName, index::Int)</code></pre><p>Set the <code>order</code> of <code>vn</code> in <code>vi</code> to <code>index</code>, where <code>order</code> is the number of <code>observe statements run before sampling</code>vn`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1166-L1171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.settrans!-Tuple{AbstractVarInfo, Bool, VarName}" href="#DynamicPPL.settrans!-Tuple{AbstractVarInfo, Bool, VarName}"><code>DynamicPPL.settrans!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">settrans!(vi::VarInfo, trans::Bool, vn::VarName)</code></pre><p>Set the <code>trans</code> flag value of <code>vn</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L360-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.setval!-Tuple{AbstractVarInfo, Any}" href="#DynamicPPL.setval!-Tuple{AbstractVarInfo, Any}"><code>DynamicPPL.setval!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setval!(vi::AbstractVarInfo, x)
setval!(vi::AbstractVarInfo, values, keys)
setval!(vi::AbstractVarInfo, chains::AbstractChains, sample_idx::Int, chain_idx::Int)</code></pre><p>Set the values in <code>vi</code> to the provided values and leave those which are not present in <code>x</code> or <code>chains</code> unchanged.</p><p><strong>Notes</strong></p><p>This is rather limited for two reasons:</p><ol><li>It uses <code>subsumes_string(string(vn), map(string, keys))</code> under the hood, and therefore suffers from the same limitations as <a href="#DynamicPPL.subsumes_string"><code>subsumes_string</code></a>.</li><li>It will set every <code>vn</code> present in <code>keys</code>. It will NOT however set every <code>k</code> present in <code>keys</code>. This means that if <code>vn == [m[1], m[2]]</code>, representing some variable <code>m</code>, calling <code>setval!(vi, (m = [1.0, 2.0]))</code> will be a no-op since it will try to find <code>m[1]</code> and <code>m[2]</code> in <code>keys((m = [1.0, 2.0]))</code>.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions, StableRNGs

julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1)
           end
       end;

julia&gt; rng = StableRNG(42);

julia&gt; m = demo([missing]);

julia&gt; var_info = DynamicPPL.VarInfo(rng, m);

julia&gt; var_info[@varname(m)]
-0.6702516921145671

julia&gt; var_info[@varname(x[1])]
-0.22312984965118443

julia&gt; DynamicPPL.setval!(var_info, (m = 100.0, )); # set `m` and and keep `x[1]`

julia&gt; var_info[@varname(m)] # [✓] changed
100.0

julia&gt; var_info[@varname(x[1])] # [✓] unchanged
-0.22312984965118443

julia&gt; m(rng, var_info); # rerun model

julia&gt; var_info[@varname(m)] # [✓] unchanged
100.0

julia&gt; var_info[@varname(x[1])] # [✓] unchanged
-0.22312984965118443</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1344-L1400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.setval!-Tuple{UntypedVarInfo, Any, Union{Int64, UnitRange, Vector{Int64}}}" href="#DynamicPPL.setval!-Tuple{UntypedVarInfo, Any, Union{Int64, UnitRange, Vector{Int64}}}"><code>DynamicPPL.setval!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setval!(vi::UntypedVarInfo, val, vview::Union{Int, UnitRange, Vector{Int}})</code></pre><p>Set the value of <code>vi.vals[vview]</code> to <code>val</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.setval!-Tuple{VarInfo, Any, VarName}" href="#DynamicPPL.setval!-Tuple{VarInfo, Any, VarName}"><code>DynamicPPL.setval!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setval!(vi::VarInfo, val, vn::VarName)</code></pre><p>Set the value(s) of <code>vn</code> in the metadata of <code>vi</code> to <code>val</code>.</p><p>The values may or may not be transformed to Euclidean space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L295-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.setval_and_resample!-Tuple{AbstractVarInfo, Any}" href="#DynamicPPL.setval_and_resample!-Tuple{AbstractVarInfo, Any}"><code>DynamicPPL.setval_and_resample!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setval_and_resample!(vi::AbstractVarInfo, x)
setval_and_resample!(vi::AbstractVarInfo, values, keys)
setval_and_resample!(vi::AbstractVarInfo, chains::AbstractChains, sample_idx, chain_idx)</code></pre><p>Set the values in <code>vi</code> to the provided values and those which are not present in <code>x</code> or <code>chains</code> to <em>be</em> resampled.</p><p>Note that this does <em>not</em> resample the values not provided! It will call <code>setflag!(vi, vn, &quot;del&quot;)</code> for variables <code>vn</code> for which no values are provided, which means that the next time we call <code>model(vi)</code> these variables will be resampled.</p><p><strong>Note</strong></p><ul><li>This suffers from the same limitations as <a href="#DynamicPPL.setval!-Tuple{AbstractVarInfo, Any}"><code>setval!</code></a>. See <code>setval!</code> for more info.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions, StableRNGs

julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1)
           end
       end;

julia&gt; rng = StableRNG(42);

julia&gt; m = demo([missing]);

julia&gt; var_info = DynamicPPL.VarInfo(rng, m);

julia&gt; var_info[@varname(m)]
-0.6702516921145671

julia&gt; var_info[@varname(x[1])]
-0.22312984965118443

julia&gt; DynamicPPL.setval_and_resample!(var_info, (m = 100.0, )); # set `m` and ready `x[1]` for resampling

julia&gt; var_info[@varname(m)] # [✓] changed
100.0

julia&gt; var_info[@varname(x[1])] # [✓] unchanged
-0.22312984965118443

julia&gt; m(rng, var_info); # sample `x[1]` conditioned on `m = 100.0`

julia&gt; var_info[@varname(m)] # [✓] unchanged
100.0

julia&gt; var_info[@varname(x[1])] # [✓] changed
101.37363069798343</code></pre><p><strong>See also</strong></p><ul><li><a href="#DynamicPPL.setval!-Tuple{AbstractVarInfo, Any}"><code>setval!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1420-L1477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.splitlens-Tuple{Any, Any}" href="#DynamicPPL.splitlens-Tuple{Any, Any}"><code>DynamicPPL.splitlens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splitlens(condition, lens)</code></pre><p>Return a 3-tuple <code>(parent, child, issuccess)</code> where, if <code>issuccess</code> is <code>true</code>, <code>parent</code> is a lens such that <code>condition(parent)</code> is <code>true</code> and <code>parent ∘ child == lens</code>.</p><p>If <code>issuccess</code> is <code>false</code>, then no such split could be found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p, c, issucesss = splitlens(@lens(_.a[1])) do parent
           # Succeeds!
           parent == @lens(_.a)
       end
((@lens _.a), (@lens _[1]), true)

julia&gt; p ∘ c
(@lens _.a[1])

julia&gt; splitlens(@lens(_.a[1])) do parent
           # Fails!
           parent == @lens(_.b)
       end
(nothing, (@lens _.a[1]), false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/utils.jl#L281-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.subsumes_string" href="#DynamicPPL.subsumes_string"><code>DynamicPPL.subsumes_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subsumes_string(u::String, v::String[, u_indexing])</code></pre><p>Check whether stringified variable name <code>v</code> describes a sub-range of stringified variable <code>u</code>.</p><p>This is a very restricted version <code>subumes(u::VarName, v::VarName)</code> only really supporting:</p><ul><li>Scalar: <code>x</code> subsumes <code>x[1, 2]</code>, <code>x[1, 2]</code> subsumes <code>x[1, 2][3]</code>, etc.</li></ul><p><strong>Note</strong></p><ul><li>To get same matching capabilities as <code>AbstractPPL.subumes(u::VarName, v::VarName)</code>  for strings, one can always do <code>eval(varname(Meta.parse(u))</code> to get <code>VarName</code> of <code>u</code>, and similarly to <code>v</code>. But this is slow.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varname.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.syms-Tuple{UntypedVarInfo}" href="#DynamicPPL.syms-Tuple{UntypedVarInfo}"><code>DynamicPPL.syms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">syms(vi::VarInfo)</code></pre><p>Returns a tuple of the unique symbols of random variables sampled in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L369-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.tilde_assume!!-NTuple{4, Any}" href="#DynamicPPL.tilde_assume!!-NTuple{4, Any}"><code>DynamicPPL.tilde_assume!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tilde_assume!!(context, right, vn, vi)</code></pre><p>Handle assumed variables, e.g., <code>x ~ Normal()</code> (where <code>x</code> does occur in the model inputs), accumulate the log probability, and return the sampled value and updated <code>vi</code>.</p><p>By default, calls <code>tilde_assume(context, right, vn, vi)</code> and accumulates the log probability of <code>vi</code> with the returned value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/context_implementations.jl#L107-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.tilde_assume-Tuple{SamplingContext, Any, Any, Any}" href="#DynamicPPL.tilde_assume-Tuple{SamplingContext, Any, Any, Any}"><code>DynamicPPL.tilde_assume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tilde_assume(context::SamplingContext, right, vn, vi)</code></pre><p>Handle assumed variables, e.g., <code>x ~ Normal()</code> (where <code>x</code> does occur in the model inputs), accumulate the log probability, and return the sampled value with a context associated with a sampler.</p><p>Falls back to</p><pre><code class="language-julia hljs">tilde_assume(context.rng, context.context, context.sampler, right, vn, vi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/context_implementations.jl#L18-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.tilde_observe!!-NTuple{4, Any}" href="#DynamicPPL.tilde_observe!!-NTuple{4, Any}"><code>DynamicPPL.tilde_observe!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tilde_observe(context, right, left, vi)</code></pre><p>Handle observed constants, e.g., <code>1.0 ~ Normal()</code>, accumulate the log probability, and return the observed value.</p><p>By default, calls <code>tilde_observe(context, right, left, vi)</code> and accumulates the log probability of <code>vi</code> with the returned value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/context_implementations.jl#L173-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.tilde_observe!!-NTuple{5, Any}" href="#DynamicPPL.tilde_observe!!-NTuple{5, Any}"><code>DynamicPPL.tilde_observe!!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tilde_observe!!(context, right, left, vname, vi)</code></pre><p>Handle observed variables, e.g., <code>x ~ Normal()</code> (where <code>x</code> does occur in the model inputs), accumulate the log probability, and return the observed value and updated <code>vi</code>.</p><p>Falls back to <code>tilde_observe!!(context, right, left, vi)</code> ignoring the information about variable name and indices; if needed, these can be accessed through this function, though.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/context_implementations.jl#L160-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.tilde_observe-Tuple{SamplingContext, Any, Any, Any}" href="#DynamicPPL.tilde_observe-Tuple{SamplingContext, Any, Any, Any}"><code>DynamicPPL.tilde_observe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tilde_observe(context::SamplingContext, right, left, vi)</code></pre><p>Handle observed constants with a <code>context</code> associated with a sampler.</p><p>Falls back to <code>tilde_observe(context.context, context.sampler, right, left, vi)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/context_implementations.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.tonamedtuple-Tuple{VarInfo}" href="#DynamicPPL.tonamedtuple-Tuple{VarInfo}"><code>DynamicPPL.tonamedtuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tonamedtuple(vi::VarInfo)</code></pre><p>Convert a <code>vi</code> into a <code>NamedTuple</code> where each variable symbol maps to the values and  indexing string of the variable.</p><p>For example, a model that had a vector of vector-valued variables <code>x</code> would return</p><pre><code class="language-julia hljs">(x = ([1.5, 2.0], [3.0, 1.0], [&quot;x[1]&quot;, &quot;x[2]&quot;]), )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1000-L1012">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.unset_flag!-Tuple{VarInfo, VarName, String}" href="#DynamicPPL.unset_flag!-Tuple{VarInfo, VarName, String}"><code>DynamicPPL.unset_flag!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unset_flag!(vi::VarInfo, vn::VarName, flag::String)</code></pre><p>Set <code>vn</code>&#39;s value for <code>flag</code> to <code>false</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1193-L1197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.unwrap_right_left_vns-Tuple{Any, Any, Any}" href="#DynamicPPL.unwrap_right_left_vns-Tuple{Any, Any, Any}"><code>DynamicPPL.unwrap_right_left_vns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unwrap_right_left_vns(right, left, vns)</code></pre><p>Return the unwrapped distributions on the right-hand side and values and variable names on the left-hand side of a <code>.~</code> expression such as <code>x .~ Normal()</code>.</p><p>This is used mainly to unwrap <code>NamedDist</code> distributions and adjust the indices of the variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; _, _, vns = DynamicPPL.unwrap_right_left_vns(MvNormal(ones(2), I), randn(2, 2), @varname(x)); vns[end]
x[:,2]

julia&gt; _, _, vns = DynamicPPL.unwrap_right_left_vns(Normal(), randn(1, 2), @varname(x)); vns[end]
x[1,2]

julia&gt; _, _, vns = DynamicPPL.unwrap_right_left_vns(Normal(), randn(1, 2), @varname(x[:])); vns[end]
x[:][1,2]

julia&gt; _, _, vns = DynamicPPL.unwrap_right_left_vns(Normal(), randn(3), @varname(x[1])); vns[end]
x[1][3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L127-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.unwrap_right_vn-Tuple{Any, Any}" href="#DynamicPPL.unwrap_right_vn-Tuple{Any, Any}"><code>DynamicPPL.unwrap_right_vn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unwrap_right_vn(right, vn)</code></pre><p>Return the unwrapped distribution on the right-hand side and variable name on the left-hand side of a <code>~</code> expression such as <code>x ~ Normal()</code>.</p><p>This is used mainly to unwrap <code>NamedDist</code> distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.updategid!-Tuple{AbstractVarInfo, VarName, Sampler}" href="#DynamicPPL.updategid!-Tuple{AbstractVarInfo, VarName, Sampler}"><code>DynamicPPL.updategid!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updategid!(vi::VarInfo, vn::VarName, spl::Sampler)</code></pre><p>Set <code>vn</code>&#39;s <code>gid</code> to <code>Set([spl.selector])</code>, if <code>vn</code> does not have a sampler selector linked and <code>vn</code>&#39;s symbol is in the space of <code>spl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1258-L1263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.use_threadsafe_eval-Tuple{AbstractPPL.AbstractContext, AbstractVarInfo}" href="#DynamicPPL.use_threadsafe_eval-Tuple{AbstractPPL.AbstractContext, AbstractVarInfo}"><code>DynamicPPL.use_threadsafe_eval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">use_threadsafe_eval(context::AbstractContext, varinfo::AbstractVarInfo)</code></pre><p>Return <code>true</code> if evaluation of a model using <code>context</code> and <code>varinfo</code> should wrap <code>varinfo</code> in <code>ThreadSafeVarInfo</code>, i.e. threadsafe evaluation, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L379-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.values_as-Tuple{SimpleVarInfo}" href="#DynamicPPL.values_as-Tuple{SimpleVarInfo}"><code>DynamicPPL.values_as</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">values_as(varinfo[, Type])</code></pre><p>Return the values/realizations in <code>varinfo</code> as <code>Type</code>, if implemented.</p><p>If no <code>Type</code> is provided, return values as stored in <code>varinfo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/simple_varinfo.jl#L414-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.values_as-Tuple{UntypedVarInfo, Type{NamedTuple}}" href="#DynamicPPL.values_as-Tuple{UntypedVarInfo, Type{NamedTuple}}"><code>DynamicPPL.values_as</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">values_as(vi::AbstractVarInfo, ::Type{NamedTuple})
values_as(vi::AbstractVarInfo, ::Type{Dict})</code></pre><p>Return values in <code>vi</code> as the specified type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1510-L1515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.values_as-Tuple{VarInfo}" href="#DynamicPPL.values_as-Tuple{VarInfo}"><code>DynamicPPL.values_as</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">values_as(vi::AbstractVarInfo)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/varinfo.jl#L1505-L1507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.loglikelihood-Tuple{Model, AbstractVarInfo}" href="#StatsAPI.loglikelihood-Tuple{Model, AbstractVarInfo}"><code>StatsAPI.loglikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loglikelihood(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log likelihood of variables <code>varinfo</code> for the probabilistic <code>model</code>.</p><p>See also <a href="#DynamicPPL.logjoint-Tuple{Model, AbstractVarInfo}"><code>logjoint</code></a> and <a href="#DynamicPPL.logprior-Tuple{Model, AbstractVarInfo}"><code>logprior</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/model.jl#L542-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.loglikelihood-Tuple{Model, Any}" href="#StatsAPI.loglikelihood-Tuple{Model, Any}"><code>StatsAPI.loglikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loglikelihood(model::Model, θ)</code></pre><p>Return the log likelihood of variables <code>θ</code> for the probabilistic <code>model</code>.</p><p>See also <a href="#DynamicPPL.logjoint-Tuple{Model, AbstractVarInfo}"><code>logjoint</code></a> and <a href="#DynamicPPL.logprior-Tuple{Model, AbstractVarInfo}"><code>logprior</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1.0)
           end
       end
demo (generic function with 2 methods)

julia&gt; # Using a `NamedTuple`.
       loglikelihood(demo([1.0]), (m = 100.0, ))
-4901.418938533205

julia&gt; # Using a `Dict`.
       loglikelihood(demo([1.0]), Dict(@varname(m) =&gt; 100.0))
-4901.418938533205

julia&gt; # Truth.
       logpdf(Normal(100.0, 1.0), 1.0)
-4901.418938533205</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/simple_varinfo.jl#L490-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.@addlogprob!-Tuple{Any}" href="#DynamicPPL.@addlogprob!-Tuple{Any}"><code>DynamicPPL.@addlogprob!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@addlogprob!(ex)</code></pre><p>Add the result of the evaluation of <code>ex</code> to the joint log probability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/utils.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.@model" href="#DynamicPPL.@model"><code>DynamicPPL.@model</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@model(expr[, warn = false])</code></pre><p>Macro to specify a probabilistic model.</p><p>If <code>warn</code> is <code>true</code>, a warning is displayed if internal variable names are used in the model definition.</p><p><strong>Examples</strong></p><p>Model definition:</p><pre><code class="language-julia hljs">@model function model(x, y = 42)
    ...
end</code></pre><p>To generate a <code>Model</code>, call <code>model(xvalue)</code> or <code>model(xvalue, yvalue)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/compiler.jl#L182-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.@submodel-Tuple{Any, Any}" href="#DynamicPPL.@submodel-Tuple{Any, Any}"><code>DynamicPPL.@submodel</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@submodel prefix=... model
@submodel prefix=... ... = model</code></pre><p>Run a Turing <code>model</code> nested inside of a Turing model and add &quot;<code>prefix</code>.&quot; as a prefix to all random variables inside of the <code>model</code>.</p><p>Valid expressions for <code>prefix=...</code> are:</p><ul><li><code>prefix=false</code>: no prefix is used.</li><li><code>prefix=true</code>: <em>attempt</em> to automatically determine the prefix from the left-hand side <code>... = model</code> by first converting into a <code>VarName</code>, and then calling <code>Symbol</code> on this.</li><li><code>prefix=expression</code>: results in the prefix <code>Symbol(expression)</code>.</li></ul><p>The prefix makes it possible to run the same Turing model multiple times while keeping track of all random variables correctly.</p><p><strong>Examples</strong></p><p><strong>Example models</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo1(x)
           x ~ Normal()
           return 1 + abs(x)
       end;

julia&gt; @model function demo2(x, y, z)
            @submodel prefix=&quot;sub1&quot; a = demo1(x)
            @submodel prefix=&quot;sub2&quot; b = demo1(y)
            return z ~ Uniform(-a, b)
       end;</code></pre><p>When we sample from the model <code>demo2(missing, missing, 0.4)</code> random variables <code>sub1.x</code> and <code>sub2.x</code> will be sampled:</p><pre><code class="language-julia-repl hljs">julia&gt; vi = VarInfo(demo2(missing, missing, 0.4));

julia&gt; @varname(var&quot;sub1.x&quot;) in keys(vi)
true

julia&gt; @varname(var&quot;sub2.x&quot;) in keys(vi)
true</code></pre><p>Variables <code>a</code> and <code>b</code> are not tracked since they can be computed from the random variables <code>sub1.x</code> and <code>sub2.x</code> that were tracked when running <code>demo1</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @varname(a) in keys(vi)
false

julia&gt; @varname(b) in keys(vi)
false</code></pre><p>We can check that the log joint probability of the model accumulated in <code>vi</code> is correct:</p><pre><code class="language-julia-repl hljs">julia&gt; sub1_x = vi[@varname(var&quot;sub1.x&quot;)];

julia&gt; sub2_x = vi[@varname(var&quot;sub2.x&quot;)];

julia&gt; logprior = logpdf(Normal(), sub1_x) + logpdf(Normal(), sub2_x);

julia&gt; loglikelihood = logpdf(Uniform(-1 - abs(sub1_x), 1 + abs(sub2_x)), 0.4);

julia&gt; getlogp(vi) ≈ logprior + loglikelihood
true</code></pre><p><strong>Different ways of setting the prefix</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model inner() = x ~ Normal()
inner (generic function with 2 methods)

julia&gt; # When `prefix` is unspecified, no prefix is used.
       @model outer() = @submodel a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(x) in keys(VarInfo(outer()))
true

julia&gt; # Explicitely don&#39;t use any prefix.
       @model outer() = @submodel prefix=false a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(x) in keys(VarInfo(outer()))
true

julia&gt; # Automatically determined from `a`.
       @model outer() = @submodel prefix=true a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(var&quot;a.x&quot;) in keys(VarInfo(outer()))
true

julia&gt; # Using a static string.
       @model outer() = @submodel prefix=&quot;my prefix&quot; a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(var&quot;my prefix.x&quot;) in keys(VarInfo(outer()))
true

julia&gt; # Using string interpolation.
       @model outer() = @submodel prefix=&quot;$(inner().name)&quot; a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(var&quot;inner.x&quot;) in keys(VarInfo(outer()))
true

julia&gt; # Or using some arbitrary expression.
       @model outer() = @submodel prefix=1 + 2 a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(var&quot;3.x&quot;) in keys(VarInfo(outer()))
true

julia&gt; # (×) Automatic prefixing without a left-hand side expression does not work!
       @model outer() = @submodel prefix=true inner()
ERROR: LoadError: cannot automatically prefix with no left-hand side
[...]</code></pre><p><strong>Notes</strong></p><ul><li>The choice <code>prefix=expression</code> means that the prefixing will incur a runtime cost. This is also the case for <code>prefix=true</code>, depending on whether the expression on the the right-hand side of <code>... = model</code> requires runtime-information or not, e.g. <code>x = model</code> will result in the <em>static</em> prefix <code>x</code>, while <code>x[i] = model</code> will be resolved at runtime.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/submodel_macro.jl#L49-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicPPL.@submodel-Tuple{Any}" href="#DynamicPPL.@submodel-Tuple{Any}"><code>DynamicPPL.@submodel</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@submodel model
@submodel ... = model</code></pre><p>Run a Turing <code>model</code> nested inside of a Turing model.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo1(x)
           x ~ Normal()
           return 1 + abs(x)
       end;

julia&gt; @model function demo2(x, y)
            @submodel a = demo1(x)
            return y ~ Uniform(0, a)
       end;</code></pre><p>When we sample from the model <code>demo2(missing, 0.4)</code> random variable <code>x</code> will be sampled:</p><pre><code class="language-julia-repl hljs">julia&gt; vi = VarInfo(demo2(missing, 0.4));

julia&gt; @varname(x) in keys(vi)
true</code></pre><p>Variable <code>a</code> is not tracked since it can be computed from the random variable <code>x</code> that was tracked when running <code>demo1</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @varname(a) in keys(vi)
false</code></pre><p>We can check that the log joint probability of the model accumulated in <code>vi</code> is correct:</p><pre><code class="language-julia-repl hljs">julia&gt; x = vi[@varname(x)];

julia&gt; getlogp(vi) ≈ logpdf(Normal(), x) + logpdf(Uniform(0, 1 + abs(x)), 0.4)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/DynamicPPL.jl/blob/083dfa11447e762aaa74a07e08c39f40b39a7d0e/src/submodel_macro.jl#L1-L44">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="test_utils/">TestUtils »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.13 on <span class="colophon-date" title="Monday 28 February 2022 18:26">Monday 28 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

